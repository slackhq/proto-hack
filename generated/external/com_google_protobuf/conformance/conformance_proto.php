<?hh // strict
namespace conformance;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: external/com_google_protobuf/conformance/conformance.proto

newtype WireFormat_enum_t as int = int;
abstract class WireFormat {
  const WireFormat_enum_t UNSPECIFIED = 0;
  const WireFormat_enum_t PROTOBUF = 1;
  const WireFormat_enum_t JSON = 2;
  const WireFormat_enum_t JSPB = 3;
  const WireFormat_enum_t TEXT_FORMAT = 4;
  private static dict<int, string> $itos = dict[
    0 => 'UNSPECIFIED',
    1 => 'PROTOBUF',
    2 => 'JSON',
    3 => 'JSPB',
    4 => 'TEXT_FORMAT',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'UNSPECIFIED' => 0,
    'PROTOBUF' => 1,
    'JSON' => 2,
    'JSPB' => 3,
    'TEXT_FORMAT' => 4,
  ];
  public static function FromMixed(mixed $m): WireFormat_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): WireFormat_enum_t {
    return $i;
  }
}

newtype TestCategory_enum_t as int = int;
abstract class TestCategory {
  const TestCategory_enum_t UNSPECIFIED_TEST = 0;
  const TestCategory_enum_t BINARY_TEST = 1;
  const TestCategory_enum_t JSON_TEST = 2;
  const TestCategory_enum_t JSON_IGNORE_UNKNOWN_PARSING_TEST = 3;
  const TestCategory_enum_t JSPB_TEST = 4;
  const TestCategory_enum_t TEXT_FORMAT_TEST = 5;
  private static dict<int, string> $itos = dict[
    0 => 'UNSPECIFIED_TEST',
    1 => 'BINARY_TEST',
    2 => 'JSON_TEST',
    3 => 'JSON_IGNORE_UNKNOWN_PARSING_TEST',
    4 => 'JSPB_TEST',
    5 => 'TEXT_FORMAT_TEST',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'UNSPECIFIED_TEST' => 0,
    'BINARY_TEST' => 1,
    'JSON_TEST' => 2,
    'JSON_IGNORE_UNKNOWN_PARSING_TEST' => 3,
    'JSPB_TEST' => 4,
    'TEXT_FORMAT_TEST' => 5,
  ];
  public static function FromMixed(mixed $m): TestCategory_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): TestCategory_enum_t {
    return $i;
  }
}

class FailureSet implements \Protobuf\Message {
  public vec<string> $failure;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'failure' => vec<string>,
  ) $s = shape()) {
    $this->failure = $s['failure'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "conformance.FailureSet";
  }

  public static function ParseFrom(string $input): ?FailureSet {
    $msg = new FailureSet();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->failure []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->failure as $elem) {
      $e->writeTag(1, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('failure', 'failure', $this->failure);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'failure':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->failure []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FailureSet)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->failure = $o->failure;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

enum ConformanceRequest_payload_oneof_t: int {
  NOT_SET = 0;
  protobuf_payload = 1;
  json_payload = 2;
  jspb_payload = 7;
  text_payload = 8;
}

interface ConformanceRequest_payload {
  public function WhichOneof(): ConformanceRequest_payload_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): ConformanceRequest_payload;
}

class ConformanceRequest_payload_NOT_SET implements ConformanceRequest_payload {
  public function WhichOneof(): ConformanceRequest_payload_oneof_t {
    return ConformanceRequest_payload_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): ConformanceRequest_payload { return $this; }
}

class ConformanceRequest_payload_protobuf_payload implements ConformanceRequest_payload {
  public function __construct(public string $protobuf_payload) {}

  public function WhichOneof(): ConformanceRequest_payload_oneof_t {
    return ConformanceRequest_payload_oneof_t::protobuf_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(1, 2);;
    $e->writeString($this->protobuf_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBytes('protobuf_payload', 'protobufPayload', $this->protobuf_payload, true);
  }

  public function Copy(): ConformanceRequest_payload {
    return new ConformanceRequest_payload_protobuf_payload($this->protobuf_payload);
  }
}

class ConformanceRequest_payload_json_payload implements ConformanceRequest_payload {
  public function __construct(public string $json_payload) {}

  public function WhichOneof(): ConformanceRequest_payload_oneof_t {
    return ConformanceRequest_payload_oneof_t::json_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(2, 2);;
    $e->writeString($this->json_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('json_payload', 'jsonPayload', $this->json_payload, true);
  }

  public function Copy(): ConformanceRequest_payload {
    return new ConformanceRequest_payload_json_payload($this->json_payload);
  }
}

class ConformanceRequest_payload_jspb_payload implements ConformanceRequest_payload {
  public function __construct(public string $jspb_payload) {}

  public function WhichOneof(): ConformanceRequest_payload_oneof_t {
    return ConformanceRequest_payload_oneof_t::jspb_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(7, 2);;
    $e->writeString($this->jspb_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('jspb_payload', 'jspbPayload', $this->jspb_payload, true);
  }

  public function Copy(): ConformanceRequest_payload {
    return new ConformanceRequest_payload_jspb_payload($this->jspb_payload);
  }
}

class ConformanceRequest_payload_text_payload implements ConformanceRequest_payload {
  public function __construct(public string $text_payload) {}

  public function WhichOneof(): ConformanceRequest_payload_oneof_t {
    return ConformanceRequest_payload_oneof_t::text_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(8, 2);;
    $e->writeString($this->text_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('text_payload', 'textPayload', $this->text_payload, true);
  }

  public function Copy(): ConformanceRequest_payload {
    return new ConformanceRequest_payload_text_payload($this->text_payload);
  }
}

class ConformanceRequest implements \Protobuf\Message {
  public \conformance\WireFormat_enum_t $requested_output_format;
  public string $message_type;
  public \conformance\TestCategory_enum_t $test_category;
  public ?\conformance\JspbEncodingConfig $jspb_encoding_options;
  public bool $print_unknown_fields;
  public ConformanceRequest_payload $payload;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'requested_output_format' => \conformance\WireFormat_enum_t,
    ?'message_type' => string,
    ?'test_category' => \conformance\TestCategory_enum_t,
    ?'jspb_encoding_options' => ?\conformance\JspbEncodingConfig,
    ?'print_unknown_fields' => bool,
    ?'payload' => ConformanceRequest_payload,
  ) $s = shape()) {
    $this->requested_output_format = $s['requested_output_format'] ?? \conformance\WireFormat::FromInt(0);
    $this->message_type = $s['message_type'] ?? '';
    $this->test_category = $s['test_category'] ?? \conformance\TestCategory::FromInt(0);
    $this->jspb_encoding_options = $s['jspb_encoding_options'] ?? null;
    $this->print_unknown_fields = $s['print_unknown_fields'] ?? false;
    $this->payload = $s['payload'] ?? new ConformanceRequest_payload_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "conformance.ConformanceRequest";
  }

  public static function ParseFrom(string $input): ?ConformanceRequest {
    $msg = new ConformanceRequest();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->payload = new ConformanceRequest_payload_protobuf_payload($d->readString());
          break;
        case 2:
          $this->payload = new ConformanceRequest_payload_json_payload($d->readString());
          break;
        case 3:
          $this->requested_output_format = \conformance\WireFormat::FromInt($d->readVarint());
          break;
        case 4:
          $this->message_type = $d->readString();
          break;
        case 5:
          $this->test_category = \conformance\TestCategory::FromInt($d->readVarint());
          break;
        case 6:
          if ($this->jspb_encoding_options is null) {
            $this->jspb_encoding_options = new \conformance\JspbEncodingConfig();
          }
          $this->jspb_encoding_options->MergeFrom($d->readDecoder());
          break;
        case 7:
          $this->payload = new ConformanceRequest_payload_jspb_payload($d->readString());
          break;
        case 8:
          $this->payload = new ConformanceRequest_payload_text_payload($d->readString());
          break;
        case 9:
          $this->print_unknown_fields = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->requested_output_format !== \conformance\WireFormat::FromInt(0)) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->requested_output_format);
    }
    if ($this->message_type !== '') {
      $e->writeTag(4, 2);
      $e->writeString($this->message_type);
    }
    if ($this->test_category !== \conformance\TestCategory::FromInt(0)) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->test_category);
    }
    $msg = $this->jspb_encoding_options;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    if ($this->print_unknown_fields !== false) {
      $e->writeTag(9, 0);
      $e->writeBool($this->print_unknown_fields);
    }
    $this->payload->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('requested_output_format', 'requestedOutputFormat', \conformance\WireFormat::ToStringDict(), $this->requested_output_format, false);
    $e->writeString('message_type', 'messageType', $this->message_type, false);
    $e->writeEnum('test_category', 'testCategory', \conformance\TestCategory::ToStringDict(), $this->test_category, false);
    $e->writeMessage('jspb_encoding_options', 'jspbEncodingOptions', $this->jspb_encoding_options, false);
    $e->writeBool('print_unknown_fields', 'printUnknownFields', $this->print_unknown_fields, false);
    $this->payload->WriteJsonTo($e);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'protobuf_payload': case 'protobufPayload':
          $this->payload = new ConformanceRequest_payload_protobuf_payload(\Protobuf\Internal\JsonDecoder::readBytes($v));
          break;
        case 'json_payload': case 'jsonPayload':
          $this->payload = new ConformanceRequest_payload_json_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'requested_output_format': case 'requestedOutputFormat':
          $this->requested_output_format = \conformance\WireFormat::FromMixed($v);
          break;
        case 'message_type': case 'messageType':
          $this->message_type = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'test_category': case 'testCategory':
          $this->test_category = \conformance\TestCategory::FromMixed($v);
          break;
        case 'jspb_encoding_options': case 'jspbEncodingOptions':
          if ($v is null) break;
          if ($this->jspb_encoding_options is null) {
            $this->jspb_encoding_options = new \conformance\JspbEncodingConfig();
          }
          $this->jspb_encoding_options->MergeJsonFrom($v);
          break;
        case 'jspb_payload': case 'jspbPayload':
          $this->payload = new ConformanceRequest_payload_jspb_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'text_payload': case 'textPayload':
          $this->payload = new ConformanceRequest_payload_text_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'print_unknown_fields': case 'printUnknownFields':
          $this->print_unknown_fields = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ConformanceRequest)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->requested_output_format = $o->requested_output_format;
    $this->message_type = $o->message_type;
    $this->test_category = $o->test_category;
    $tmp = $o->jspb_encoding_options;
    if ($tmp is nonnull) {
      $nv = new \conformance\JspbEncodingConfig();
      $nv->CopyFrom($tmp);
      $this->jspb_encoding_options = $nv;
    }
    $this->print_unknown_fields = $o->print_unknown_fields;
    $this->payload = $o->payload->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

enum ConformanceResponse_result_oneof_t: int {
  NOT_SET = 0;
  parse_error = 1;
  serialize_error = 6;
  timeout_error = 9;
  runtime_error = 2;
  protobuf_payload = 3;
  json_payload = 4;
  skipped = 5;
  jspb_payload = 7;
  text_payload = 8;
}

interface ConformanceResponse_result {
  public function WhichOneof(): ConformanceResponse_result_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): ConformanceResponse_result;
}

class ConformanceResponse_result_NOT_SET implements ConformanceResponse_result {
  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): ConformanceResponse_result { return $this; }
}

class ConformanceResponse_result_parse_error implements ConformanceResponse_result {
  public function __construct(public string $parse_error) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::parse_error;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(1, 2);;
    $e->writeString($this->parse_error);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('parse_error', 'parseError', $this->parse_error, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_result_parse_error($this->parse_error);
  }
}

class ConformanceResponse_result_serialize_error implements ConformanceResponse_result {
  public function __construct(public string $serialize_error) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::serialize_error;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(6, 2);;
    $e->writeString($this->serialize_error);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('serialize_error', 'serializeError', $this->serialize_error, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_result_serialize_error($this->serialize_error);
  }
}

class ConformanceResponse_result_timeout_error implements ConformanceResponse_result {
  public function __construct(public string $timeout_error) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::timeout_error;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(9, 2);;
    $e->writeString($this->timeout_error);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('timeout_error', 'timeoutError', $this->timeout_error, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_result_timeout_error($this->timeout_error);
  }
}

class ConformanceResponse_result_runtime_error implements ConformanceResponse_result {
  public function __construct(public string $runtime_error) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::runtime_error;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(2, 2);;
    $e->writeString($this->runtime_error);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('runtime_error', 'runtimeError', $this->runtime_error, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_result_runtime_error($this->runtime_error);
  }
}

class ConformanceResponse_result_protobuf_payload implements ConformanceResponse_result {
  public function __construct(public string $protobuf_payload) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::protobuf_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(3, 2);;
    $e->writeString($this->protobuf_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBytes('protobuf_payload', 'protobufPayload', $this->protobuf_payload, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_result_protobuf_payload($this->protobuf_payload);
  }
}

class ConformanceResponse_result_json_payload implements ConformanceResponse_result {
  public function __construct(public string $json_payload) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::json_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(4, 2);;
    $e->writeString($this->json_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('json_payload', 'jsonPayload', $this->json_payload, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_result_json_payload($this->json_payload);
  }
}

class ConformanceResponse_result_skipped implements ConformanceResponse_result {
  public function __construct(public string $skipped) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::skipped;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(5, 2);;
    $e->writeString($this->skipped);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('skipped', 'skipped', $this->skipped, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_result_skipped($this->skipped);
  }
}

class ConformanceResponse_result_jspb_payload implements ConformanceResponse_result {
  public function __construct(public string $jspb_payload) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::jspb_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(7, 2);;
    $e->writeString($this->jspb_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('jspb_payload', 'jspbPayload', $this->jspb_payload, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_result_jspb_payload($this->jspb_payload);
  }
}

class ConformanceResponse_result_text_payload implements ConformanceResponse_result {
  public function __construct(public string $text_payload) {}

  public function WhichOneof(): ConformanceResponse_result_oneof_t {
    return ConformanceResponse_result_oneof_t::text_payload;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(8, 2);;
    $e->writeString($this->text_payload);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('text_payload', 'textPayload', $this->text_payload, true);
  }

  public function Copy(): ConformanceResponse_result {
    return new ConformanceResponse_result_text_payload($this->text_payload);
  }
}

class ConformanceResponse implements \Protobuf\Message {
  public ConformanceResponse_result $result;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'result' => ConformanceResponse_result,
  ) $s = shape()) {
    $this->result = $s['result'] ?? new ConformanceResponse_result_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "conformance.ConformanceResponse";
  }

  public static function ParseFrom(string $input): ?ConformanceResponse {
    $msg = new ConformanceResponse();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->result = new ConformanceResponse_result_parse_error($d->readString());
          break;
        case 2:
          $this->result = new ConformanceResponse_result_runtime_error($d->readString());
          break;
        case 3:
          $this->result = new ConformanceResponse_result_protobuf_payload($d->readString());
          break;
        case 4:
          $this->result = new ConformanceResponse_result_json_payload($d->readString());
          break;
        case 5:
          $this->result = new ConformanceResponse_result_skipped($d->readString());
          break;
        case 6:
          $this->result = new ConformanceResponse_result_serialize_error($d->readString());
          break;
        case 7:
          $this->result = new ConformanceResponse_result_jspb_payload($d->readString());
          break;
        case 8:
          $this->result = new ConformanceResponse_result_text_payload($d->readString());
          break;
        case 9:
          $this->result = new ConformanceResponse_result_timeout_error($d->readString());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $this->result->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $this->result->WriteJsonTo($e);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'parse_error': case 'parseError':
          $this->result = new ConformanceResponse_result_parse_error(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'runtime_error': case 'runtimeError':
          $this->result = new ConformanceResponse_result_runtime_error(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'protobuf_payload': case 'protobufPayload':
          $this->result = new ConformanceResponse_result_protobuf_payload(\Protobuf\Internal\JsonDecoder::readBytes($v));
          break;
        case 'json_payload': case 'jsonPayload':
          $this->result = new ConformanceResponse_result_json_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'skipped':
          $this->result = new ConformanceResponse_result_skipped(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'serialize_error': case 'serializeError':
          $this->result = new ConformanceResponse_result_serialize_error(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'jspb_payload': case 'jspbPayload':
          $this->result = new ConformanceResponse_result_jspb_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'text_payload': case 'textPayload':
          $this->result = new ConformanceResponse_result_text_payload(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'timeout_error': case 'timeoutError':
          $this->result = new ConformanceResponse_result_timeout_error(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ConformanceResponse)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->result = $o->result->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class JspbEncodingConfig implements \Protobuf\Message {
  public bool $use_jspb_array_any_format;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'use_jspb_array_any_format' => bool,
  ) $s = shape()) {
    $this->use_jspb_array_any_format = $s['use_jspb_array_any_format'] ?? false;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "conformance.JspbEncodingConfig";
  }

  public static function ParseFrom(string $input): ?JspbEncodingConfig {
    $msg = new JspbEncodingConfig();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->use_jspb_array_any_format = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->use_jspb_array_any_format !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->use_jspb_array_any_format);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('use_jspb_array_any_format', 'useJspbArrayAnyFormat', $this->use_jspb_array_any_format, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'use_jspb_array_any_format': case 'useJspbArrayAnyFormat':
          $this->use_jspb_array_any_format = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is JspbEncodingConfig)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->use_jspb_array_any_format = $o->use_jspb_array_any_format;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_external_com_google_protobuf_conformance_conformance__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'external/com_google_protobuf/conformance/conformance.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 2664 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\xac\x94\xcd\x6e\xda\x40\x14\x85\x31\x10\x7e\x2e\x4e\x62\x4d\x12\xc5\xe9\x26\x84\xfe\x88\xa6\x12\xa9\xd2\x4d\xd5\x45\x25\x48\x21\x21\x55\x6d\x64\x8c\xd2\xae\x46\x6\x6\xe4\x4\x3c\xee\xcc\x58\xd\x7d\x89\xbe\x43\x5f\xb1\x52\xd7\x95\x67\x6c\x62\xd4\x2c\xba\xe8\xce\xf7\x9c\xef\xce\x1d\x7c\xf\x86\x77\xe4\x5e\x10\x16\x78\x8b\xb3\x9\x5d\xe2\x39\xa5\xf3\x5\xc1\x21\xa3\x82\x8e\xa3\xd9\xd9\x84\x6\x33\xca\x96\x5e\x30\x21\xd9\xe7\x96\x4\x50\x2d\x23\x35\x5e\x0\xf4\x3c\x7f\x11\x31\x32\x24\x2\x99\x50\x9e\xa9\xca\xd4\xea\x85\x66\xd5\x49\xcb\xc6\xef\x2\xa0\x8b\x87\x3e\x87\x7c\x8d\x8\x17\xe8\x15\x18\xe9\x54\x1c\x7a\xab\x5\xf5\xa6\xa6\x56\xd7\x9a\xfa\x55\xce\xd9\x4d\x9d\x81\x32\xd0\x53\xd0\x6f\x39\xd\xd6\x60\xbe\xae\x35\xab\x57\x39\xa7\x16\xab\x1b\x50\x38\x5e\x43\xe5\x7\x28\x1c\x67\x20\x41\xee\xc5\x1a\xaa\xa4\x50\xac\xa6\x90\xd\x87\x4c\x5d\x93\x4c\x31\x8d\x44\x18\x9\x2c\xef\x2f\xcc\x42\x5d\x6b\xee\x9c\x1f\xb6\xb2\x2f\xe7\xc6\x67\xa4\x27\x6d\xe7\x60\xdd\x67\xcb\x36\x25\xa3\x13\xd0\x97\x84\x73\x6f\x4e\xb0\x58\x85\xc4\x2c\xc6\x53\x9d\x5a\xa2\xb9\xab\x90\xa0\xf7\xb0\x2d\x8\x17\x78\xe2\x9\x32\xa7\x6c\x65\x6e\xc9\x49\x47\x1b\x93\x5c\xc2\xc5\x45\x2\x38\xba\xc8\x54\x68\x8\x7\xf2\xd7\x93\x60\x42\xa7\x7e\x30\xc7\x34\x14\x3e\xd\xb8\x59\xaa\x6b\xcd\xda\xf9\xf1\xc6\x39\xd7\x3c\x1c\x77\x13\x30\xde\x8d\x3f\x77\xf6\x6e\x33\x9a\xad\x7a\xd1\x6b\xd8\xf\x99\x1f\x8\x1c\x5\x77\x1\xfd\x16\xe0\x99\x4f\x16\x53\x6e\x56\xeb\x5a\xb3\xe2\x20\xe9\x8d\x94\xd5\x93\x4e\xa7\xa\xe5\xe4\xd5\x36\x7e\xe5\x61\x6f\x63\xf1\x3c\xa4\x1\x27\xe8\x4\x6a\xa1\xc7\x38\xc1\x84\x31\xca\xe4\xd2\xe3\xd\x80\x14\xbb\xb1\x86\x5e\xc2\x2e\x27\xcc\xf7\x16\xfe\xf7\x14\x2b\x25\xd8\xce\xda\x50\xe8\x73\xd8\x16\xfe\x92\xd0\x48\x24\x60\x35\x1\xf5\x44\x5e\x63\x2c\xa\x62\x29\xc1\xd2\x8\xe9\x89\xac\xb0\xc7\x52\x59\xf8\xd7\x54\x16\x1f\x4b\xe5\x13\x28\xf3\x3b\x3f\xc\xc9\x54\x6e\x34\xf6\x53\xe1\xff\x25\xb6\x53\x81\x12\x23\x3c\x5a\x88\x86\x5\xe8\xef\xed\xa2\xb7\x70\x14\x71\x82\xe5\x34\x8f\x31\x6f\x85\xbd\x60\x95\x66\x5a\x93\xdb\x3c\x88\x38\x89\x3b\xdb\xb1\xdd\xe\x56\x2a\xba\xa7\x3\x80\x87\x7c\xa3\x5d\xa8\x8d\xac\xe1\xa0\x7b\xd1\xef\xf5\xbb\x1f\x8c\x1c\xd2\xa1\x32\x70\x6c\xd7\xee\x8c\x7a\x86\x86\x2a\x50\xbc\x1e\xda\x96\x91\x57\x4f\x83\x8e\x51\x88\x5b\xdc\xee\x67\x17\xf7\x6c\xe7\x53\xdb\x35\x8a\xa7\x3f\x34\xd0\xb3\x41\x46\xfb\x60\x64\xe\xc5\x6e\x77\xe8\x1a\xb9\xb8\xaf\xd3\xb7\xda\xce\x17\x25\x68\x68\x1b\xaa\xf1\xe1\xaa\xcc\xa3\x67\x50\x97\x65\xff\xd2\xb2\x9d\x2e\x1e\x59\x1f\x2d\xfb\xc6\xc2\x83\xb6\x33\xec\x5b\x97\x8a\x2a\xa8\xa6\x41\x47\x95\xc5\x78\x54\xe6\x32\x4a\xdd\xea\x9c\xc1\xf1\x84\x2e\x5b\xea\x63\xd8\x4a\xd7\x9c\xfd\xc7\xfc\xcc\xd7\x32\x51\x1e\x97\x24\xf3\xe6\x4f\x0\x0\x0\xff\xff\xf7\x6\xa7\x2f");
  }
}
