<?hh // strict
namespace protobuf_test_messages\proto3;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/test_messages_proto3.proto

newtype ForeignEnum_enum_t as int = int;
abstract class ForeignEnum {
  const ForeignEnum_enum_t FOREIGN_FOO = 0;
  const ForeignEnum_enum_t FOREIGN_BAR = 1;
  const ForeignEnum_enum_t FOREIGN_BAZ = 2;
  private static dict<int, string> $itos = dict[
    0 => 'FOREIGN_FOO',
    1 => 'FOREIGN_BAR',
    2 => 'FOREIGN_BAZ',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FOREIGN_FOO' => 0,
    'FOREIGN_BAR' => 1,
    'FOREIGN_BAZ' => 2,
  ];
  public static function FromMixed(mixed $m): ForeignEnum_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): ForeignEnum_enum_t {
    return $i;
  }
}

newtype TestAllTypesProto3_NestedEnum_enum_t as int = int;
abstract class TestAllTypesProto3_NestedEnum {
  const TestAllTypesProto3_NestedEnum_enum_t FOO = 0;
  const TestAllTypesProto3_NestedEnum_enum_t BAR = 1;
  const TestAllTypesProto3_NestedEnum_enum_t BAZ = 2;
  const TestAllTypesProto3_NestedEnum_enum_t NEG = -1;
  private static dict<int, string> $itos = dict[
    0 => 'FOO',
    1 => 'BAR',
    2 => 'BAZ',
    -1 => 'NEG',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FOO' => 0,
    'BAR' => 1,
    'BAZ' => 2,
    'NEG' => -1,
  ];
  public static function FromMixed(mixed $m): TestAllTypesProto3_NestedEnum_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): TestAllTypesProto3_NestedEnum_enum_t {
    return $i;
  }
}

newtype TestAllTypesProto3_AliasedEnum_enum_t as int = int;
abstract class TestAllTypesProto3_AliasedEnum {
  const TestAllTypesProto3_AliasedEnum_enum_t ALIAS_FOO = 0;
  const TestAllTypesProto3_AliasedEnum_enum_t ALIAS_BAR = 1;
  const TestAllTypesProto3_AliasedEnum_enum_t ALIAS_BAZ = 2;
  const TestAllTypesProto3_AliasedEnum_enum_t QUX = 2;
  const TestAllTypesProto3_AliasedEnum_enum_t qux = 2;
  const TestAllTypesProto3_AliasedEnum_enum_t bAz = 2;
  private static dict<int, string> $itos = dict[
    0 => 'ALIAS_FOO',
    1 => 'ALIAS_BAR',
    2 => 'ALIAS_BAZ',
    2 => 'QUX',
    2 => 'qux',
    2 => 'bAz',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'ALIAS_FOO' => 0,
    'ALIAS_BAR' => 1,
    'ALIAS_BAZ' => 2,
    'QUX' => 2,
    'qux' => 2,
    'bAz' => 2,
  ];
  public static function FromMixed(mixed $m): TestAllTypesProto3_AliasedEnum_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): TestAllTypesProto3_AliasedEnum_enum_t {
    return $i;
  }
}

enum TestAllTypesProto3_oneof_field_oneof_t: int {
  NOT_SET = 0;
  oneof_uint32 = 111;
  oneof_nested_message = 112;
  oneof_string = 113;
  oneof_bytes = 114;
  oneof_bool = 115;
  oneof_uint64 = 116;
  oneof_float = 117;
  oneof_double = 118;
  oneof_enum = 119;
  oneof_null_value = 120;
}

interface TestAllTypesProto3_oneof_field {
  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): TestAllTypesProto3_oneof_field;
}

class TestAllTypesProto3_oneof_field_NOT_SET implements TestAllTypesProto3_oneof_field {
  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): TestAllTypesProto3_oneof_field { return $this; }
}

class TestAllTypesProto3_oneof_field_oneof_uint32 implements TestAllTypesProto3_oneof_field {
  public function __construct(public int $oneof_uint32) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_uint32;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(111, 0);;
    $e->writeVarint($this->oneof_uint32);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('oneof_uint32', 'oneofUint32', $this->oneof_uint32, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_field_oneof_uint32($this->oneof_uint32);
  }
}

class TestAllTypesProto3_oneof_field_oneof_nested_message implements TestAllTypesProto3_oneof_field {
  public function __construct(public \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage $oneof_nested_message) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_nested_message;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->oneof_nested_message->WriteTo($nested);
    $e->writeEncoder($nested, 112);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('oneof_nested_message', 'oneofNestedMessage', $this->oneof_nested_message, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
    $nv->CopyFrom($this->oneof_nested_message);
    return new TestAllTypesProto3_oneof_field_oneof_nested_message($nv);
  }
}

class TestAllTypesProto3_oneof_field_oneof_string implements TestAllTypesProto3_oneof_field {
  public function __construct(public string $oneof_string) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_string;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(113, 2);;
    $e->writeString($this->oneof_string);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('oneof_string', 'oneofString', $this->oneof_string, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_field_oneof_string($this->oneof_string);
  }
}

class TestAllTypesProto3_oneof_field_oneof_bytes implements TestAllTypesProto3_oneof_field {
  public function __construct(public string $oneof_bytes) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_bytes;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(114, 2);;
    $e->writeString($this->oneof_bytes);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBytes('oneof_bytes', 'oneofBytes', $this->oneof_bytes, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_field_oneof_bytes($this->oneof_bytes);
  }
}

class TestAllTypesProto3_oneof_field_oneof_bool implements TestAllTypesProto3_oneof_field {
  public function __construct(public bool $oneof_bool) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_bool;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(115, 0);;
    $e->writeBool($this->oneof_bool);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('oneof_bool', 'oneofBool', $this->oneof_bool, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_field_oneof_bool($this->oneof_bool);
  }
}

class TestAllTypesProto3_oneof_field_oneof_uint64 implements TestAllTypesProto3_oneof_field {
  public function __construct(public int $oneof_uint64) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_uint64;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(116, 0);;
    $e->writeVarint($this->oneof_uint64);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('oneof_uint64', 'oneofUint64', $this->oneof_uint64, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_field_oneof_uint64($this->oneof_uint64);
  }
}

class TestAllTypesProto3_oneof_field_oneof_float implements TestAllTypesProto3_oneof_field {
  public function __construct(public float $oneof_float) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_float;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(117, 5);;
    $e->writeFloat($this->oneof_float);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeFloat('oneof_float', 'oneofFloat', $this->oneof_float, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_field_oneof_float($this->oneof_float);
  }
}

class TestAllTypesProto3_oneof_field_oneof_double implements TestAllTypesProto3_oneof_field {
  public function __construct(public float $oneof_double) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_double;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(118, 1);;
    $e->writeDouble($this->oneof_double);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeFloat('oneof_double', 'oneofDouble', $this->oneof_double, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_field_oneof_double($this->oneof_double);
  }
}

class TestAllTypesProto3_oneof_field_oneof_enum implements TestAllTypesProto3_oneof_field {
  public function __construct(public \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t $oneof_enum) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_enum;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(119, 0);;
    $e->writeVarint($this->oneof_enum);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('oneof_enum', 'oneofEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->oneof_enum, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_field_oneof_enum($this->oneof_enum);
  }
}

class TestAllTypesProto3_oneof_field_oneof_null_value implements TestAllTypesProto3_oneof_field {
  public function __construct(public \google\protobuf\NullValue_enum_t $oneof_null_value) {}

  public function WhichOneof(): TestAllTypesProto3_oneof_field_oneof_t {
    return TestAllTypesProto3_oneof_field_oneof_t::oneof_null_value;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(120, 0);;
    $e->writeVarint($this->oneof_null_value);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('oneof_null_value', 'oneofNullValue', \google\protobuf\NullValue::ToStringDict(), $this->oneof_null_value, true);
  }

  public function Copy(): TestAllTypesProto3_oneof_field {
    return new TestAllTypesProto3_oneof_field_oneof_null_value($this->oneof_null_value);
  }
}

class TestAllTypesProto3_NestedMessage implements \Protobuf\Message {
  public int $a;
  public ?\protobuf_test_messages\proto3\TestAllTypesProto3 $corecursive;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'a' => int,
    ?'corecursive' => ?\protobuf_test_messages\proto3\TestAllTypesProto3,
  ) $s = shape()) {
    $this->a = $s['a'] ?? 0;
    $this->corecursive = $s['corecursive'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.NestedMessage";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_NestedMessage {
    $msg = new TestAllTypesProto3_NestedMessage();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->a = $d->readVarint32Signed();
          break;
        case 2:
          if ($this->corecursive == null) $this->corecursive = new \protobuf_test_messages\proto3\TestAllTypesProto3();
          $this->corecursive->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->a !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->a);
    }
    $msg = $this->corecursive;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('a', 'a', $this->a, false);
    $e->writeMessage('corecursive', 'corecursive', $this->corecursive, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'a':
          $this->a = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'corecursive':
          if ($v === null) break;
          if ($this->corecursive == null) $this->corecursive = new \protobuf_test_messages\proto3\TestAllTypesProto3();
          $this->corecursive->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_NestedMessage)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->a = $o->a;
    $tmp = $o->corecursive;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3();
      $nv->CopyFrom($tmp);
      $this->corecursive = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapInt32Int32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapInt32Int32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapInt32Int32Entry {
    $msg = new TestAllTypesProto3_MapInt32Int32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapInt32Int32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapInt64Int64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapInt64Int64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapInt64Int64Entry {
    $msg = new TestAllTypesProto3_MapInt64Int64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint();
          break;
        case 2:
          $this->value = $d->readVarint();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapInt64Int64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapUint32Uint32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapUint32Uint32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapUint32Uint32Entry {
    $msg = new TestAllTypesProto3_MapUint32Uint32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32();
          break;
        case 2:
          $this->value = $d->readVarint32();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapUint32Uint32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapUint64Uint64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapUint64Uint64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapUint64Uint64Entry {
    $msg = new TestAllTypesProto3_MapUint64Uint64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint();
          break;
        case 2:
          $this->value = $d->readVarint();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('key', 'key', $this->key, false);
    $e->writeInt64Unsigned('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapUint64Uint64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapSint32Sint32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapSint32Sint32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapSint32Sint32Entry {
    $msg = new TestAllTypesProto3_MapSint32Sint32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarintZigZag32();
          break;
        case 2:
          $this->value = $d->readVarintZigZag32();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarintZigZag32($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarintZigZag32($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapSint32Sint32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapSint64Sint64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapSint64Sint64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapSint64Sint64Entry {
    $msg = new TestAllTypesProto3_MapSint64Sint64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarintZigZag64();
          break;
        case 2:
          $this->value = $d->readVarintZigZag64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarintZigZag64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarintZigZag64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapSint64Sint64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapFixed32Fixed32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapFixed32Fixed32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapFixed32Fixed32Entry {
    $msg = new TestAllTypesProto3_MapFixed32Fixed32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt32Unsigned();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt32Unsigned();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 5);
      $e->writeLittleEndianInt32Unsigned($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 5);
      $e->writeLittleEndianInt32Unsigned($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapFixed32Fixed32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapFixed64Fixed64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapFixed64Fixed64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapFixed64Fixed64Entry {
    $msg = new TestAllTypesProto3_MapFixed64Fixed64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt64();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 1);
      $e->writeLittleEndianInt64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 1);
      $e->writeLittleEndianInt64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('key', 'key', $this->key, false);
    $e->writeInt64Unsigned('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapFixed64Fixed64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapSfixed32Sfixed32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapSfixed32Sfixed32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapSfixed32Sfixed32Entry {
    $msg = new TestAllTypesProto3_MapSfixed32Sfixed32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt32Signed();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 5);
      $e->writeLittleEndianInt32Signed($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 5);
      $e->writeLittleEndianInt32Signed($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapSfixed32Sfixed32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapSfixed64Sfixed64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapSfixed64Sfixed64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapSfixed64Sfixed64Entry {
    $msg = new TestAllTypesProto3_MapSfixed64Sfixed64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt64();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 1);
      $e->writeLittleEndianInt64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 1);
      $e->writeLittleEndianInt64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapSfixed64Sfixed64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapInt32FloatEntry implements \Protobuf\Message {
  public int $key;
  public float $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => float,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0.0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapInt32FloatEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapInt32FloatEntry {
    $msg = new TestAllTypesProto3_MapInt32FloatEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readFloat();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0.0) {
      $e->writeTag(2, 5);
      $e->writeFloat($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeFloat('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapInt32FloatEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapInt32DoubleEntry implements \Protobuf\Message {
  public int $key;
  public float $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => float,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0.0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapInt32DoubleEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapInt32DoubleEntry {
    $msg = new TestAllTypesProto3_MapInt32DoubleEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readDouble();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0.0) {
      $e->writeTag(2, 1);
      $e->writeDouble($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeFloat('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapInt32DoubleEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapBoolBoolEntry implements \Protobuf\Message {
  public bool $key;
  public bool $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => bool,
    ?'value' => bool,
  ) $s = shape()) {
    $this->key = $s['key'] ?? false;
    $this->value = $s['value'] ?? false;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapBoolBoolEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapBoolBoolEntry {
    $msg = new TestAllTypesProto3_MapBoolBoolEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readBool();
          break;
        case 2:
          $this->value = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->key);
    }
    if ($this->value !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('key', 'key', $this->key, false);
    $e->writeBool('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapBoolBoolEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringStringEntry implements \Protobuf\Message {
  public string $key;
  public string $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => string,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringStringEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapStringStringEntry {
    $msg = new TestAllTypesProto3_MapStringStringEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeString('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringStringEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringBytesEntry implements \Protobuf\Message {
  public string $key;
  public string $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => string,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringBytesEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapStringBytesEntry {
    $msg = new TestAllTypesProto3_MapStringBytesEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeBytes('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringBytesEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringNestedMessageEntry implements \Protobuf\Message {
  public string $key;
  public ?\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => ?\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringNestedMessageEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapStringNestedMessageEntry {
    $msg = new TestAllTypesProto3_MapStringNestedMessageEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeMessage('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          if ($v === null) break;
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringNestedMessageEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $tmp = $o->value;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->value = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringForeignMessageEntry implements \Protobuf\Message {
  public string $key;
  public ?\protobuf_test_messages\proto3\ForeignMessage $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => ?\protobuf_test_messages\proto3\ForeignMessage,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringForeignMessageEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapStringForeignMessageEntry {
    $msg = new TestAllTypesProto3_MapStringForeignMessageEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto3\ForeignMessage();
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeMessage('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          if ($v === null) break;
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto3\ForeignMessage();
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringForeignMessageEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $tmp = $o->value;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\ForeignMessage();
      $nv->CopyFrom($tmp);
      $this->value = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringNestedEnumEntry implements \Protobuf\Message {
  public string $key;
  public \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt(0);
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringNestedEnumEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapStringNestedEnumEntry {
    $msg = new TestAllTypesProto3_MapStringNestedEnumEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt(0)) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeEnum('value', 'value', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringNestedEnumEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3_MapStringForeignEnumEntry implements \Protobuf\Message {
  public string $key;
  public \protobuf_test_messages\proto3\ForeignEnum_enum_t $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => \protobuf_test_messages\proto3\ForeignEnum_enum_t,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? \protobuf_test_messages\proto3\ForeignEnum::FromInt(0);
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3.MapStringForeignEnumEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3_MapStringForeignEnumEntry {
    $msg = new TestAllTypesProto3_MapStringForeignEnumEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = \protobuf_test_messages\proto3\ForeignEnum::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== \protobuf_test_messages\proto3\ForeignEnum::FromInt(0)) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeEnum('value', 'value', \protobuf_test_messages\proto3\ForeignEnum::ToStringDict(), $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \protobuf_test_messages\proto3\ForeignEnum::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3_MapStringForeignEnumEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto3 implements \Protobuf\Message {
  public int $optional_int32;
  public int $optional_int64;
  public int $optional_uint32;
  public int $optional_uint64;
  public int $optional_sint32;
  public int $optional_sint64;
  public int $optional_fixed32;
  public int $optional_fixed64;
  public int $optional_sfixed32;
  public int $optional_sfixed64;
  public float $optional_float;
  public float $optional_double;
  public bool $optional_bool;
  public string $optional_string;
  public string $optional_bytes;
  public ?\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage $optional_nested_message;
  public ?\protobuf_test_messages\proto3\ForeignMessage $optional_foreign_message;
  public \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t $optional_nested_enum;
  public \protobuf_test_messages\proto3\ForeignEnum_enum_t $optional_foreign_enum;
  public \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum_enum_t $optional_aliased_enum;
  public string $optional_string_piece;
  public string $optional_cord;
  public ?\protobuf_test_messages\proto3\TestAllTypesProto3 $recursive_message;
  public vec<int> $repeated_int32;
  public vec<int> $repeated_int64;
  public vec<int> $repeated_uint32;
  public vec<int> $repeated_uint64;
  public vec<int> $repeated_sint32;
  public vec<int> $repeated_sint64;
  public vec<int> $repeated_fixed32;
  public vec<int> $repeated_fixed64;
  public vec<int> $repeated_sfixed32;
  public vec<int> $repeated_sfixed64;
  public vec<float> $repeated_float;
  public vec<float> $repeated_double;
  public vec<bool> $repeated_bool;
  public vec<string> $repeated_string;
  public vec<string> $repeated_bytes;
  public vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage> $repeated_nested_message;
  public vec<\protobuf_test_messages\proto3\ForeignMessage> $repeated_foreign_message;
  public vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t> $repeated_nested_enum;
  public vec<\protobuf_test_messages\proto3\ForeignEnum_enum_t> $repeated_foreign_enum;
  public vec<string> $repeated_string_piece;
  public vec<string> $repeated_cord;
  public vec<int> $packed_int32;
  public vec<int> $packed_int64;
  public vec<int> $packed_uint32;
  public vec<int> $packed_uint64;
  public vec<int> $packed_sint32;
  public vec<int> $packed_sint64;
  public vec<int> $packed_fixed32;
  public vec<int> $packed_fixed64;
  public vec<int> $packed_sfixed32;
  public vec<int> $packed_sfixed64;
  public vec<float> $packed_float;
  public vec<float> $packed_double;
  public vec<bool> $packed_bool;
  public vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t> $packed_nested_enum;
  public vec<int> $unpacked_int32;
  public vec<int> $unpacked_int64;
  public vec<int> $unpacked_uint32;
  public vec<int> $unpacked_uint64;
  public vec<int> $unpacked_sint32;
  public vec<int> $unpacked_sint64;
  public vec<int> $unpacked_fixed32;
  public vec<int> $unpacked_fixed64;
  public vec<int> $unpacked_sfixed32;
  public vec<int> $unpacked_sfixed64;
  public vec<float> $unpacked_float;
  public vec<float> $unpacked_double;
  public vec<bool> $unpacked_bool;
  public vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t> $unpacked_nested_enum;
  public dict<int, int> $map_int32_int32;
  public dict<int, int> $map_int64_int64;
  public dict<int, int> $map_uint32_uint32;
  public dict<int, int> $map_uint64_uint64;
  public dict<int, int> $map_sint32_sint32;
  public dict<int, int> $map_sint64_sint64;
  public dict<int, int> $map_fixed32_fixed32;
  public dict<int, int> $map_fixed64_fixed64;
  public dict<int, int> $map_sfixed32_sfixed32;
  public dict<int, int> $map_sfixed64_sfixed64;
  public dict<int, float> $map_int32_float;
  public dict<int, float> $map_int32_double;
  public dict<\Protobuf\Internal\bool_map_key_t, bool> $map_bool_bool;
  public dict<string, string> $map_string_string;
  public dict<string, string> $map_string_bytes;
  public dict<string, \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage> $map_string_nested_message;
  public dict<string, \protobuf_test_messages\proto3\ForeignMessage> $map_string_foreign_message;
  public dict<string, \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t> $map_string_nested_enum;
  public dict<string, \protobuf_test_messages\proto3\ForeignEnum_enum_t> $map_string_foreign_enum;
  public ?\google\protobuf\BoolValue $optional_bool_wrapper;
  public ?\google\protobuf\Int32Value $optional_int32_wrapper;
  public ?\google\protobuf\Int64Value $optional_int64_wrapper;
  public ?\google\protobuf\UInt32Value $optional_uint32_wrapper;
  public ?\google\protobuf\UInt64Value $optional_uint64_wrapper;
  public ?\google\protobuf\FloatValue $optional_float_wrapper;
  public ?\google\protobuf\DoubleValue $optional_double_wrapper;
  public ?\google\protobuf\StringValue $optional_string_wrapper;
  public ?\google\protobuf\BytesValue $optional_bytes_wrapper;
  public vec<\google\protobuf\BoolValue> $repeated_bool_wrapper;
  public vec<\google\protobuf\Int32Value> $repeated_int32_wrapper;
  public vec<\google\protobuf\Int64Value> $repeated_int64_wrapper;
  public vec<\google\protobuf\UInt32Value> $repeated_uint32_wrapper;
  public vec<\google\protobuf\UInt64Value> $repeated_uint64_wrapper;
  public vec<\google\protobuf\FloatValue> $repeated_float_wrapper;
  public vec<\google\protobuf\DoubleValue> $repeated_double_wrapper;
  public vec<\google\protobuf\StringValue> $repeated_string_wrapper;
  public vec<\google\protobuf\BytesValue> $repeated_bytes_wrapper;
  public ?\google\protobuf\Duration $optional_duration;
  public ?\google\protobuf\Timestamp $optional_timestamp;
  public ?\google\protobuf\FieldMask $optional_field_mask;
  public ?\google\protobuf\Struct $optional_struct;
  public ?\google\protobuf\Any $optional_any;
  public ?\google\protobuf\Value $optional_value;
  public \google\protobuf\NullValue_enum_t $optional_null_value;
  public vec<\google\protobuf\Duration> $repeated_duration;
  public vec<\google\protobuf\Timestamp> $repeated_timestamp;
  public vec<\google\protobuf\FieldMask> $repeated_fieldmask;
  public vec<\google\protobuf\Struct> $repeated_struct;
  public vec<\google\protobuf\Any> $repeated_any;
  public vec<\google\protobuf\Value> $repeated_value;
  public vec<\google\protobuf\ListValue> $repeated_list_value;
  public int $fieldname1;
  public int $field_name2;
  public int $_field_name3;
  public int $field__name4_;
  public int $field0name5;
  public int $field_0_name6;
  public int $fieldName7;
  public int $FieldName8;
  public int $field_Name9;
  public int $Field_Name10;
  public int $FIELD_NAME11;
  public int $FIELD_name12;
  public int $__field_name13;
  public int $__Field_name14;
  public int $field__name15;
  public int $field__Name16;
  public int $field_name17__;
  public int $Field_name18__;
  public TestAllTypesProto3_oneof_field $oneof_field;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'optional_int32' => int,
    ?'optional_int64' => int,
    ?'optional_uint32' => int,
    ?'optional_uint64' => int,
    ?'optional_sint32' => int,
    ?'optional_sint64' => int,
    ?'optional_fixed32' => int,
    ?'optional_fixed64' => int,
    ?'optional_sfixed32' => int,
    ?'optional_sfixed64' => int,
    ?'optional_float' => float,
    ?'optional_double' => float,
    ?'optional_bool' => bool,
    ?'optional_string' => string,
    ?'optional_bytes' => string,
    ?'optional_nested_message' => ?\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage,
    ?'optional_foreign_message' => ?\protobuf_test_messages\proto3\ForeignMessage,
    ?'optional_nested_enum' => \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t,
    ?'optional_foreign_enum' => \protobuf_test_messages\proto3\ForeignEnum_enum_t,
    ?'optional_aliased_enum' => \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum_enum_t,
    ?'optional_string_piece' => string,
    ?'optional_cord' => string,
    ?'recursive_message' => ?\protobuf_test_messages\proto3\TestAllTypesProto3,
    ?'repeated_int32' => vec<int>,
    ?'repeated_int64' => vec<int>,
    ?'repeated_uint32' => vec<int>,
    ?'repeated_uint64' => vec<int>,
    ?'repeated_sint32' => vec<int>,
    ?'repeated_sint64' => vec<int>,
    ?'repeated_fixed32' => vec<int>,
    ?'repeated_fixed64' => vec<int>,
    ?'repeated_sfixed32' => vec<int>,
    ?'repeated_sfixed64' => vec<int>,
    ?'repeated_float' => vec<float>,
    ?'repeated_double' => vec<float>,
    ?'repeated_bool' => vec<bool>,
    ?'repeated_string' => vec<string>,
    ?'repeated_bytes' => vec<string>,
    ?'repeated_nested_message' => vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage>,
    ?'repeated_foreign_message' => vec<\protobuf_test_messages\proto3\ForeignMessage>,
    ?'repeated_nested_enum' => vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t>,
    ?'repeated_foreign_enum' => vec<\protobuf_test_messages\proto3\ForeignEnum_enum_t>,
    ?'repeated_string_piece' => vec<string>,
    ?'repeated_cord' => vec<string>,
    ?'packed_int32' => vec<int>,
    ?'packed_int64' => vec<int>,
    ?'packed_uint32' => vec<int>,
    ?'packed_uint64' => vec<int>,
    ?'packed_sint32' => vec<int>,
    ?'packed_sint64' => vec<int>,
    ?'packed_fixed32' => vec<int>,
    ?'packed_fixed64' => vec<int>,
    ?'packed_sfixed32' => vec<int>,
    ?'packed_sfixed64' => vec<int>,
    ?'packed_float' => vec<float>,
    ?'packed_double' => vec<float>,
    ?'packed_bool' => vec<bool>,
    ?'packed_nested_enum' => vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t>,
    ?'unpacked_int32' => vec<int>,
    ?'unpacked_int64' => vec<int>,
    ?'unpacked_uint32' => vec<int>,
    ?'unpacked_uint64' => vec<int>,
    ?'unpacked_sint32' => vec<int>,
    ?'unpacked_sint64' => vec<int>,
    ?'unpacked_fixed32' => vec<int>,
    ?'unpacked_fixed64' => vec<int>,
    ?'unpacked_sfixed32' => vec<int>,
    ?'unpacked_sfixed64' => vec<int>,
    ?'unpacked_float' => vec<float>,
    ?'unpacked_double' => vec<float>,
    ?'unpacked_bool' => vec<bool>,
    ?'unpacked_nested_enum' => vec<\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t>,
    ?'map_int32_int32' => dict<int, int>,
    ?'map_int64_int64' => dict<int, int>,
    ?'map_uint32_uint32' => dict<int, int>,
    ?'map_uint64_uint64' => dict<int, int>,
    ?'map_sint32_sint32' => dict<int, int>,
    ?'map_sint64_sint64' => dict<int, int>,
    ?'map_fixed32_fixed32' => dict<int, int>,
    ?'map_fixed64_fixed64' => dict<int, int>,
    ?'map_sfixed32_sfixed32' => dict<int, int>,
    ?'map_sfixed64_sfixed64' => dict<int, int>,
    ?'map_int32_float' => dict<int, float>,
    ?'map_int32_double' => dict<int, float>,
    ?'map_bool_bool' => dict<\Protobuf\Internal\bool_map_key_t, bool>,
    ?'map_string_string' => dict<string, string>,
    ?'map_string_bytes' => dict<string, string>,
    ?'map_string_nested_message' => dict<string, \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage>,
    ?'map_string_foreign_message' => dict<string, \protobuf_test_messages\proto3\ForeignMessage>,
    ?'map_string_nested_enum' => dict<string, \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum_enum_t>,
    ?'map_string_foreign_enum' => dict<string, \protobuf_test_messages\proto3\ForeignEnum_enum_t>,
    ?'optional_bool_wrapper' => ?\google\protobuf\BoolValue,
    ?'optional_int32_wrapper' => ?\google\protobuf\Int32Value,
    ?'optional_int64_wrapper' => ?\google\protobuf\Int64Value,
    ?'optional_uint32_wrapper' => ?\google\protobuf\UInt32Value,
    ?'optional_uint64_wrapper' => ?\google\protobuf\UInt64Value,
    ?'optional_float_wrapper' => ?\google\protobuf\FloatValue,
    ?'optional_double_wrapper' => ?\google\protobuf\DoubleValue,
    ?'optional_string_wrapper' => ?\google\protobuf\StringValue,
    ?'optional_bytes_wrapper' => ?\google\protobuf\BytesValue,
    ?'repeated_bool_wrapper' => vec<\google\protobuf\BoolValue>,
    ?'repeated_int32_wrapper' => vec<\google\protobuf\Int32Value>,
    ?'repeated_int64_wrapper' => vec<\google\protobuf\Int64Value>,
    ?'repeated_uint32_wrapper' => vec<\google\protobuf\UInt32Value>,
    ?'repeated_uint64_wrapper' => vec<\google\protobuf\UInt64Value>,
    ?'repeated_float_wrapper' => vec<\google\protobuf\FloatValue>,
    ?'repeated_double_wrapper' => vec<\google\protobuf\DoubleValue>,
    ?'repeated_string_wrapper' => vec<\google\protobuf\StringValue>,
    ?'repeated_bytes_wrapper' => vec<\google\protobuf\BytesValue>,
    ?'optional_duration' => ?\google\protobuf\Duration,
    ?'optional_timestamp' => ?\google\protobuf\Timestamp,
    ?'optional_field_mask' => ?\google\protobuf\FieldMask,
    ?'optional_struct' => ?\google\protobuf\Struct,
    ?'optional_any' => ?\google\protobuf\Any,
    ?'optional_value' => ?\google\protobuf\Value,
    ?'optional_null_value' => \google\protobuf\NullValue_enum_t,
    ?'repeated_duration' => vec<\google\protobuf\Duration>,
    ?'repeated_timestamp' => vec<\google\protobuf\Timestamp>,
    ?'repeated_fieldmask' => vec<\google\protobuf\FieldMask>,
    ?'repeated_struct' => vec<\google\protobuf\Struct>,
    ?'repeated_any' => vec<\google\protobuf\Any>,
    ?'repeated_value' => vec<\google\protobuf\Value>,
    ?'repeated_list_value' => vec<\google\protobuf\ListValue>,
    ?'fieldname1' => int,
    ?'field_name2' => int,
    ?'_field_name3' => int,
    ?'field__name4_' => int,
    ?'field0name5' => int,
    ?'field_0_name6' => int,
    ?'fieldName7' => int,
    ?'FieldName8' => int,
    ?'field_Name9' => int,
    ?'Field_Name10' => int,
    ?'FIELD_NAME11' => int,
    ?'FIELD_name12' => int,
    ?'__field_name13' => int,
    ?'__Field_name14' => int,
    ?'field__name15' => int,
    ?'field__Name16' => int,
    ?'field_name17__' => int,
    ?'Field_name18__' => int,
    ?'oneof_field' => TestAllTypesProto3_oneof_field,
  ) $s = shape()) {
    $this->optional_int32 = $s['optional_int32'] ?? 0;
    $this->optional_int64 = $s['optional_int64'] ?? 0;
    $this->optional_uint32 = $s['optional_uint32'] ?? 0;
    $this->optional_uint64 = $s['optional_uint64'] ?? 0;
    $this->optional_sint32 = $s['optional_sint32'] ?? 0;
    $this->optional_sint64 = $s['optional_sint64'] ?? 0;
    $this->optional_fixed32 = $s['optional_fixed32'] ?? 0;
    $this->optional_fixed64 = $s['optional_fixed64'] ?? 0;
    $this->optional_sfixed32 = $s['optional_sfixed32'] ?? 0;
    $this->optional_sfixed64 = $s['optional_sfixed64'] ?? 0;
    $this->optional_float = $s['optional_float'] ?? 0.0;
    $this->optional_double = $s['optional_double'] ?? 0.0;
    $this->optional_bool = $s['optional_bool'] ?? false;
    $this->optional_string = $s['optional_string'] ?? '';
    $this->optional_bytes = $s['optional_bytes'] ?? '';
    $this->optional_nested_message = $s['optional_nested_message'] ?? null;
    $this->optional_foreign_message = $s['optional_foreign_message'] ?? null;
    $this->optional_nested_enum = $s['optional_nested_enum'] ?? \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt(0);
    $this->optional_foreign_enum = $s['optional_foreign_enum'] ?? \protobuf_test_messages\proto3\ForeignEnum::FromInt(0);
    $this->optional_aliased_enum = $s['optional_aliased_enum'] ?? \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum::FromInt(0);
    $this->optional_string_piece = $s['optional_string_piece'] ?? '';
    $this->optional_cord = $s['optional_cord'] ?? '';
    $this->recursive_message = $s['recursive_message'] ?? null;
    $this->repeated_int32 = $s['repeated_int32'] ?? vec[];
    $this->repeated_int64 = $s['repeated_int64'] ?? vec[];
    $this->repeated_uint32 = $s['repeated_uint32'] ?? vec[];
    $this->repeated_uint64 = $s['repeated_uint64'] ?? vec[];
    $this->repeated_sint32 = $s['repeated_sint32'] ?? vec[];
    $this->repeated_sint64 = $s['repeated_sint64'] ?? vec[];
    $this->repeated_fixed32 = $s['repeated_fixed32'] ?? vec[];
    $this->repeated_fixed64 = $s['repeated_fixed64'] ?? vec[];
    $this->repeated_sfixed32 = $s['repeated_sfixed32'] ?? vec[];
    $this->repeated_sfixed64 = $s['repeated_sfixed64'] ?? vec[];
    $this->repeated_float = $s['repeated_float'] ?? vec[];
    $this->repeated_double = $s['repeated_double'] ?? vec[];
    $this->repeated_bool = $s['repeated_bool'] ?? vec[];
    $this->repeated_string = $s['repeated_string'] ?? vec[];
    $this->repeated_bytes = $s['repeated_bytes'] ?? vec[];
    $this->repeated_nested_message = $s['repeated_nested_message'] ?? vec[];
    $this->repeated_foreign_message = $s['repeated_foreign_message'] ?? vec[];
    $this->repeated_nested_enum = $s['repeated_nested_enum'] ?? vec[];
    $this->repeated_foreign_enum = $s['repeated_foreign_enum'] ?? vec[];
    $this->repeated_string_piece = $s['repeated_string_piece'] ?? vec[];
    $this->repeated_cord = $s['repeated_cord'] ?? vec[];
    $this->packed_int32 = $s['packed_int32'] ?? vec[];
    $this->packed_int64 = $s['packed_int64'] ?? vec[];
    $this->packed_uint32 = $s['packed_uint32'] ?? vec[];
    $this->packed_uint64 = $s['packed_uint64'] ?? vec[];
    $this->packed_sint32 = $s['packed_sint32'] ?? vec[];
    $this->packed_sint64 = $s['packed_sint64'] ?? vec[];
    $this->packed_fixed32 = $s['packed_fixed32'] ?? vec[];
    $this->packed_fixed64 = $s['packed_fixed64'] ?? vec[];
    $this->packed_sfixed32 = $s['packed_sfixed32'] ?? vec[];
    $this->packed_sfixed64 = $s['packed_sfixed64'] ?? vec[];
    $this->packed_float = $s['packed_float'] ?? vec[];
    $this->packed_double = $s['packed_double'] ?? vec[];
    $this->packed_bool = $s['packed_bool'] ?? vec[];
    $this->packed_nested_enum = $s['packed_nested_enum'] ?? vec[];
    $this->unpacked_int32 = $s['unpacked_int32'] ?? vec[];
    $this->unpacked_int64 = $s['unpacked_int64'] ?? vec[];
    $this->unpacked_uint32 = $s['unpacked_uint32'] ?? vec[];
    $this->unpacked_uint64 = $s['unpacked_uint64'] ?? vec[];
    $this->unpacked_sint32 = $s['unpacked_sint32'] ?? vec[];
    $this->unpacked_sint64 = $s['unpacked_sint64'] ?? vec[];
    $this->unpacked_fixed32 = $s['unpacked_fixed32'] ?? vec[];
    $this->unpacked_fixed64 = $s['unpacked_fixed64'] ?? vec[];
    $this->unpacked_sfixed32 = $s['unpacked_sfixed32'] ?? vec[];
    $this->unpacked_sfixed64 = $s['unpacked_sfixed64'] ?? vec[];
    $this->unpacked_float = $s['unpacked_float'] ?? vec[];
    $this->unpacked_double = $s['unpacked_double'] ?? vec[];
    $this->unpacked_bool = $s['unpacked_bool'] ?? vec[];
    $this->unpacked_nested_enum = $s['unpacked_nested_enum'] ?? vec[];
    $this->map_int32_int32 = $s['map_int32_int32'] ?? dict[];
    $this->map_int64_int64 = $s['map_int64_int64'] ?? dict[];
    $this->map_uint32_uint32 = $s['map_uint32_uint32'] ?? dict[];
    $this->map_uint64_uint64 = $s['map_uint64_uint64'] ?? dict[];
    $this->map_sint32_sint32 = $s['map_sint32_sint32'] ?? dict[];
    $this->map_sint64_sint64 = $s['map_sint64_sint64'] ?? dict[];
    $this->map_fixed32_fixed32 = $s['map_fixed32_fixed32'] ?? dict[];
    $this->map_fixed64_fixed64 = $s['map_fixed64_fixed64'] ?? dict[];
    $this->map_sfixed32_sfixed32 = $s['map_sfixed32_sfixed32'] ?? dict[];
    $this->map_sfixed64_sfixed64 = $s['map_sfixed64_sfixed64'] ?? dict[];
    $this->map_int32_float = $s['map_int32_float'] ?? dict[];
    $this->map_int32_double = $s['map_int32_double'] ?? dict[];
    $this->map_bool_bool = $s['map_bool_bool'] ?? dict[];
    $this->map_string_string = $s['map_string_string'] ?? dict[];
    $this->map_string_bytes = $s['map_string_bytes'] ?? dict[];
    $this->map_string_nested_message = $s['map_string_nested_message'] ?? dict[];
    $this->map_string_foreign_message = $s['map_string_foreign_message'] ?? dict[];
    $this->map_string_nested_enum = $s['map_string_nested_enum'] ?? dict[];
    $this->map_string_foreign_enum = $s['map_string_foreign_enum'] ?? dict[];
    $this->optional_bool_wrapper = $s['optional_bool_wrapper'] ?? null;
    $this->optional_int32_wrapper = $s['optional_int32_wrapper'] ?? null;
    $this->optional_int64_wrapper = $s['optional_int64_wrapper'] ?? null;
    $this->optional_uint32_wrapper = $s['optional_uint32_wrapper'] ?? null;
    $this->optional_uint64_wrapper = $s['optional_uint64_wrapper'] ?? null;
    $this->optional_float_wrapper = $s['optional_float_wrapper'] ?? null;
    $this->optional_double_wrapper = $s['optional_double_wrapper'] ?? null;
    $this->optional_string_wrapper = $s['optional_string_wrapper'] ?? null;
    $this->optional_bytes_wrapper = $s['optional_bytes_wrapper'] ?? null;
    $this->repeated_bool_wrapper = $s['repeated_bool_wrapper'] ?? vec[];
    $this->repeated_int32_wrapper = $s['repeated_int32_wrapper'] ?? vec[];
    $this->repeated_int64_wrapper = $s['repeated_int64_wrapper'] ?? vec[];
    $this->repeated_uint32_wrapper = $s['repeated_uint32_wrapper'] ?? vec[];
    $this->repeated_uint64_wrapper = $s['repeated_uint64_wrapper'] ?? vec[];
    $this->repeated_float_wrapper = $s['repeated_float_wrapper'] ?? vec[];
    $this->repeated_double_wrapper = $s['repeated_double_wrapper'] ?? vec[];
    $this->repeated_string_wrapper = $s['repeated_string_wrapper'] ?? vec[];
    $this->repeated_bytes_wrapper = $s['repeated_bytes_wrapper'] ?? vec[];
    $this->optional_duration = $s['optional_duration'] ?? null;
    $this->optional_timestamp = $s['optional_timestamp'] ?? null;
    $this->optional_field_mask = $s['optional_field_mask'] ?? null;
    $this->optional_struct = $s['optional_struct'] ?? null;
    $this->optional_any = $s['optional_any'] ?? null;
    $this->optional_value = $s['optional_value'] ?? null;
    $this->optional_null_value = $s['optional_null_value'] ?? \google\protobuf\NullValue::FromInt(0);
    $this->repeated_duration = $s['repeated_duration'] ?? vec[];
    $this->repeated_timestamp = $s['repeated_timestamp'] ?? vec[];
    $this->repeated_fieldmask = $s['repeated_fieldmask'] ?? vec[];
    $this->repeated_struct = $s['repeated_struct'] ?? vec[];
    $this->repeated_any = $s['repeated_any'] ?? vec[];
    $this->repeated_value = $s['repeated_value'] ?? vec[];
    $this->repeated_list_value = $s['repeated_list_value'] ?? vec[];
    $this->fieldname1 = $s['fieldname1'] ?? 0;
    $this->field_name2 = $s['field_name2'] ?? 0;
    $this->_field_name3 = $s['_field_name3'] ?? 0;
    $this->field__name4_ = $s['field__name4_'] ?? 0;
    $this->field0name5 = $s['field0name5'] ?? 0;
    $this->field_0_name6 = $s['field_0_name6'] ?? 0;
    $this->fieldName7 = $s['fieldName7'] ?? 0;
    $this->FieldName8 = $s['FieldName8'] ?? 0;
    $this->field_Name9 = $s['field_Name9'] ?? 0;
    $this->Field_Name10 = $s['Field_Name10'] ?? 0;
    $this->FIELD_NAME11 = $s['FIELD_NAME11'] ?? 0;
    $this->FIELD_name12 = $s['FIELD_name12'] ?? 0;
    $this->__field_name13 = $s['__field_name13'] ?? 0;
    $this->__Field_name14 = $s['__Field_name14'] ?? 0;
    $this->field__name15 = $s['field__name15'] ?? 0;
    $this->field__Name16 = $s['field__Name16'] ?? 0;
    $this->field_name17__ = $s['field_name17__'] ?? 0;
    $this->Field_name18__ = $s['Field_name18__'] ?? 0;
    $this->oneof_field = $s['oneof_field'] ?? new TestAllTypesProto3_oneof_field_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.TestAllTypesProto3";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto3 {
    $msg = new TestAllTypesProto3();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->optional_int32 = $d->readVarint32Signed();
          break;
        case 2:
          $this->optional_int64 = $d->readVarint();
          break;
        case 3:
          $this->optional_uint32 = $d->readVarint32();
          break;
        case 4:
          $this->optional_uint64 = $d->readVarint();
          break;
        case 5:
          $this->optional_sint32 = $d->readVarintZigZag32();
          break;
        case 6:
          $this->optional_sint64 = $d->readVarintZigZag64();
          break;
        case 7:
          $this->optional_fixed32 = $d->readLittleEndianInt32Unsigned();
          break;
        case 8:
          $this->optional_fixed64 = $d->readLittleEndianInt64();
          break;
        case 9:
          $this->optional_sfixed32 = $d->readLittleEndianInt32Signed();
          break;
        case 10:
          $this->optional_sfixed64 = $d->readLittleEndianInt64();
          break;
        case 11:
          $this->optional_float = $d->readFloat();
          break;
        case 12:
          $this->optional_double = $d->readDouble();
          break;
        case 13:
          $this->optional_bool = $d->readBool();
          break;
        case 14:
          $this->optional_string = $d->readString();
          break;
        case 15:
          $this->optional_bytes = $d->readString();
          break;
        case 18:
          if ($this->optional_nested_message == null) $this->optional_nested_message = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $this->optional_nested_message->MergeFrom($d->readDecoder());
          break;
        case 19:
          if ($this->optional_foreign_message == null) $this->optional_foreign_message = new \protobuf_test_messages\proto3\ForeignMessage();
          $this->optional_foreign_message->MergeFrom($d->readDecoder());
          break;
        case 21:
          $this->optional_nested_enum = \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint());
          break;
        case 22:
          $this->optional_foreign_enum = \protobuf_test_messages\proto3\ForeignEnum::FromInt($d->readVarint());
          break;
        case 23:
          $this->optional_aliased_enum = \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum::FromInt($d->readVarint());
          break;
        case 24:
          $this->optional_string_piece = $d->readString();
          break;
        case 25:
          $this->optional_cord = $d->readString();
          break;
        case 27:
          if ($this->recursive_message == null) $this->recursive_message = new \protobuf_test_messages\proto3\TestAllTypesProto3();
          $this->recursive_message->MergeFrom($d->readDecoder());
          break;
        case 31:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->repeated_int32 []= $d->readVarint32Signed();
          }
          break;
        case 32:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int64 []= $packed->readVarint();
            }
          } else {
            $this->repeated_int64 []= $d->readVarint();
          }
          break;
        case 33:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->repeated_uint32 []= $d->readVarint32();
          }
          break;
        case 34:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_uint64 []= $packed->readVarint();
            }
          } else {
            $this->repeated_uint64 []= $d->readVarint();
          }
          break;
        case 35:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->repeated_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 36:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->repeated_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 37:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->repeated_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 38:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->repeated_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 39:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->repeated_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 40:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->repeated_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 41:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_float []= $packed->readFloat();
            }
          } else {
            $this->repeated_float []= $d->readFloat();
          }
          break;
        case 42:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_double []= $packed->readDouble();
            }
          } else {
            $this->repeated_double []= $d->readDouble();
          }
          break;
        case 43:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_bool []= $packed->readBool();
            }
          } else {
            $this->repeated_bool []= $d->readBool();
          }
          break;
        case 44:
          $this->repeated_string []= $d->readString();
          break;
        case 45:
          $this->repeated_bytes []= $d->readString();
          break;
        case 48:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_nested_message []= $obj;
          break;
        case 49:
          $obj = new \protobuf_test_messages\proto3\ForeignMessage();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_foreign_message []= $obj;
          break;
        case 51:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->repeated_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 52:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_foreign_enum []= \protobuf_test_messages\proto3\ForeignEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->repeated_foreign_enum []= \protobuf_test_messages\proto3\ForeignEnum::FromInt($d->readVarint());
          }
          break;
        case 54:
          $this->repeated_string_piece []= $d->readString();
          break;
        case 55:
          $this->repeated_cord []= $d->readString();
          break;
        case 56:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32Int32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_int32[$obj->key] = $obj->value;
          break;
        case 57:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt64Int64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int64_int64[$obj->key] = $obj->value;
          break;
        case 58:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapUint32Uint32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_uint32_uint32[$obj->key] = $obj->value;
          break;
        case 59:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapUint64Uint64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_uint64_uint64[$obj->key] = $obj->value;
          break;
        case 60:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSint32Sint32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sint32_sint32[$obj->key] = $obj->value;
          break;
        case 61:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSint64Sint64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sint64_sint64[$obj->key] = $obj->value;
          break;
        case 62:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapFixed32Fixed32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_fixed32_fixed32[$obj->key] = $obj->value;
          break;
        case 63:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapFixed64Fixed64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_fixed64_fixed64[$obj->key] = $obj->value;
          break;
        case 64:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSfixed32Sfixed32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sfixed32_sfixed32[$obj->key] = $obj->value;
          break;
        case 65:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSfixed64Sfixed64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sfixed64_sfixed64[$obj->key] = $obj->value;
          break;
        case 66:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32FloatEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_float[$obj->key] = $obj->value;
          break;
        case 67:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32DoubleEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_double[$obj->key] = $obj->value;
          break;
        case 68:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapBoolBoolEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_bool_bool[\Protobuf\BoolMapKey::FromBool($obj->key)] = $obj->value;
          break;
        case 69:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringStringEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_string[$obj->key] = $obj->value;
          break;
        case 70:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringBytesEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_bytes[$obj->key] = $obj->value;
          break;
        case 71:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringNestedMessageEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_nested_message[$obj->key] = $obj->value ?? new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          break;
        case 72:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringForeignMessageEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_foreign_message[$obj->key] = $obj->value ?? new \protobuf_test_messages\proto3\ForeignMessage();
          break;
        case 73:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringNestedEnumEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_nested_enum[$obj->key] = $obj->value;
          break;
        case 74:
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringForeignEnumEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_foreign_enum[$obj->key] = $obj->value;
          break;
        case 75:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->packed_int32 []= $d->readVarint32Signed();
          }
          break;
        case 76:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_int64 []= $packed->readVarint();
            }
          } else {
            $this->packed_int64 []= $d->readVarint();
          }
          break;
        case 77:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->packed_uint32 []= $d->readVarint32();
          }
          break;
        case 78:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_uint64 []= $packed->readVarint();
            }
          } else {
            $this->packed_uint64 []= $d->readVarint();
          }
          break;
        case 79:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->packed_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 80:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->packed_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 81:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->packed_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 82:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->packed_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 83:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->packed_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 84:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->packed_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 85:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_float []= $packed->readFloat();
            }
          } else {
            $this->packed_float []= $d->readFloat();
          }
          break;
        case 86:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_double []= $packed->readDouble();
            }
          } else {
            $this->packed_double []= $d->readDouble();
          }
          break;
        case 87:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_bool []= $packed->readBool();
            }
          } else {
            $this->packed_bool []= $d->readBool();
          }
          break;
        case 88:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->packed_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 89:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->unpacked_int32 []= $d->readVarint32Signed();
          }
          break;
        case 90:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_int64 []= $packed->readVarint();
            }
          } else {
            $this->unpacked_int64 []= $d->readVarint();
          }
          break;
        case 91:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->unpacked_uint32 []= $d->readVarint32();
          }
          break;
        case 92:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_uint64 []= $packed->readVarint();
            }
          } else {
            $this->unpacked_uint64 []= $d->readVarint();
          }
          break;
        case 93:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->unpacked_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 94:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->unpacked_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 95:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->unpacked_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 96:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->unpacked_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 97:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->unpacked_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 98:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->unpacked_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 99:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_float []= $packed->readFloat();
            }
          } else {
            $this->unpacked_float []= $d->readFloat();
          }
          break;
        case 100:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_double []= $packed->readDouble();
            }
          } else {
            $this->unpacked_double []= $d->readDouble();
          }
          break;
        case 101:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_bool []= $packed->readBool();
            }
          } else {
            $this->unpacked_bool []= $d->readBool();
          }
          break;
        case 102:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->unpacked_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 111:
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_uint32($d->readVarint32());
          break;
        case 112:
          if ($this->oneof_field->WhichOneof() == TestAllTypesProto3_oneof_field_oneof_t::oneof_nested_message) {
            ($this->oneof_field as TestAllTypesProto3_oneof_field_oneof_nested_message)->oneof_nested_message->MergeFrom($d->readDecoder());
          } else {
            $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
            $obj->MergeFrom($d->readDecoder());
            $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_nested_message($obj);
          }
          break;
        case 113:
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_string($d->readString());
          break;
        case 114:
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_bytes($d->readString());
          break;
        case 115:
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_bool($d->readBool());
          break;
        case 116:
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_uint64($d->readVarint());
          break;
        case 117:
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_float($d->readFloat());
          break;
        case 118:
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_double($d->readDouble());
          break;
        case 119:
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_enum(\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt($d->readVarint()));
          break;
        case 120:
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_null_value(\google\protobuf\NullValue::FromInt($d->readVarint()));
          break;
        case 201:
          if ($this->optional_bool_wrapper == null) $this->optional_bool_wrapper = new \google\protobuf\BoolValue();
          $this->optional_bool_wrapper->MergeFrom($d->readDecoder());
          break;
        case 202:
          if ($this->optional_int32_wrapper == null) $this->optional_int32_wrapper = new \google\protobuf\Int32Value();
          $this->optional_int32_wrapper->MergeFrom($d->readDecoder());
          break;
        case 203:
          if ($this->optional_int64_wrapper == null) $this->optional_int64_wrapper = new \google\protobuf\Int64Value();
          $this->optional_int64_wrapper->MergeFrom($d->readDecoder());
          break;
        case 204:
          if ($this->optional_uint32_wrapper == null) $this->optional_uint32_wrapper = new \google\protobuf\UInt32Value();
          $this->optional_uint32_wrapper->MergeFrom($d->readDecoder());
          break;
        case 205:
          if ($this->optional_uint64_wrapper == null) $this->optional_uint64_wrapper = new \google\protobuf\UInt64Value();
          $this->optional_uint64_wrapper->MergeFrom($d->readDecoder());
          break;
        case 206:
          if ($this->optional_float_wrapper == null) $this->optional_float_wrapper = new \google\protobuf\FloatValue();
          $this->optional_float_wrapper->MergeFrom($d->readDecoder());
          break;
        case 207:
          if ($this->optional_double_wrapper == null) $this->optional_double_wrapper = new \google\protobuf\DoubleValue();
          $this->optional_double_wrapper->MergeFrom($d->readDecoder());
          break;
        case 208:
          if ($this->optional_string_wrapper == null) $this->optional_string_wrapper = new \google\protobuf\StringValue();
          $this->optional_string_wrapper->MergeFrom($d->readDecoder());
          break;
        case 209:
          if ($this->optional_bytes_wrapper == null) $this->optional_bytes_wrapper = new \google\protobuf\BytesValue();
          $this->optional_bytes_wrapper->MergeFrom($d->readDecoder());
          break;
        case 211:
          $obj = new \google\protobuf\BoolValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_bool_wrapper []= $obj;
          break;
        case 212:
          $obj = new \google\protobuf\Int32Value();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_int32_wrapper []= $obj;
          break;
        case 213:
          $obj = new \google\protobuf\Int64Value();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_int64_wrapper []= $obj;
          break;
        case 214:
          $obj = new \google\protobuf\UInt32Value();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_uint32_wrapper []= $obj;
          break;
        case 215:
          $obj = new \google\protobuf\UInt64Value();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_uint64_wrapper []= $obj;
          break;
        case 216:
          $obj = new \google\protobuf\FloatValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_float_wrapper []= $obj;
          break;
        case 217:
          $obj = new \google\protobuf\DoubleValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_double_wrapper []= $obj;
          break;
        case 218:
          $obj = new \google\protobuf\StringValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_string_wrapper []= $obj;
          break;
        case 219:
          $obj = new \google\protobuf\BytesValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_bytes_wrapper []= $obj;
          break;
        case 301:
          if ($this->optional_duration == null) $this->optional_duration = new \google\protobuf\Duration();
          $this->optional_duration->MergeFrom($d->readDecoder());
          break;
        case 302:
          if ($this->optional_timestamp == null) $this->optional_timestamp = new \google\protobuf\Timestamp();
          $this->optional_timestamp->MergeFrom($d->readDecoder());
          break;
        case 303:
          if ($this->optional_field_mask == null) $this->optional_field_mask = new \google\protobuf\FieldMask();
          $this->optional_field_mask->MergeFrom($d->readDecoder());
          break;
        case 304:
          if ($this->optional_struct == null) $this->optional_struct = new \google\protobuf\Struct();
          $this->optional_struct->MergeFrom($d->readDecoder());
          break;
        case 305:
          if ($this->optional_any == null) $this->optional_any = new \google\protobuf\Any();
          $this->optional_any->MergeFrom($d->readDecoder());
          break;
        case 306:
          if ($this->optional_value == null) $this->optional_value = new \google\protobuf\Value();
          $this->optional_value->MergeFrom($d->readDecoder());
          break;
        case 307:
          $this->optional_null_value = \google\protobuf\NullValue::FromInt($d->readVarint());
          break;
        case 311:
          $obj = new \google\protobuf\Duration();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_duration []= $obj;
          break;
        case 312:
          $obj = new \google\protobuf\Timestamp();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_timestamp []= $obj;
          break;
        case 313:
          $obj = new \google\protobuf\FieldMask();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_fieldmask []= $obj;
          break;
        case 315:
          $obj = new \google\protobuf\Any();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_any []= $obj;
          break;
        case 316:
          $obj = new \google\protobuf\Value();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_value []= $obj;
          break;
        case 317:
          $obj = new \google\protobuf\ListValue();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_list_value []= $obj;
          break;
        case 324:
          $obj = new \google\protobuf\Struct();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_struct []= $obj;
          break;
        case 401:
          $this->fieldname1 = $d->readVarint32Signed();
          break;
        case 402:
          $this->field_name2 = $d->readVarint32Signed();
          break;
        case 403:
          $this->_field_name3 = $d->readVarint32Signed();
          break;
        case 404:
          $this->field__name4_ = $d->readVarint32Signed();
          break;
        case 405:
          $this->field0name5 = $d->readVarint32Signed();
          break;
        case 406:
          $this->field_0_name6 = $d->readVarint32Signed();
          break;
        case 407:
          $this->fieldName7 = $d->readVarint32Signed();
          break;
        case 408:
          $this->FieldName8 = $d->readVarint32Signed();
          break;
        case 409:
          $this->field_Name9 = $d->readVarint32Signed();
          break;
        case 410:
          $this->Field_Name10 = $d->readVarint32Signed();
          break;
        case 411:
          $this->FIELD_NAME11 = $d->readVarint32Signed();
          break;
        case 412:
          $this->FIELD_name12 = $d->readVarint32Signed();
          break;
        case 413:
          $this->__field_name13 = $d->readVarint32Signed();
          break;
        case 414:
          $this->__Field_name14 = $d->readVarint32Signed();
          break;
        case 415:
          $this->field__name15 = $d->readVarint32Signed();
          break;
        case 416:
          $this->field__Name16 = $d->readVarint32Signed();
          break;
        case 417:
          $this->field_name17__ = $d->readVarint32Signed();
          break;
        case 418:
          $this->Field_name18__ = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->optional_int32 !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->optional_int32);
    }
    if ($this->optional_int64 !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->optional_int64);
    }
    if ($this->optional_uint32 !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->optional_uint32);
    }
    if ($this->optional_uint64 !== 0) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->optional_uint64);
    }
    if ($this->optional_sint32 !== 0) {
      $e->writeTag(5, 0);
      $e->writeVarintZigZag32($this->optional_sint32);
    }
    if ($this->optional_sint64 !== 0) {
      $e->writeTag(6, 0);
      $e->writeVarintZigZag64($this->optional_sint64);
    }
    if ($this->optional_fixed32 !== 0) {
      $e->writeTag(7, 5);
      $e->writeLittleEndianInt32Unsigned($this->optional_fixed32);
    }
    if ($this->optional_fixed64 !== 0) {
      $e->writeTag(8, 1);
      $e->writeLittleEndianInt64($this->optional_fixed64);
    }
    if ($this->optional_sfixed32 !== 0) {
      $e->writeTag(9, 5);
      $e->writeLittleEndianInt32Signed($this->optional_sfixed32);
    }
    if ($this->optional_sfixed64 !== 0) {
      $e->writeTag(10, 1);
      $e->writeLittleEndianInt64($this->optional_sfixed64);
    }
    if ($this->optional_float !== 0.0) {
      $e->writeTag(11, 5);
      $e->writeFloat($this->optional_float);
    }
    if ($this->optional_double !== 0.0) {
      $e->writeTag(12, 1);
      $e->writeDouble($this->optional_double);
    }
    if ($this->optional_bool !== false) {
      $e->writeTag(13, 0);
      $e->writeBool($this->optional_bool);
    }
    if ($this->optional_string !== '') {
      $e->writeTag(14, 2);
      $e->writeString($this->optional_string);
    }
    if ($this->optional_bytes !== '') {
      $e->writeTag(15, 2);
      $e->writeString($this->optional_bytes);
    }
    $msg = $this->optional_nested_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 18);
    }
    $msg = $this->optional_foreign_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 19);
    }
    if ($this->optional_nested_enum !== \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromInt(0)) {
      $e->writeTag(21, 0);
      $e->writeVarint($this->optional_nested_enum);
    }
    if ($this->optional_foreign_enum !== \protobuf_test_messages\proto3\ForeignEnum::FromInt(0)) {
      $e->writeTag(22, 0);
      $e->writeVarint($this->optional_foreign_enum);
    }
    if ($this->optional_aliased_enum !== \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum::FromInt(0)) {
      $e->writeTag(23, 0);
      $e->writeVarint($this->optional_aliased_enum);
    }
    if ($this->optional_string_piece !== '') {
      $e->writeTag(24, 2);
      $e->writeString($this->optional_string_piece);
    }
    if ($this->optional_cord !== '') {
      $e->writeTag(25, 2);
      $e->writeString($this->optional_cord);
    }
    $msg = $this->recursive_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 27);
    }
    if (\count($this->repeated_int32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_int32 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 31);
    }
    if (\count($this->repeated_int64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_int64 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 32);
    }
    if (\count($this->repeated_uint32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_uint32 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 33);
    }
    if (\count($this->repeated_uint64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_uint64 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 34);
    }
    if (\count($this->repeated_sint32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_sint32 as $elem) {
        $packed->writeVarintZigZag32($elem);
      }
      $e->writeEncoder($packed, 35);
    }
    if (\count($this->repeated_sint64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_sint64 as $elem) {
        $packed->writeVarintZigZag64($elem);
      }
      $e->writeEncoder($packed, 36);
    }
    if (\count($this->repeated_fixed32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_fixed32 as $elem) {
        $packed->writeLittleEndianInt32Unsigned($elem);
      }
      $e->writeEncoder($packed, 37);
    }
    if (\count($this->repeated_fixed64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_fixed64 as $elem) {
        $packed->writeLittleEndianInt64($elem);
      }
      $e->writeEncoder($packed, 38);
    }
    if (\count($this->repeated_sfixed32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_sfixed32 as $elem) {
        $packed->writeLittleEndianInt32Signed($elem);
      }
      $e->writeEncoder($packed, 39);
    }
    if (\count($this->repeated_sfixed64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_sfixed64 as $elem) {
        $packed->writeLittleEndianInt64($elem);
      }
      $e->writeEncoder($packed, 40);
    }
    if (\count($this->repeated_float) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_float as $elem) {
        $packed->writeFloat($elem);
      }
      $e->writeEncoder($packed, 41);
    }
    if (\count($this->repeated_double) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_double as $elem) {
        $packed->writeDouble($elem);
      }
      $e->writeEncoder($packed, 42);
    }
    if (\count($this->repeated_bool) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_bool as $elem) {
        $packed->writeBool($elem);
      }
      $e->writeEncoder($packed, 43);
    }
    foreach ($this->repeated_string as $elem) {
      $e->writeTag(44, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_bytes as $elem) {
      $e->writeTag(45, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_nested_message as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 48);
    }
    foreach ($this->repeated_foreign_message as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 49);
    }
    if (\count($this->repeated_nested_enum) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_nested_enum as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 51);
    }
    if (\count($this->repeated_foreign_enum) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->repeated_foreign_enum as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 52);
    }
    foreach ($this->repeated_string_piece as $elem) {
      $e->writeTag(54, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_cord as $elem) {
      $e->writeTag(55, 2);
      $e->writeString($elem);
    }
    foreach ($this->map_int32_int32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32Int32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 56);
    }
    foreach ($this->map_int64_int64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt64Int64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 57);
    }
    foreach ($this->map_uint32_uint32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapUint32Uint32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 58);
    }
    foreach ($this->map_uint64_uint64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapUint64Uint64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 59);
    }
    foreach ($this->map_sint32_sint32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSint32Sint32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 60);
    }
    foreach ($this->map_sint64_sint64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSint64Sint64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 61);
    }
    foreach ($this->map_fixed32_fixed32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapFixed32Fixed32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 62);
    }
    foreach ($this->map_fixed64_fixed64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapFixed64Fixed64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 63);
    }
    foreach ($this->map_sfixed32_sfixed32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSfixed32Sfixed32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 64);
    }
    foreach ($this->map_sfixed64_sfixed64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapSfixed64Sfixed64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 65);
    }
    foreach ($this->map_int32_float as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32FloatEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 66);
    }
    foreach ($this->map_int32_double as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapInt32DoubleEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 67);
    }
    foreach ($this->map_bool_bool as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapBoolBoolEntry();
      $obj->key = \Protobuf\BoolMapKey::ToBool($k);
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 68);
    }
    foreach ($this->map_string_string as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringStringEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 69);
    }
    foreach ($this->map_string_bytes as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringBytesEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 70);
    }
    foreach ($this->map_string_nested_message as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringNestedMessageEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 71);
    }
    foreach ($this->map_string_foreign_message as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringForeignMessageEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 72);
    }
    foreach ($this->map_string_nested_enum as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringNestedEnumEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 73);
    }
    foreach ($this->map_string_foreign_enum as $k => $v) {
      $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_MapStringForeignEnumEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 74);
    }
    if (\count($this->packed_int32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_int32 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 75);
    }
    if (\count($this->packed_int64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_int64 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 76);
    }
    if (\count($this->packed_uint32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_uint32 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 77);
    }
    if (\count($this->packed_uint64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_uint64 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 78);
    }
    if (\count($this->packed_sint32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sint32 as $elem) {
        $packed->writeVarintZigZag32($elem);
      }
      $e->writeEncoder($packed, 79);
    }
    if (\count($this->packed_sint64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sint64 as $elem) {
        $packed->writeVarintZigZag64($elem);
      }
      $e->writeEncoder($packed, 80);
    }
    if (\count($this->packed_fixed32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_fixed32 as $elem) {
        $packed->writeLittleEndianInt32Unsigned($elem);
      }
      $e->writeEncoder($packed, 81);
    }
    if (\count($this->packed_fixed64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_fixed64 as $elem) {
        $packed->writeLittleEndianInt64($elem);
      }
      $e->writeEncoder($packed, 82);
    }
    if (\count($this->packed_sfixed32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sfixed32 as $elem) {
        $packed->writeLittleEndianInt32Signed($elem);
      }
      $e->writeEncoder($packed, 83);
    }
    if (\count($this->packed_sfixed64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sfixed64 as $elem) {
        $packed->writeLittleEndianInt64($elem);
      }
      $e->writeEncoder($packed, 84);
    }
    if (\count($this->packed_float) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_float as $elem) {
        $packed->writeFloat($elem);
      }
      $e->writeEncoder($packed, 85);
    }
    if (\count($this->packed_double) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_double as $elem) {
        $packed->writeDouble($elem);
      }
      $e->writeEncoder($packed, 86);
    }
    if (\count($this->packed_bool) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_bool as $elem) {
        $packed->writeBool($elem);
      }
      $e->writeEncoder($packed, 87);
    }
    if (\count($this->packed_nested_enum) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_nested_enum as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 88);
    }
    foreach ($this->unpacked_int32 as $elem) {
      $e->writeTag(89, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_int64 as $elem) {
      $e->writeTag(90, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_uint32 as $elem) {
      $e->writeTag(91, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_uint64 as $elem) {
      $e->writeTag(92, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_sint32 as $elem) {
      $e->writeTag(93, 0);
      $e->writeVarintZigZag32($elem);
    }
    foreach ($this->unpacked_sint64 as $elem) {
      $e->writeTag(94, 0);
      $e->writeVarintZigZag64($elem);
    }
    foreach ($this->unpacked_fixed32 as $elem) {
      $e->writeTag(95, 5);
      $e->writeLittleEndianInt32Unsigned($elem);
    }
    foreach ($this->unpacked_fixed64 as $elem) {
      $e->writeTag(96, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->unpacked_sfixed32 as $elem) {
      $e->writeTag(97, 5);
      $e->writeLittleEndianInt32Signed($elem);
    }
    foreach ($this->unpacked_sfixed64 as $elem) {
      $e->writeTag(98, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->unpacked_float as $elem) {
      $e->writeTag(99, 5);
      $e->writeFloat($elem);
    }
    foreach ($this->unpacked_double as $elem) {
      $e->writeTag(100, 1);
      $e->writeDouble($elem);
    }
    foreach ($this->unpacked_bool as $elem) {
      $e->writeTag(101, 0);
      $e->writeBool($elem);
    }
    foreach ($this->unpacked_nested_enum as $elem) {
      $e->writeTag(102, 0);
      $e->writeVarint($elem);
    }
    $msg = $this->optional_bool_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 201);
    }
    $msg = $this->optional_int32_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 202);
    }
    $msg = $this->optional_int64_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 203);
    }
    $msg = $this->optional_uint32_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 204);
    }
    $msg = $this->optional_uint64_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 205);
    }
    $msg = $this->optional_float_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 206);
    }
    $msg = $this->optional_double_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 207);
    }
    $msg = $this->optional_string_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 208);
    }
    $msg = $this->optional_bytes_wrapper;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 209);
    }
    foreach ($this->repeated_bool_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 211);
    }
    foreach ($this->repeated_int32_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 212);
    }
    foreach ($this->repeated_int64_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 213);
    }
    foreach ($this->repeated_uint32_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 214);
    }
    foreach ($this->repeated_uint64_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 215);
    }
    foreach ($this->repeated_float_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 216);
    }
    foreach ($this->repeated_double_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 217);
    }
    foreach ($this->repeated_string_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 218);
    }
    foreach ($this->repeated_bytes_wrapper as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 219);
    }
    $msg = $this->optional_duration;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 301);
    }
    $msg = $this->optional_timestamp;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 302);
    }
    $msg = $this->optional_field_mask;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 303);
    }
    $msg = $this->optional_struct;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 304);
    }
    $msg = $this->optional_any;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 305);
    }
    $msg = $this->optional_value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 306);
    }
    if ($this->optional_null_value !== \google\protobuf\NullValue::FromInt(0)) {
      $e->writeTag(307, 0);
      $e->writeVarint($this->optional_null_value);
    }
    foreach ($this->repeated_duration as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 311);
    }
    foreach ($this->repeated_timestamp as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 312);
    }
    foreach ($this->repeated_fieldmask as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 313);
    }
    foreach ($this->repeated_any as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 315);
    }
    foreach ($this->repeated_value as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 316);
    }
    foreach ($this->repeated_list_value as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 317);
    }
    foreach ($this->repeated_struct as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 324);
    }
    if ($this->fieldname1 !== 0) {
      $e->writeTag(401, 0);
      $e->writeVarint($this->fieldname1);
    }
    if ($this->field_name2 !== 0) {
      $e->writeTag(402, 0);
      $e->writeVarint($this->field_name2);
    }
    if ($this->_field_name3 !== 0) {
      $e->writeTag(403, 0);
      $e->writeVarint($this->_field_name3);
    }
    if ($this->field__name4_ !== 0) {
      $e->writeTag(404, 0);
      $e->writeVarint($this->field__name4_);
    }
    if ($this->field0name5 !== 0) {
      $e->writeTag(405, 0);
      $e->writeVarint($this->field0name5);
    }
    if ($this->field_0_name6 !== 0) {
      $e->writeTag(406, 0);
      $e->writeVarint($this->field_0_name6);
    }
    if ($this->fieldName7 !== 0) {
      $e->writeTag(407, 0);
      $e->writeVarint($this->fieldName7);
    }
    if ($this->FieldName8 !== 0) {
      $e->writeTag(408, 0);
      $e->writeVarint($this->FieldName8);
    }
    if ($this->field_Name9 !== 0) {
      $e->writeTag(409, 0);
      $e->writeVarint($this->field_Name9);
    }
    if ($this->Field_Name10 !== 0) {
      $e->writeTag(410, 0);
      $e->writeVarint($this->Field_Name10);
    }
    if ($this->FIELD_NAME11 !== 0) {
      $e->writeTag(411, 0);
      $e->writeVarint($this->FIELD_NAME11);
    }
    if ($this->FIELD_name12 !== 0) {
      $e->writeTag(412, 0);
      $e->writeVarint($this->FIELD_name12);
    }
    if ($this->__field_name13 !== 0) {
      $e->writeTag(413, 0);
      $e->writeVarint($this->__field_name13);
    }
    if ($this->__Field_name14 !== 0) {
      $e->writeTag(414, 0);
      $e->writeVarint($this->__Field_name14);
    }
    if ($this->field__name15 !== 0) {
      $e->writeTag(415, 0);
      $e->writeVarint($this->field__name15);
    }
    if ($this->field__Name16 !== 0) {
      $e->writeTag(416, 0);
      $e->writeVarint($this->field__Name16);
    }
    if ($this->field_name17__ !== 0) {
      $e->writeTag(417, 0);
      $e->writeVarint($this->field_name17__);
    }
    if ($this->Field_name18__ !== 0) {
      $e->writeTag(418, 0);
      $e->writeVarint($this->Field_name18__);
    }
    $this->oneof_field->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('optional_int32', 'optionalInt32', $this->optional_int32, false);
    $e->writeInt64Signed('optional_int64', 'optionalInt64', $this->optional_int64, false);
    $e->writeInt32('optional_uint32', 'optionalUint32', $this->optional_uint32, false);
    $e->writeInt64Unsigned('optional_uint64', 'optionalUint64', $this->optional_uint64, false);
    $e->writeInt32('optional_sint32', 'optionalSint32', $this->optional_sint32, false);
    $e->writeInt64Signed('optional_sint64', 'optionalSint64', $this->optional_sint64, false);
    $e->writeInt32('optional_fixed32', 'optionalFixed32', $this->optional_fixed32, false);
    $e->writeInt64Unsigned('optional_fixed64', 'optionalFixed64', $this->optional_fixed64, false);
    $e->writeInt32('optional_sfixed32', 'optionalSfixed32', $this->optional_sfixed32, false);
    $e->writeInt64Signed('optional_sfixed64', 'optionalSfixed64', $this->optional_sfixed64, false);
    $e->writeFloat('optional_float', 'optionalFloat', $this->optional_float, false);
    $e->writeFloat('optional_double', 'optionalDouble', $this->optional_double, false);
    $e->writeBool('optional_bool', 'optionalBool', $this->optional_bool, false);
    $e->writeString('optional_string', 'optionalString', $this->optional_string, false);
    $e->writeBytes('optional_bytes', 'optionalBytes', $this->optional_bytes, false);
    $e->writeMessage('optional_nested_message', 'optionalNestedMessage', $this->optional_nested_message, false);
    $e->writeMessage('optional_foreign_message', 'optionalForeignMessage', $this->optional_foreign_message, false);
    $e->writeEnum('optional_nested_enum', 'optionalNestedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->optional_nested_enum, false);
    $e->writeEnum('optional_foreign_enum', 'optionalForeignEnum', \protobuf_test_messages\proto3\ForeignEnum::ToStringDict(), $this->optional_foreign_enum, false);
    $e->writeEnum('optional_aliased_enum', 'optionalAliasedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum::ToStringDict(), $this->optional_aliased_enum, false);
    $e->writeString('optional_string_piece', 'optionalStringPiece', $this->optional_string_piece, false);
    $e->writeString('optional_cord', 'optionalCord', $this->optional_cord, false);
    $e->writeMessage('recursive_message', 'recursiveMessage', $this->recursive_message, false);
    $e->writePrimitiveList('repeated_int32', 'repeatedInt32', $this->repeated_int32);
    $e->writeInt64SignedList('repeated_int64', 'repeatedInt64', $this->repeated_int64);
    $e->writePrimitiveList('repeated_uint32', 'repeatedUint32', $this->repeated_uint32);
    $e->writeInt64UnsignedList('repeated_uint64', 'repeatedUint64', $this->repeated_uint64);
    $e->writePrimitiveList('repeated_sint32', 'repeatedSint32', $this->repeated_sint32);
    $e->writeInt64SignedList('repeated_sint64', 'repeatedSint64', $this->repeated_sint64);
    $e->writePrimitiveList('repeated_fixed32', 'repeatedFixed32', $this->repeated_fixed32);
    $e->writeInt64UnsignedList('repeated_fixed64', 'repeatedFixed64', $this->repeated_fixed64);
    $e->writePrimitiveList('repeated_sfixed32', 'repeatedSfixed32', $this->repeated_sfixed32);
    $e->writeInt64SignedList('repeated_sfixed64', 'repeatedSfixed64', $this->repeated_sfixed64);
    $e->writeFloatList('repeated_float', 'repeatedFloat', $this->repeated_float);
    $e->writeFloatList('repeated_double', 'repeatedDouble', $this->repeated_double);
    $e->writePrimitiveList('repeated_bool', 'repeatedBool', $this->repeated_bool);
    $e->writePrimitiveList('repeated_string', 'repeatedString', $this->repeated_string);
    $e->writeBytesList('repeated_bytes', 'repeatedBytes', $this->repeated_bytes);
    $e->writeMessageList('repeated_nested_message', 'repeatedNestedMessage', $this->repeated_nested_message);
    $e->writeMessageList('repeated_foreign_message', 'repeatedForeignMessage', $this->repeated_foreign_message);
    $e->writeEnumList('repeated_nested_enum', 'repeatedNestedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->repeated_nested_enum);
    $e->writeEnumList('repeated_foreign_enum', 'repeatedForeignEnum', \protobuf_test_messages\proto3\ForeignEnum::ToStringDict(), $this->repeated_foreign_enum);
    $e->writePrimitiveList('repeated_string_piece', 'repeatedStringPiece', $this->repeated_string_piece);
    $e->writePrimitiveList('repeated_cord', 'repeatedCord', $this->repeated_cord);
    $e->writePrimitiveMap('map_int32_int32', 'mapInt32Int32', $this->map_int32_int32);
    $e->writeInt64SignedMap('map_int64_int64', 'mapInt64Int64', $this->map_int64_int64);
    $e->writePrimitiveMap('map_uint32_uint32', 'mapUint32Uint32', $this->map_uint32_uint32);
    $e->writeInt64UnsignedMap('map_uint64_uint64', 'mapUint64Uint64', $this->map_uint64_uint64);
    $e->writePrimitiveMap('map_sint32_sint32', 'mapSint32Sint32', $this->map_sint32_sint32);
    $e->writeInt64SignedMap('map_sint64_sint64', 'mapSint64Sint64', $this->map_sint64_sint64);
    $e->writePrimitiveMap('map_fixed32_fixed32', 'mapFixed32Fixed32', $this->map_fixed32_fixed32);
    $e->writeInt64UnsignedMap('map_fixed64_fixed64', 'mapFixed64Fixed64', $this->map_fixed64_fixed64);
    $e->writePrimitiveMap('map_sfixed32_sfixed32', 'mapSfixed32Sfixed32', $this->map_sfixed32_sfixed32);
    $e->writeInt64SignedMap('map_sfixed64_sfixed64', 'mapSfixed64Sfixed64', $this->map_sfixed64_sfixed64);
    $e->writeFloatMap('map_int32_float', 'mapInt32Float', $this->map_int32_float);
    $e->writeFloatMap('map_int32_double', 'mapInt32Double', $this->map_int32_double);
    $e->writePrimitiveMap('map_bool_bool', 'mapBoolBool', $this->map_bool_bool);
    $e->writePrimitiveMap('map_string_string', 'mapStringString', $this->map_string_string);
    $e->writeBytesMap('map_string_bytes', 'mapStringBytes', $this->map_string_bytes);
    $e->writeMessageMap('map_string_nested_message', 'mapStringNestedMessage', $this->map_string_nested_message);
    $e->writeMessageMap('map_string_foreign_message', 'mapStringForeignMessage', $this->map_string_foreign_message);
    $e->writeEnumMap('map_string_nested_enum', 'mapStringNestedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->map_string_nested_enum);
    $e->writeEnumMap('map_string_foreign_enum', 'mapStringForeignEnum', \protobuf_test_messages\proto3\ForeignEnum::ToStringDict(), $this->map_string_foreign_enum);
    $e->writePrimitiveList('packed_int32', 'packedInt32', $this->packed_int32);
    $e->writeInt64SignedList('packed_int64', 'packedInt64', $this->packed_int64);
    $e->writePrimitiveList('packed_uint32', 'packedUint32', $this->packed_uint32);
    $e->writeInt64UnsignedList('packed_uint64', 'packedUint64', $this->packed_uint64);
    $e->writePrimitiveList('packed_sint32', 'packedSint32', $this->packed_sint32);
    $e->writeInt64SignedList('packed_sint64', 'packedSint64', $this->packed_sint64);
    $e->writePrimitiveList('packed_fixed32', 'packedFixed32', $this->packed_fixed32);
    $e->writeInt64UnsignedList('packed_fixed64', 'packedFixed64', $this->packed_fixed64);
    $e->writePrimitiveList('packed_sfixed32', 'packedSfixed32', $this->packed_sfixed32);
    $e->writeInt64SignedList('packed_sfixed64', 'packedSfixed64', $this->packed_sfixed64);
    $e->writeFloatList('packed_float', 'packedFloat', $this->packed_float);
    $e->writeFloatList('packed_double', 'packedDouble', $this->packed_double);
    $e->writePrimitiveList('packed_bool', 'packedBool', $this->packed_bool);
    $e->writeEnumList('packed_nested_enum', 'packedNestedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->packed_nested_enum);
    $e->writePrimitiveList('unpacked_int32', 'unpackedInt32', $this->unpacked_int32);
    $e->writeInt64SignedList('unpacked_int64', 'unpackedInt64', $this->unpacked_int64);
    $e->writePrimitiveList('unpacked_uint32', 'unpackedUint32', $this->unpacked_uint32);
    $e->writeInt64UnsignedList('unpacked_uint64', 'unpackedUint64', $this->unpacked_uint64);
    $e->writePrimitiveList('unpacked_sint32', 'unpackedSint32', $this->unpacked_sint32);
    $e->writeInt64SignedList('unpacked_sint64', 'unpackedSint64', $this->unpacked_sint64);
    $e->writePrimitiveList('unpacked_fixed32', 'unpackedFixed32', $this->unpacked_fixed32);
    $e->writeInt64UnsignedList('unpacked_fixed64', 'unpackedFixed64', $this->unpacked_fixed64);
    $e->writePrimitiveList('unpacked_sfixed32', 'unpackedSfixed32', $this->unpacked_sfixed32);
    $e->writeInt64SignedList('unpacked_sfixed64', 'unpackedSfixed64', $this->unpacked_sfixed64);
    $e->writeFloatList('unpacked_float', 'unpackedFloat', $this->unpacked_float);
    $e->writeFloatList('unpacked_double', 'unpackedDouble', $this->unpacked_double);
    $e->writePrimitiveList('unpacked_bool', 'unpackedBool', $this->unpacked_bool);
    $e->writeEnumList('unpacked_nested_enum', 'unpackedNestedEnum', \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::ToStringDict(), $this->unpacked_nested_enum);
    $e->writeMessage('optional_bool_wrapper', 'optionalBoolWrapper', $this->optional_bool_wrapper, false);
    $e->writeMessage('optional_int32_wrapper', 'optionalInt32Wrapper', $this->optional_int32_wrapper, false);
    $e->writeMessage('optional_int64_wrapper', 'optionalInt64Wrapper', $this->optional_int64_wrapper, false);
    $e->writeMessage('optional_uint32_wrapper', 'optionalUint32Wrapper', $this->optional_uint32_wrapper, false);
    $e->writeMessage('optional_uint64_wrapper', 'optionalUint64Wrapper', $this->optional_uint64_wrapper, false);
    $e->writeMessage('optional_float_wrapper', 'optionalFloatWrapper', $this->optional_float_wrapper, false);
    $e->writeMessage('optional_double_wrapper', 'optionalDoubleWrapper', $this->optional_double_wrapper, false);
    $e->writeMessage('optional_string_wrapper', 'optionalStringWrapper', $this->optional_string_wrapper, false);
    $e->writeMessage('optional_bytes_wrapper', 'optionalBytesWrapper', $this->optional_bytes_wrapper, false);
    $e->writeMessageList('repeated_bool_wrapper', 'repeatedBoolWrapper', $this->repeated_bool_wrapper);
    $e->writeMessageList('repeated_int32_wrapper', 'repeatedInt32Wrapper', $this->repeated_int32_wrapper);
    $e->writeMessageList('repeated_int64_wrapper', 'repeatedInt64Wrapper', $this->repeated_int64_wrapper);
    $e->writeMessageList('repeated_uint32_wrapper', 'repeatedUint32Wrapper', $this->repeated_uint32_wrapper);
    $e->writeMessageList('repeated_uint64_wrapper', 'repeatedUint64Wrapper', $this->repeated_uint64_wrapper);
    $e->writeMessageList('repeated_float_wrapper', 'repeatedFloatWrapper', $this->repeated_float_wrapper);
    $e->writeMessageList('repeated_double_wrapper', 'repeatedDoubleWrapper', $this->repeated_double_wrapper);
    $e->writeMessageList('repeated_string_wrapper', 'repeatedStringWrapper', $this->repeated_string_wrapper);
    $e->writeMessageList('repeated_bytes_wrapper', 'repeatedBytesWrapper', $this->repeated_bytes_wrapper);
    $e->writeMessage('optional_duration', 'optionalDuration', $this->optional_duration, false);
    $e->writeMessage('optional_timestamp', 'optionalTimestamp', $this->optional_timestamp, false);
    $e->writeMessage('optional_field_mask', 'optionalFieldMask', $this->optional_field_mask, false);
    $e->writeMessage('optional_struct', 'optionalStruct', $this->optional_struct, false);
    $e->writeMessage('optional_any', 'optionalAny', $this->optional_any, false);
    $e->writeMessage('optional_value', 'optionalValue', $this->optional_value, false);
    $e->writeEnum('optional_null_value', 'optionalNullValue', \google\protobuf\NullValue::ToStringDict(), $this->optional_null_value, false);
    $e->writeMessageList('repeated_duration', 'repeatedDuration', $this->repeated_duration);
    $e->writeMessageList('repeated_timestamp', 'repeatedTimestamp', $this->repeated_timestamp);
    $e->writeMessageList('repeated_fieldmask', 'repeatedFieldmask', $this->repeated_fieldmask);
    $e->writeMessageList('repeated_any', 'repeatedAny', $this->repeated_any);
    $e->writeMessageList('repeated_value', 'repeatedValue', $this->repeated_value);
    $e->writeMessageList('repeated_list_value', 'repeatedListValue', $this->repeated_list_value);
    $e->writeMessageList('repeated_struct', 'repeatedStruct', $this->repeated_struct);
    $e->writeInt32('fieldname1', 'fieldname1', $this->fieldname1, false);
    $e->writeInt32('field_name2', 'fieldName2', $this->field_name2, false);
    $e->writeInt32('_field_name3', 'FieldName3', $this->_field_name3, false);
    $e->writeInt32('field__name4_', 'fieldName4', $this->field__name4_, false);
    $e->writeInt32('field0name5', 'field0name5', $this->field0name5, false);
    $e->writeInt32('field_0_name6', 'field0Name6', $this->field_0_name6, false);
    $e->writeInt32('fieldName7', 'fieldName7', $this->fieldName7, false);
    $e->writeInt32('FieldName8', 'FieldName8', $this->FieldName8, false);
    $e->writeInt32('field_Name9', 'fieldName9', $this->field_Name9, false);
    $e->writeInt32('Field_Name10', 'FieldName10', $this->Field_Name10, false);
    $e->writeInt32('FIELD_NAME11', 'FIELDNAME11', $this->FIELD_NAME11, false);
    $e->writeInt32('FIELD_name12', 'FIELDName12', $this->FIELD_name12, false);
    $e->writeInt32('__field_name13', 'FieldName13', $this->__field_name13, false);
    $e->writeInt32('__Field_name14', 'FieldName14', $this->__Field_name14, false);
    $e->writeInt32('field__name15', 'fieldName15', $this->field__name15, false);
    $e->writeInt32('field__Name16', 'fieldName16', $this->field__Name16, false);
    $e->writeInt32('field_name17__', 'fieldName17', $this->field_name17__, false);
    $e->writeInt32('Field_name18__', 'FieldName18', $this->Field_name18__, false);
    $this->oneof_field->WriteJsonTo($e);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'optional_int32': case 'optionalInt32':
          $this->optional_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_int64': case 'optionalInt64':
          $this->optional_int64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_uint32': case 'optionalUint32':
          $this->optional_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        case 'optional_uint64': case 'optionalUint64':
          $this->optional_uint64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'optional_sint32': case 'optionalSint32':
          $this->optional_sint32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_sint64': case 'optionalSint64':
          $this->optional_sint64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_fixed32': case 'optionalFixed32':
          $this->optional_fixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_fixed64': case 'optionalFixed64':
          $this->optional_fixed64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'optional_sfixed32': case 'optionalSfixed32':
          $this->optional_sfixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_sfixed64': case 'optionalSfixed64':
          $this->optional_sfixed64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_float': case 'optionalFloat':
          $this->optional_float = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'optional_double': case 'optionalDouble':
          $this->optional_double = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'optional_bool': case 'optionalBool':
          $this->optional_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'optional_string': case 'optionalString':
          $this->optional_string = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'optional_bytes': case 'optionalBytes':
          $this->optional_bytes = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        case 'optional_nested_message': case 'optionalNestedMessage':
          if ($v === null) break;
          if ($this->optional_nested_message == null) $this->optional_nested_message = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $this->optional_nested_message->MergeJsonFrom($v);
          break;
        case 'optional_foreign_message': case 'optionalForeignMessage':
          if ($v === null) break;
          if ($this->optional_foreign_message == null) $this->optional_foreign_message = new \protobuf_test_messages\proto3\ForeignMessage();
          $this->optional_foreign_message->MergeJsonFrom($v);
          break;
        case 'optional_nested_enum': case 'optionalNestedEnum':
          $this->optional_nested_enum = \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($v);
          break;
        case 'optional_foreign_enum': case 'optionalForeignEnum':
          $this->optional_foreign_enum = \protobuf_test_messages\proto3\ForeignEnum::FromMixed($v);
          break;
        case 'optional_aliased_enum': case 'optionalAliasedEnum':
          $this->optional_aliased_enum = \protobuf_test_messages\proto3\TestAllTypesProto3_AliasedEnum::FromMixed($v);
          break;
        case 'optional_string_piece': case 'optionalStringPiece':
          $this->optional_string_piece = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'optional_cord': case 'optionalCord':
          $this->optional_cord = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'recursive_message': case 'recursiveMessage':
          if ($v === null) break;
          if ($this->recursive_message == null) $this->recursive_message = new \protobuf_test_messages\proto3\TestAllTypesProto3();
          $this->recursive_message->MergeJsonFrom($v);
          break;
        case 'repeated_int32': case 'repeatedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_int64': case 'repeatedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_uint32': case 'repeatedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'repeated_uint64': case 'repeatedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'repeated_sint32': case 'repeatedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_sint64': case 'repeatedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_fixed32': case 'repeatedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_fixed64': case 'repeatedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'repeated_sfixed32': case 'repeatedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_sfixed64': case 'repeatedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_float': case 'repeatedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'repeated_double': case 'repeatedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'repeated_bool': case 'repeatedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'repeated_string': case 'repeatedString':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_string []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'repeated_bytes': case 'repeatedBytes':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_bytes []= \Protobuf\Internal\JsonDecoder::readBytes($vv);
          }
          break;
        case 'repeated_nested_message': case 'repeatedNestedMessage':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
            $obj->MergeJsonFrom($vv);
            $this->repeated_nested_message []= $obj;
          }
          break;
        case 'repeated_foreign_message': case 'repeatedForeignMessage':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \protobuf_test_messages\proto3\ForeignMessage();
            $obj->MergeJsonFrom($vv);
            $this->repeated_foreign_message []= $obj;
          }
          break;
        case 'repeated_nested_enum': case 'repeatedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($vv);
          }
          break;
        case 'repeated_foreign_enum': case 'repeatedForeignEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_foreign_enum []= \protobuf_test_messages\proto3\ForeignEnum::FromMixed($vv);
          }
          break;
        case 'repeated_string_piece': case 'repeatedStringPiece':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_string_piece []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'repeated_cord': case 'repeatedCord':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_cord []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'map_int32_int32': case 'mapInt32Int32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_int32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_int64_int64': case 'mapInt64Int64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int64_int64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_uint32_uint32': case 'mapUint32Uint32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_uint32_uint32[\Protobuf\Internal\JsonDecoder::readInt32Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
            }
          }
          break;
        case 'map_uint64_uint64': case 'mapUint64Uint64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_uint64_uint64[\Protobuf\Internal\JsonDecoder::readInt64Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
            }
          }
          break;
        case 'map_sint32_sint32': case 'mapSint32Sint32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sint32_sint32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_sint64_sint64': case 'mapSint64Sint64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sint64_sint64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_fixed32_fixed32': case 'mapFixed32Fixed32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_fixed32_fixed32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_fixed64_fixed64': case 'mapFixed64Fixed64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_fixed64_fixed64[\Protobuf\Internal\JsonDecoder::readInt64Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
            }
          }
          break;
        case 'map_sfixed32_sfixed32': case 'mapSfixed32Sfixed32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sfixed32_sfixed32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_sfixed64_sfixed64': case 'mapSfixed64Sfixed64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sfixed64_sfixed64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_int32_float': case 'mapInt32Float':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_float[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readFloat($v);
            }
          }
          break;
        case 'map_int32_double': case 'mapInt32Double':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_double[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readFloat($v);
            }
          }
          break;
        case 'map_bool_bool': case 'mapBoolBool':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_bool_bool[\Protobuf\Internal\JsonDecoder::readBoolMapKey($k)] = \Protobuf\Internal\JsonDecoder::readBool($v);
            }
          }
          break;
        case 'map_string_string': case 'mapStringString':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_string[\Protobuf\Internal\JsonDecoder::readString($k)] = \Protobuf\Internal\JsonDecoder::readString($v);
            }
          }
          break;
        case 'map_string_bytes': case 'mapStringBytes':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_bytes[\Protobuf\Internal\JsonDecoder::readString($k)] = \Protobuf\Internal\JsonDecoder::readBytes($v);
            }
          }
          break;
        case 'map_string_nested_message': case 'mapStringNestedMessage':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
              $obj->MergeJsonFrom($v);
              $this->map_string_nested_message[\Protobuf\Internal\JsonDecoder::readString($k)] = $obj;
            }
          }
          break;
        case 'map_string_foreign_message': case 'mapStringForeignMessage':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $obj = new \protobuf_test_messages\proto3\ForeignMessage();
              $obj->MergeJsonFrom($v);
              $this->map_string_foreign_message[\Protobuf\Internal\JsonDecoder::readString($k)] = $obj;
            }
          }
          break;
        case 'map_string_nested_enum': case 'mapStringNestedEnum':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_nested_enum[\Protobuf\Internal\JsonDecoder::readString($k)] = \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($v);
            }
          }
          break;
        case 'map_string_foreign_enum': case 'mapStringForeignEnum':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_foreign_enum[\Protobuf\Internal\JsonDecoder::readString($k)] = \protobuf_test_messages\proto3\ForeignEnum::FromMixed($v);
            }
          }
          break;
        case 'packed_int32': case 'packedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_int64': case 'packedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_uint32': case 'packedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'packed_uint64': case 'packedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'packed_sint32': case 'packedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_sint64': case 'packedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_fixed32': case 'packedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_fixed64': case 'packedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'packed_sfixed32': case 'packedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_sfixed64': case 'packedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_float': case 'packedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'packed_double': case 'packedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'packed_bool': case 'packedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'packed_nested_enum': case 'packedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($vv);
          }
          break;
        case 'unpacked_int32': case 'unpackedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_int64': case 'unpackedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_uint32': case 'unpackedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'unpacked_uint64': case 'unpackedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'unpacked_sint32': case 'unpackedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_sint64': case 'unpackedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_fixed32': case 'unpackedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_fixed64': case 'unpackedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'unpacked_sfixed32': case 'unpackedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_sfixed64': case 'unpackedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_float': case 'unpackedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'unpacked_double': case 'unpackedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'unpacked_bool': case 'unpackedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'unpacked_nested_enum': case 'unpackedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_nested_enum []= \protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($vv);
          }
          break;
        case 'oneof_uint32': case 'oneofUint32':
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_uint32(\Protobuf\Internal\JsonDecoder::readInt32Unsigned($v));
          break;
        case 'oneof_nested_message': case 'oneofNestedMessage':
          $obj = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
          $obj->MergeJsonFrom($v);
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_nested_message($obj);
          break;
        case 'oneof_string': case 'oneofString':
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_string(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'oneof_bytes': case 'oneofBytes':
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_bytes(\Protobuf\Internal\JsonDecoder::readBytes($v));
          break;
        case 'oneof_bool': case 'oneofBool':
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_bool(\Protobuf\Internal\JsonDecoder::readBool($v));
          break;
        case 'oneof_uint64': case 'oneofUint64':
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_uint64(\Protobuf\Internal\JsonDecoder::readInt64Unsigned($v));
          break;
        case 'oneof_float': case 'oneofFloat':
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_float(\Protobuf\Internal\JsonDecoder::readFloat($v));
          break;
        case 'oneof_double': case 'oneofDouble':
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_double(\Protobuf\Internal\JsonDecoder::readFloat($v));
          break;
        case 'oneof_enum': case 'oneofEnum':
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_enum(\protobuf_test_messages\proto3\TestAllTypesProto3_NestedEnum::FromMixed($v));
          break;
        case 'oneof_null_value': case 'oneofNullValue':
          $this->oneof_field = new TestAllTypesProto3_oneof_field_oneof_null_value(\google\protobuf\NullValue::FromMixed($v));
          break;
        case 'optional_bool_wrapper': case 'optionalBoolWrapper':
          if ($v === null) break;
          if ($this->optional_bool_wrapper == null) $this->optional_bool_wrapper = new \google\protobuf\BoolValue();
          $this->optional_bool_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_int32_wrapper': case 'optionalInt32Wrapper':
          if ($v === null) break;
          if ($this->optional_int32_wrapper == null) $this->optional_int32_wrapper = new \google\protobuf\Int32Value();
          $this->optional_int32_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_int64_wrapper': case 'optionalInt64Wrapper':
          if ($v === null) break;
          if ($this->optional_int64_wrapper == null) $this->optional_int64_wrapper = new \google\protobuf\Int64Value();
          $this->optional_int64_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_uint32_wrapper': case 'optionalUint32Wrapper':
          if ($v === null) break;
          if ($this->optional_uint32_wrapper == null) $this->optional_uint32_wrapper = new \google\protobuf\UInt32Value();
          $this->optional_uint32_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_uint64_wrapper': case 'optionalUint64Wrapper':
          if ($v === null) break;
          if ($this->optional_uint64_wrapper == null) $this->optional_uint64_wrapper = new \google\protobuf\UInt64Value();
          $this->optional_uint64_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_float_wrapper': case 'optionalFloatWrapper':
          if ($v === null) break;
          if ($this->optional_float_wrapper == null) $this->optional_float_wrapper = new \google\protobuf\FloatValue();
          $this->optional_float_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_double_wrapper': case 'optionalDoubleWrapper':
          if ($v === null) break;
          if ($this->optional_double_wrapper == null) $this->optional_double_wrapper = new \google\protobuf\DoubleValue();
          $this->optional_double_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_string_wrapper': case 'optionalStringWrapper':
          if ($v === null) break;
          if ($this->optional_string_wrapper == null) $this->optional_string_wrapper = new \google\protobuf\StringValue();
          $this->optional_string_wrapper->MergeJsonFrom($v);
          break;
        case 'optional_bytes_wrapper': case 'optionalBytesWrapper':
          if ($v === null) break;
          if ($this->optional_bytes_wrapper == null) $this->optional_bytes_wrapper = new \google\protobuf\BytesValue();
          $this->optional_bytes_wrapper->MergeJsonFrom($v);
          break;
        case 'repeated_bool_wrapper': case 'repeatedBoolWrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\BoolValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_bool_wrapper []= $obj;
          }
          break;
        case 'repeated_int32_wrapper': case 'repeatedInt32Wrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Int32Value();
            $obj->MergeJsonFrom($vv);
            $this->repeated_int32_wrapper []= $obj;
          }
          break;
        case 'repeated_int64_wrapper': case 'repeatedInt64Wrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Int64Value();
            $obj->MergeJsonFrom($vv);
            $this->repeated_int64_wrapper []= $obj;
          }
          break;
        case 'repeated_uint32_wrapper': case 'repeatedUint32Wrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UInt32Value();
            $obj->MergeJsonFrom($vv);
            $this->repeated_uint32_wrapper []= $obj;
          }
          break;
        case 'repeated_uint64_wrapper': case 'repeatedUint64Wrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UInt64Value();
            $obj->MergeJsonFrom($vv);
            $this->repeated_uint64_wrapper []= $obj;
          }
          break;
        case 'repeated_float_wrapper': case 'repeatedFloatWrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FloatValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_float_wrapper []= $obj;
          }
          break;
        case 'repeated_double_wrapper': case 'repeatedDoubleWrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DoubleValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_double_wrapper []= $obj;
          }
          break;
        case 'repeated_string_wrapper': case 'repeatedStringWrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\StringValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_string_wrapper []= $obj;
          }
          break;
        case 'repeated_bytes_wrapper': case 'repeatedBytesWrapper':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\BytesValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_bytes_wrapper []= $obj;
          }
          break;
        case 'optional_duration': case 'optionalDuration':
          if ($v === null) break;
          if ($this->optional_duration == null) $this->optional_duration = new \google\protobuf\Duration();
          $this->optional_duration->MergeJsonFrom($v);
          break;
        case 'optional_timestamp': case 'optionalTimestamp':
          if ($v === null) break;
          if ($this->optional_timestamp == null) $this->optional_timestamp = new \google\protobuf\Timestamp();
          $this->optional_timestamp->MergeJsonFrom($v);
          break;
        case 'optional_field_mask': case 'optionalFieldMask':
          if ($v === null) break;
          if ($this->optional_field_mask == null) $this->optional_field_mask = new \google\protobuf\FieldMask();
          $this->optional_field_mask->MergeJsonFrom($v);
          break;
        case 'optional_struct': case 'optionalStruct':
          if ($v === null) break;
          if ($this->optional_struct == null) $this->optional_struct = new \google\protobuf\Struct();
          $this->optional_struct->MergeJsonFrom($v);
          break;
        case 'optional_any': case 'optionalAny':
          if ($v === null) break;
          if ($this->optional_any == null) $this->optional_any = new \google\protobuf\Any();
          $this->optional_any->MergeJsonFrom($v);
          break;
        case 'optional_value': case 'optionalValue':
          if ($this->optional_value == null) $this->optional_value = new \google\protobuf\Value();
          $this->optional_value->MergeJsonFrom($v);
          break;
        case 'optional_null_value': case 'optionalNullValue':
          $this->optional_null_value = \google\protobuf\NullValue::FromMixed($v);
          break;
        case 'repeated_duration': case 'repeatedDuration':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Duration();
            $obj->MergeJsonFrom($vv);
            $this->repeated_duration []= $obj;
          }
          break;
        case 'repeated_timestamp': case 'repeatedTimestamp':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Timestamp();
            $obj->MergeJsonFrom($vv);
            $this->repeated_timestamp []= $obj;
          }
          break;
        case 'repeated_fieldmask': case 'repeatedFieldmask':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldMask();
            $obj->MergeJsonFrom($vv);
            $this->repeated_fieldmask []= $obj;
          }
          break;
        case 'repeated_any': case 'repeatedAny':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Any();
            $obj->MergeJsonFrom($vv);
            $this->repeated_any []= $obj;
          }
          break;
        case 'repeated_value': case 'repeatedValue':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Value();
            $obj->MergeJsonFrom($vv);
            $this->repeated_value []= $obj;
          }
          break;
        case 'repeated_list_value': case 'repeatedListValue':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\ListValue();
            $obj->MergeJsonFrom($vv);
            $this->repeated_list_value []= $obj;
          }
          break;
        case 'repeated_struct': case 'repeatedStruct':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Struct();
            $obj->MergeJsonFrom($vv);
            $this->repeated_struct []= $obj;
          }
          break;
        case 'fieldname1':
          $this->fieldname1 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_name2': case 'fieldName2':
          $this->field_name2 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '_field_name3': case 'FieldName3':
          $this->_field_name3 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__name4_': case 'fieldName4':
          $this->field__name4_ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field0name5':
          $this->field0name5 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_0_name6': case 'field0Name6':
          $this->field_0_name6 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'fieldName7':
          $this->fieldName7 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FieldName8':
          $this->FieldName8 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_Name9': case 'fieldName9':
          $this->field_Name9 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'Field_Name10': case 'FieldName10':
          $this->Field_Name10 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FIELD_NAME11': case 'FIELDNAME11':
          $this->FIELD_NAME11 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FIELD_name12': case 'FIELDName12':
          $this->FIELD_name12 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '__field_name13': case 'FieldName13':
          $this->__field_name13 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '__Field_name14': case 'FieldName14':
          $this->__Field_name14 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__name15': case 'fieldName15':
          $this->field__name15 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__Name16': case 'fieldName16':
          $this->field__Name16 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_name17__': case 'fieldName17':
          $this->field_name17__ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'Field_name18__': case 'FieldName18':
          $this->Field_name18__ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto3)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->optional_int32 = $o->optional_int32;
    $this->optional_int64 = $o->optional_int64;
    $this->optional_uint32 = $o->optional_uint32;
    $this->optional_uint64 = $o->optional_uint64;
    $this->optional_sint32 = $o->optional_sint32;
    $this->optional_sint64 = $o->optional_sint64;
    $this->optional_fixed32 = $o->optional_fixed32;
    $this->optional_fixed64 = $o->optional_fixed64;
    $this->optional_sfixed32 = $o->optional_sfixed32;
    $this->optional_sfixed64 = $o->optional_sfixed64;
    $this->optional_float = $o->optional_float;
    $this->optional_double = $o->optional_double;
    $this->optional_bool = $o->optional_bool;
    $this->optional_string = $o->optional_string;
    $this->optional_bytes = $o->optional_bytes;
    $tmp = $o->optional_nested_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->optional_nested_message = $nv;
    }
    $tmp = $o->optional_foreign_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\ForeignMessage();
      $nv->CopyFrom($tmp);
      $this->optional_foreign_message = $nv;
    }
    $this->optional_nested_enum = $o->optional_nested_enum;
    $this->optional_foreign_enum = $o->optional_foreign_enum;
    $this->optional_aliased_enum = $o->optional_aliased_enum;
    $this->optional_string_piece = $o->optional_string_piece;
    $this->optional_cord = $o->optional_cord;
    $tmp = $o->recursive_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3();
      $nv->CopyFrom($tmp);
      $this->recursive_message = $nv;
    }
    $this->repeated_int32 = $o->repeated_int32;
    $this->repeated_int64 = $o->repeated_int64;
    $this->repeated_uint32 = $o->repeated_uint32;
    $this->repeated_uint64 = $o->repeated_uint64;
    $this->repeated_sint32 = $o->repeated_sint32;
    $this->repeated_sint64 = $o->repeated_sint64;
    $this->repeated_fixed32 = $o->repeated_fixed32;
    $this->repeated_fixed64 = $o->repeated_fixed64;
    $this->repeated_sfixed32 = $o->repeated_sfixed32;
    $this->repeated_sfixed64 = $o->repeated_sfixed64;
    $this->repeated_float = $o->repeated_float;
    $this->repeated_double = $o->repeated_double;
    $this->repeated_bool = $o->repeated_bool;
    $this->repeated_string = $o->repeated_string;
    $this->repeated_bytes = $o->repeated_bytes;
    foreach ($o->repeated_nested_message as $v) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
      $nv->CopyFrom($v);
      $this->repeated_nested_message []= $nv;
    }
    foreach ($o->repeated_foreign_message as $v) {
      $nv = new \protobuf_test_messages\proto3\ForeignMessage();
      $nv->CopyFrom($v);
      $this->repeated_foreign_message []= $nv;
    }
    $this->repeated_nested_enum = $o->repeated_nested_enum;
    $this->repeated_foreign_enum = $o->repeated_foreign_enum;
    $this->repeated_string_piece = $o->repeated_string_piece;
    $this->repeated_cord = $o->repeated_cord;
    $this->map_int32_int32 = $o->map_int32_int32;
    $this->map_int64_int64 = $o->map_int64_int64;
    $this->map_uint32_uint32 = $o->map_uint32_uint32;
    $this->map_uint64_uint64 = $o->map_uint64_uint64;
    $this->map_sint32_sint32 = $o->map_sint32_sint32;
    $this->map_sint64_sint64 = $o->map_sint64_sint64;
    $this->map_fixed32_fixed32 = $o->map_fixed32_fixed32;
    $this->map_fixed64_fixed64 = $o->map_fixed64_fixed64;
    $this->map_sfixed32_sfixed32 = $o->map_sfixed32_sfixed32;
    $this->map_sfixed64_sfixed64 = $o->map_sfixed64_sfixed64;
    $this->map_int32_float = $o->map_int32_float;
    $this->map_int32_double = $o->map_int32_double;
    $this->map_bool_bool = $o->map_bool_bool;
    $this->map_string_string = $o->map_string_string;
    $this->map_string_bytes = $o->map_string_bytes;
    foreach ($o->map_string_nested_message as $k => $v) {
      $nv = new \protobuf_test_messages\proto3\TestAllTypesProto3_NestedMessage();
      $nv->CopyFrom($v);
      $this->map_string_nested_message[$k] = $nv;
    }
    foreach ($o->map_string_foreign_message as $k => $v) {
      $nv = new \protobuf_test_messages\proto3\ForeignMessage();
      $nv->CopyFrom($v);
      $this->map_string_foreign_message[$k] = $nv;
    }
    $this->map_string_nested_enum = $o->map_string_nested_enum;
    $this->map_string_foreign_enum = $o->map_string_foreign_enum;
    $this->packed_int32 = $o->packed_int32;
    $this->packed_int64 = $o->packed_int64;
    $this->packed_uint32 = $o->packed_uint32;
    $this->packed_uint64 = $o->packed_uint64;
    $this->packed_sint32 = $o->packed_sint32;
    $this->packed_sint64 = $o->packed_sint64;
    $this->packed_fixed32 = $o->packed_fixed32;
    $this->packed_fixed64 = $o->packed_fixed64;
    $this->packed_sfixed32 = $o->packed_sfixed32;
    $this->packed_sfixed64 = $o->packed_sfixed64;
    $this->packed_float = $o->packed_float;
    $this->packed_double = $o->packed_double;
    $this->packed_bool = $o->packed_bool;
    $this->packed_nested_enum = $o->packed_nested_enum;
    $this->unpacked_int32 = $o->unpacked_int32;
    $this->unpacked_int64 = $o->unpacked_int64;
    $this->unpacked_uint32 = $o->unpacked_uint32;
    $this->unpacked_uint64 = $o->unpacked_uint64;
    $this->unpacked_sint32 = $o->unpacked_sint32;
    $this->unpacked_sint64 = $o->unpacked_sint64;
    $this->unpacked_fixed32 = $o->unpacked_fixed32;
    $this->unpacked_fixed64 = $o->unpacked_fixed64;
    $this->unpacked_sfixed32 = $o->unpacked_sfixed32;
    $this->unpacked_sfixed64 = $o->unpacked_sfixed64;
    $this->unpacked_float = $o->unpacked_float;
    $this->unpacked_double = $o->unpacked_double;
    $this->unpacked_bool = $o->unpacked_bool;
    $this->unpacked_nested_enum = $o->unpacked_nested_enum;
    $tmp = $o->optional_bool_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\BoolValue();
      $nv->CopyFrom($tmp);
      $this->optional_bool_wrapper = $nv;
    }
    $tmp = $o->optional_int32_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Int32Value();
      $nv->CopyFrom($tmp);
      $this->optional_int32_wrapper = $nv;
    }
    $tmp = $o->optional_int64_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Int64Value();
      $nv->CopyFrom($tmp);
      $this->optional_int64_wrapper = $nv;
    }
    $tmp = $o->optional_uint32_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\UInt32Value();
      $nv->CopyFrom($tmp);
      $this->optional_uint32_wrapper = $nv;
    }
    $tmp = $o->optional_uint64_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\UInt64Value();
      $nv->CopyFrom($tmp);
      $this->optional_uint64_wrapper = $nv;
    }
    $tmp = $o->optional_float_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\FloatValue();
      $nv->CopyFrom($tmp);
      $this->optional_float_wrapper = $nv;
    }
    $tmp = $o->optional_double_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\DoubleValue();
      $nv->CopyFrom($tmp);
      $this->optional_double_wrapper = $nv;
    }
    $tmp = $o->optional_string_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\StringValue();
      $nv->CopyFrom($tmp);
      $this->optional_string_wrapper = $nv;
    }
    $tmp = $o->optional_bytes_wrapper;
    if ($tmp !== null) {
      $nv = new \google\protobuf\BytesValue();
      $nv->CopyFrom($tmp);
      $this->optional_bytes_wrapper = $nv;
    }
    foreach ($o->repeated_bool_wrapper as $v) {
      $nv = new \google\protobuf\BoolValue();
      $nv->CopyFrom($v);
      $this->repeated_bool_wrapper []= $nv;
    }
    foreach ($o->repeated_int32_wrapper as $v) {
      $nv = new \google\protobuf\Int32Value();
      $nv->CopyFrom($v);
      $this->repeated_int32_wrapper []= $nv;
    }
    foreach ($o->repeated_int64_wrapper as $v) {
      $nv = new \google\protobuf\Int64Value();
      $nv->CopyFrom($v);
      $this->repeated_int64_wrapper []= $nv;
    }
    foreach ($o->repeated_uint32_wrapper as $v) {
      $nv = new \google\protobuf\UInt32Value();
      $nv->CopyFrom($v);
      $this->repeated_uint32_wrapper []= $nv;
    }
    foreach ($o->repeated_uint64_wrapper as $v) {
      $nv = new \google\protobuf\UInt64Value();
      $nv->CopyFrom($v);
      $this->repeated_uint64_wrapper []= $nv;
    }
    foreach ($o->repeated_float_wrapper as $v) {
      $nv = new \google\protobuf\FloatValue();
      $nv->CopyFrom($v);
      $this->repeated_float_wrapper []= $nv;
    }
    foreach ($o->repeated_double_wrapper as $v) {
      $nv = new \google\protobuf\DoubleValue();
      $nv->CopyFrom($v);
      $this->repeated_double_wrapper []= $nv;
    }
    foreach ($o->repeated_string_wrapper as $v) {
      $nv = new \google\protobuf\StringValue();
      $nv->CopyFrom($v);
      $this->repeated_string_wrapper []= $nv;
    }
    foreach ($o->repeated_bytes_wrapper as $v) {
      $nv = new \google\protobuf\BytesValue();
      $nv->CopyFrom($v);
      $this->repeated_bytes_wrapper []= $nv;
    }
    $tmp = $o->optional_duration;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Duration();
      $nv->CopyFrom($tmp);
      $this->optional_duration = $nv;
    }
    $tmp = $o->optional_timestamp;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Timestamp();
      $nv->CopyFrom($tmp);
      $this->optional_timestamp = $nv;
    }
    $tmp = $o->optional_field_mask;
    if ($tmp !== null) {
      $nv = new \google\protobuf\FieldMask();
      $nv->CopyFrom($tmp);
      $this->optional_field_mask = $nv;
    }
    $tmp = $o->optional_struct;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Struct();
      $nv->CopyFrom($tmp);
      $this->optional_struct = $nv;
    }
    $tmp = $o->optional_any;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Any();
      $nv->CopyFrom($tmp);
      $this->optional_any = $nv;
    }
    $tmp = $o->optional_value;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Value();
      $nv->CopyFrom($tmp);
      $this->optional_value = $nv;
    }
    $this->optional_null_value = $o->optional_null_value;
    foreach ($o->repeated_duration as $v) {
      $nv = new \google\protobuf\Duration();
      $nv->CopyFrom($v);
      $this->repeated_duration []= $nv;
    }
    foreach ($o->repeated_timestamp as $v) {
      $nv = new \google\protobuf\Timestamp();
      $nv->CopyFrom($v);
      $this->repeated_timestamp []= $nv;
    }
    foreach ($o->repeated_fieldmask as $v) {
      $nv = new \google\protobuf\FieldMask();
      $nv->CopyFrom($v);
      $this->repeated_fieldmask []= $nv;
    }
    foreach ($o->repeated_any as $v) {
      $nv = new \google\protobuf\Any();
      $nv->CopyFrom($v);
      $this->repeated_any []= $nv;
    }
    foreach ($o->repeated_value as $v) {
      $nv = new \google\protobuf\Value();
      $nv->CopyFrom($v);
      $this->repeated_value []= $nv;
    }
    foreach ($o->repeated_list_value as $v) {
      $nv = new \google\protobuf\ListValue();
      $nv->CopyFrom($v);
      $this->repeated_list_value []= $nv;
    }
    foreach ($o->repeated_struct as $v) {
      $nv = new \google\protobuf\Struct();
      $nv->CopyFrom($v);
      $this->repeated_struct []= $nv;
    }
    $this->fieldname1 = $o->fieldname1;
    $this->field_name2 = $o->field_name2;
    $this->_field_name3 = $o->_field_name3;
    $this->field__name4_ = $o->field__name4_;
    $this->field0name5 = $o->field0name5;
    $this->field_0_name6 = $o->field_0_name6;
    $this->fieldName7 = $o->fieldName7;
    $this->FieldName8 = $o->FieldName8;
    $this->field_Name9 = $o->field_Name9;
    $this->Field_Name10 = $o->Field_Name10;
    $this->FIELD_NAME11 = $o->FIELD_NAME11;
    $this->FIELD_name12 = $o->FIELD_name12;
    $this->__field_name13 = $o->__field_name13;
    $this->__Field_name14 = $o->__Field_name14;
    $this->field__name15 = $o->field__name15;
    $this->field__Name16 = $o->field__Name16;
    $this->field_name17__ = $o->field_name17__;
    $this->Field_name18__ = $o->Field_name18__;
    $this->oneof_field = $o->oneof_field->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ForeignMessage implements \Protobuf\Message {
  public int $c;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'c' => int,
  ) $s = shape()) {
    $this->c = $s['c'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.ForeignMessage";
  }

  public static function ParseFrom(string $input): ?ForeignMessage {
    $msg = new ForeignMessage();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->c = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->c !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->c);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('c', 'c', $this->c, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'c':
          $this->c = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ForeignMessage)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->c = $o->c;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class NullHypothesisProto3 implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.NullHypothesisProto3";
  }

  public static function ParseFrom(string $input): ?NullHypothesisProto3 {
    $msg = new NullHypothesisProto3();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is NullHypothesisProto3)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype EnumOnlyProto3_Bool_enum_t as int = int;
abstract class EnumOnlyProto3_Bool {
  const EnumOnlyProto3_Bool_enum_t kFalse = 0;
  const EnumOnlyProto3_Bool_enum_t kTrue = 1;
  private static dict<int, string> $itos = dict[
    0 => 'kFalse',
    1 => 'kTrue',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'kFalse' => 0,
    'kTrue' => 1,
  ];
  public static function FromMixed(mixed $m): EnumOnlyProto3_Bool_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): EnumOnlyProto3_Bool_enum_t {
    return $i;
  }
}

class EnumOnlyProto3 implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto3.EnumOnlyProto3";
  }

  public static function ParseFrom(string $input): ?EnumOnlyProto3 {
    $msg = new EnumOnlyProto3();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumOnlyProto3)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_test_messages_proto3__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/test_messages_proto3.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 12195 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\xac\x5a\xc9\x73\x1b\xc7\xb9\x47\x63\x24\x8a\x6c\x2\x24\xd8\xa2\xa8\x16\xbd\x8d\x29\xeb\x69\x2c\x3f\x4b\xa2\x38\x1e\x51\x7e\x5e\x44\x5a\x84\x28\x59\x22\xed\xa1\xe4\xf5\xd9\x8\x8\xe\x15\x94\xb0\x19\x8b\x2d\xe6\x90\x54\xa5\x72\x48\x25\xa7\xec\x71\xf6\xf8\x9e\xfd\x90\xa4\x92\xdc\x72\xc9\x9e\x54\xf6\xe4\xef\x48\x55\x6e\x4e\xf5\x3a\x5f\xf7\xcc\x50\x21\x21\x55\x89\x0\xbe\xf9\xf5\xef\x5b\xfa\xeb\xdf\x0\xdd\x83\x4f\xdd\x6a\xb7\x6f\x35\xa2\x33\x9d\x6e\xbb\xdf\xde\x1c\x6c\x9f\xe9\x47\xbd\x7e\xa5\x19\xf5\x7a\xd5\x5b\x51\xaf\xc2\xcd\xb\xa7\xf9\xb\x79\x40\x81\x2a\x6\x48\x5c\x5d\x98\x3d\x66\x53\x55\x5b\x3b\xe2\xda\xec\x83\xf6\xa5\xad\x41\xb7\xda\xaf\xb7\x5b\xf2\xba\x6b\x5f\xdf\xae\x47\x8d\xad\x4a\xb3\xda\xbb\x2d\x11\xf7\xdb\x88\x5e\xbf\x3b\xa8\xf5\xe5\xd5\x87\x12\x59\xd4\x9b\x51\xaf\x5f\x6d\x76\xb2\x2\x78\xa7\x5b\xed\x74\xa2\xae\xc\x7e\xee\xdd\xd7\x31\xb9\x11\xf5\xfa\x4b\x8d\xc6\x8d\x9d\x4e\xd4\x7b\x81\xa7\x44\x4e\xe0\x89\x76\x87\xc5\x59\x6d\x54\xea\xad\xfe\xc2\x39\x8a\x5c\xe4\x1d\xc\x8b\xca\x7a\x85\x19\x6d\x58\xe0\xd3\xbc\x8b\x3c\xc7\x80\x5\x3e\x39\x89\x27\x35\x6c\x20\xe8\x1c\x17\x79\xc5\x50\x8f\xbe\xc9\xad\x9\x60\xe0\xd3\x3\x2e\xf2\xe\x98\x40\x8b\xb1\x27\x18\xf\xba\xc8\x9b\x8a\x81\x1b\x49\xc6\x9e\x60\x1c\x71\x91\x47\x4c\x60\xe0\x93\x47\x71\x49\x3\xb7\xeb\x77\xa2\xad\x85\x73\xf4\x90\x8b\xbc\x43\xa1\x26\x28\xb\x73\x12\x1a\xf8\x74\xd4\x45\xde\x88\x5\xd\x7c\xf2\x18\x9e\x8a\xdd\x2b\xda\x31\x17\x79\x93\xa1\xe6\xd8\x90\xf6\x14\x70\xe0\x53\xec\x22\xaf\x64\x83\x3\xdf\x28\xfd\x76\xa3\x5d\xed\xd3\x71\x17\x79\xf9\xb8\xf4\x65\x66\x34\xf2\xdf\x6a\xf\x36\x1b\x11\x2d\xb8\xc8\x43\x71\xfe\x97\xb8\x95\x1c\xc7\x7a\x64\x65\xb3\xdd\x6e\xd0\xa2\x8b\xbc\xd1\xb0\xa0\x8c\xcb\xed\x76\xc3\xac\x66\xbf\x5b\x6f\xdd\xa2\x13\x2e\xf2\xc6\x40\x35\xb9\xd5\x88\x6e\x73\xa7\x1f\xf5\xe8\xa4\x8b\xbc\x42\x1c\xdd\x32\x33\x92\x77\xf0\x51\xd\x6b\x45\xbd\x7e\xb4\xa5\x16\x17\x25\x2e\xf2\xc6\xcf\x3d\x7b\x7a\xd7\xa5\x77\x3a\xd9\xba\xa7\xd7\x38\xcf\x75\x1\xc\x8f\x28\x7e\xc3\x4c\x6e\x61\x1a\x57\xaf\xdd\x8d\xea\xb7\x5a\xda\xf3\x61\xee\xf9\xf1\xbb\x78\x2e\x8b\x51\xca\xcf\x8c\x2e\xbb\x61\x27\x2d\x3c\x6d\x67\x18\xb5\x6\x4d\x7a\xc4\x45\xde\xc4\xb9\xa7\xf6\x9b\xde\x4a\x6b\xd0\xc\x89\x99\x1b\xb3\x91\x37\xf1\x91\x44\x62\xdc\xe1\xc\x77\x78\xea\xbf\xcb\x8a\xd3\x1f\xb6\x52\xe2\xfc\x6f\x1\xfe\x6a\xa3\x5e\xed\xa9\x84\x8e\x72\xfe\xa7\xf7\x9e\xd0\x92\x60\x31\x5d\x2\x23\x9\x80\x4b\xd1\x74\x95\x4e\x3d\xaa\x45\x94\xb2\xd6\x5b\xce\x8f\xe6\xe3\x71\xa2\xfd\x5e\x60\x97\xc9\x49\xd0\xd1\xb5\x76\x77\x8b\x1e\x93\x78\x14\x77\xf5\x73\xed\xee\x16\x79\x13\x4f\x75\xa3\xda\xa0\xdb\xab\xbf\x1d\xe9\x2e\xb8\x8f\x77\xc1\xfc\x9e\xf3\x9\x4b\x9a\x4b\xf5\xc0\x9\x3c\xd1\x8d\x3a\x51\x95\x4d\xbe\xd0\xaa\x87\x5c\x87\x89\xa9\xb2\x6a\x31\x85\xb0\xc0\xa7\xae\xeb\x30\x31\x5\x30\x21\x7d\x1a\x26\xc5\xf4\x61\xd7\x61\x62\xaa\xcc\xb1\x98\x1a\xc0\xc0\xa7\x73\xae\xc3\xc4\x14\x2\x2d\x46\x29\xa6\xc7\x5d\x87\x89\xa9\x32\x6f\x24\x19\xa5\x98\x3e\xe2\x3a\x4c\x4c\x21\x50\x88\xa9\x6\x2a\xd5\x3b\xe1\x3a\x4c\x4c\x95\x1d\x88\xa9\x9\xd\x7c\xfa\x3f\xae\xc3\xc4\xd4\x80\xa\x31\x8d\xdd\x2b\xda\x93\xae\xc3\xc4\x54\x7\x0\xc4\xd4\x2\x7\x3e\xf5\x5c\x87\x89\xa9\x9\x16\x62\x1a\x7\xc1\xc5\xf4\x51\xd7\x61\x62\xaa\x43\x50\x62\xaa\x61\x52\x4c\x4f\xb9\xe\x13\x53\x65\x8e\xc5\x54\x3\xb9\x98\x3e\xe6\x3a\x4c\x4c\x95\x51\x89\x69\x1c\xa1\x10\xd3\xff\x75\x1d\x26\xa6\x3a\x3e\x2d\xa6\x31\x1b\x17\xd3\xc7\x5d\x87\x89\xa9\xa6\x53\x62\xaa\x61\x96\x98\x9e\x75\x9d\x7b\x22\xa6\x8a\x3f\x21\xa6\x71\xf5\x2c\x31\x9d\xe7\x9e\xf7\x2a\xa6\xba\xec\x9\x31\xb5\x33\xe4\xda\xb3\xe0\x3a\xc3\x8b\xa9\x99\x9b\x12\xd3\x44\x62\xdc\xa1\xcf\x1d\xee\x49\x4c\xad\x94\x94\xb2\x59\x1d\x20\x95\x2d\x60\x7d\x20\x94\xcd\xec\x5\xad\x6c\x7a\x1c\x57\xb6\xf3\x12\x8f\xe2\x16\xe3\xca\x76\x2\x17\x3a\xd5\xda\x6d\xad\x3b\xcf\x33\xdd\x59\xce\x97\x50\x38\x2e\xec\x4a\x79\x0\x2c\xf0\xe9\x35\xa6\x3b\x16\x8c\xeb\x44\x51\xc2\xa4\xee\x5c\x67\xba\xc3\x71\x72\xbc\x56\x1e\x8\xc\x7c\xba\xc6\x74\xc7\x6\x1a\x8c\x52\x77\xd6\x99\xee\x40\xe0\x86\xcd\x28\x75\xe7\x5\xa6\x3b\x36\x90\x2b\xcf\x84\x4\x2a\x81\x78\x91\xe9\xe\x47\x4a\x8a\x58\x79\xc\x68\xe0\xd3\x90\xe9\x4e\x2\xca\x95\x67\x52\xb9\x57\xb4\x1b\x4c\x77\x38\x56\xb2\x0\xe5\x31\xc1\x81\x4f\x6f\x30\xdd\x49\x82\xb9\xf2\xa8\xd2\xb\xdd\xb9\xc9\x74\x7\x96\x5e\x29\x8f\xca\x5f\xea\xce\x4b\x4c\x77\x60\xfe\x5a\x79\xe4\x38\xa1\x3b\x2f\x33\xdd\xe1\x30\x2c\xcc\x5c\x79\x5a\x98\x48\x10\x5c\x45\xaf\xc\xbf\x8a\xb8\xa7\x92\xe0\x6\xeb\xe8\x51\x3c\x31\x68\x19\x8d\xf8\xaa\x6c\xc4\x5c\x58\x54\x57\x44\x2b\x5a\xd0\xc0\xa7\xaf\xc9\x66\x34\xa1\x62\x52\x34\x54\x36\xe4\xeb\xb2\x21\x73\xa1\x66\x91\x2d\x69\x83\x3\x9f\xfe\xbf\x6c\x4a\xb\x6c\x31\xcb\xc6\x7c\x43\x36\x26\x0\x6f\x24\x99\x65\x73\xbe\x29\x9b\xd3\x2\x7\x3e\x79\x1c\x97\x34\x58\x75\x52\x45\x36\x68\x2e\xd4\x44\xaa\x45\x13\xf0\xc0\xa7\x1f\x90\x4d\x6a\xc3\x3\x9f\x9c\xc1\x53\x71\x28\x8a\xbe\x2a\x1b\x35\x17\x6a\x2e\xdd\xaa\xc9\x1\x81\x4f\x37\x65\xb3\x26\x6\x88\xe5\x15\x7\xc4\x1b\xb6\x26\x1b\x16\x4c\x8f\x68\x59\x58\x17\xd9\xb4\x5b\xb2\x69\x41\x5d\x64\xdb\x9e\xc4\x7a\xb4\x68\xdc\x48\x36\x6e\x2e\x2c\xa8\xb\xbc\x75\xbb\x78\x5a\x3\x61\xf3\x6e\xdf\x93\xe6\xcd\x85\x44\xb1\x83\xf6\x6d\xe0\xc9\x66\xb5\x23\x3a\x57\xf6\xef\x22\xbf\xad\x5d\xda\xbb\xbb\xeb\xd5\xe\x6f\x74\xfe\x67\xa5\xd5\xef\xee\x84\xc5\x26\xb4\x1\x6f\x81\x2f\x97\xc0\x85\xe1\xbc\x5\x3e\xff\x63\x78\x93\x36\xd2\xc5\x53\xcc\x9b\x58\x3f\x6a\x19\x3d\xc9\xfd\x95\xf7\xe5\x4f\xac\x37\xf1\x57\x78\x64\xe9\x40\x2b\xf4\x19\xf8\x6a\x35\xfe\xdf\x90\x3e\x3\x5f\xfc\x35\x7d\x2a\xab\xf2\x29\x56\xb3\x5a\xd4\x4f\xd\xe1\x53\xac\xfe\xd\x2b\x4f\x68\x85\x3e\x3\x5f\x69\xc3\xd3\x43\xfa\xc\xfc\xd\x2b\x4f\x68\x25\x77\xf0\x61\xe6\x53\x2e\x70\xad\x31\xcf\x70\xaf\xab\xfb\xf2\x2a\xc5\x48\xbe\x8\xbf\x2c\x31\xd3\x6e\x78\xe\x7c\x2d\x57\xcf\xe\xeb\x39\xf0\xe5\x8b\xe5\x59\xdb\xc9\x87\xf1\x11\x5e\x67\x95\xb4\x96\xbe\x8b\xdc\xf7\xd5\xfd\xd5\x5a\x92\xa8\x57\xe1\x9d\xa5\x68\x5f\x31\xfd\xb3\x99\x56\xb9\x2f\xd\xed\x3f\xf0\xd5\xab\xed\x3f\xbe\x62\xea\x93\x50\xe5\xe5\x61\xf5\x89\x6b\xb8\xa5\x4f\x42\xd7\xdb\xb8\x14\x7b\x93\xc2\xfe\x1c\x77\xb7\xb2\x7f\x77\xe2\x36\x20\xfc\x4d\x34\xd\x23\xd9\xc6\x2c\x2\x7e\x5b\x10\xf7\x86\x4b\xdc\xdb\xf2\xbe\xbc\xb1\x9b\x8\xfb\x2f\x5c\x8d\x37\x63\x8b\x5e\xae\xe2\x8b\xb8\xfc\x45\xb6\x32\xcc\x72\xe5\x14\xe2\x2f\x58\xae\xc0\xaa\x8a\x29\x7d\x8a\x1f\x77\xe5\x21\x8a\x29\x68\xf9\xef\xc1\xb8\x98\xc0\x48\x3e\x8e\xf0\x31\xe0\xd1\xfa\x9d\x78\x99\xbb\xbe\x3e\x84\x6b\xe3\x97\xa1\x8\x61\xa6\x99\x7a\x91\x7c\x12\xe1\x59\x10\x8a\xfd\xcb\x71\x95\xc7\xb2\x36\x44\x2c\xe6\xaf\x47\x11\xcc\xd1\x66\xfa\x55\xf2\x11\x3c\x93\xac\xb\xff\x6a\x71\x65\x98\x55\xc\xf2\x66\xdf\x25\xc0\x2a\xb6\xae\x90\x8f\x22\x7c\x34\xa5\x1c\x3c\x84\xab\x3c\x84\xe7\x87\xaf\x45\x1c\xc3\x74\x33\xe5\x12\x39\x8e\xb\xed\x56\xd4\xde\x56\xdf\x4\xda\x2e\xf2\x8a\xab\xb9\x70\x9c\x5b\xe5\xfd\xbb\x87\xa7\x5\xc8\xea\x9e\xce\x3d\xd9\xb2\x5d\xcd\x85\x84\xd3\x9b\xdd\xa2\x23\x93\xb\xf3\x2d\x17\x79\x63\x3a\x32\xb9\x9c\x1e\xc6\xe2\xa3\x5c\x49\x5d\x17\x79\x85\xd5\x5c\x88\xb9\x51\x2c\x80\x87\x30\x96\x10\x26\x25\x3d\x17\x79\xa3\xab\xb9\x70\x4c\x20\x98\xc\x18\x25\x8\x7c\xda\x77\x91\x77\xc0\x28\x41\xe0\xc7\x8e\x84\xdc\xe\x5c\xe4\xe5\xb5\x23\xa1\x93\x9a\x47\x6a\xe4\xdb\x2e\xf2\x90\xe6\x91\xda\xf6\x86\x8a\x86\x4f\xf3\x3b\xc3\x6f\xa\xeb\x5c\xf8\x74\x96\x71\x49\xce\xd4\xa0\xd1\xa8\xbc\x5d\x6d\xc\x22\x7a\x87\x3b\x99\x3d\x2d\xe\x86\xb4\xaf\xd3\x6b\x83\x46\xe3\x25\x86\x58\xcd\x85\x13\x62\x2\x94\x85\xac\x83\x2d\x58\xae\xc3\xf2\x14\x89\xfe\x2\xf1\x39\x4f\xb2\xb1\x52\xf2\xb1\xf1\xde\x2c\x33\xbd\x2c\xc6\x91\x10\xcf\x98\xe7\x4b\x9a\xf1\x97\x82\xf1\xbe\x4\x23\xbf\x25\x8\xca\x69\xe3\x14\x2a\x83\x33\xf0\x35\xe7\xaf\x76\xe1\xc\xfc\x24\x67\xe0\x2b\xce\x9b\xe0\x80\x62\x60\x6\xfa\x6b\x41\x7a\x7f\x82\xf4\x26\x88\xf4\x88\x79\xc0\x95\x45\xb\x62\xfd\xcd\x6e\xb4\x2a\xd8\x23\xe6\x71\x58\x5a\x5\x78\x63\x6a\xd6\xdf\x66\x55\x80\xf7\xaa\x55\x1\x6e\x4b\xb\x55\x74\xb2\x26\xfd\x5d\x56\xa8\xa2\xb9\xad\x50\x85\x31\x8d\x56\x2a\x9e\xa2\xfd\x7d\x16\xad\x58\xe4\x16\xad\x30\xa6\x55\x80\x6b\x80\x66\xfd\x43\x56\x5\xb8\x2c\x58\x15\xe0\x36\xc5\xb9\xe\x76\xe9\x8c\xe6\xff\x23\xe2\xb2\xbc\x6b\xf3\xc3\x1d\x5f\x10\xa4\x79\x1e\xa0\x19\xff\x24\x18\x77\x6f\x7e\xe3\xd4\x20\x83\x13\x34\xd4\x9f\x77\xe1\xd4\xcd\x6f\x1c\x31\x80\x39\xb2\x4e\x1a\x34\xe9\x5f\x4\xe9\x5d\x9a\xdf\x3c\x90\xc8\xa2\x5\xb1\xfe\x75\x37\x5a\xdd\xfc\xe6\xf1\x45\x5a\x5\xcc\xe6\xff\x5b\x56\x5\x60\xf3\x1b\x3b\xfd\x69\xa1\x5a\xcd\xff\xf7\xac\x50\x8d\xe6\x37\xcf\x5\xd2\x68\xad\xe6\xff\x47\x16\xad\xd1\xfc\xe6\xa6\x70\x5a\x5\xcc\xe6\xff\x67\x56\x5\x60\xf3\x1b\xa7\x9\x8a\xf3\x32\x38\x93\x56\xcf\x2e\xd0\x6f\xe5\xf9\x5a\x3a\x96\xcc\x5d\x22\xe2\xf3\x6a\x65\x21\x57\xb1\x3e\xae\xac\xe8\x87\x14\xe8\xb7\xf3\x19\xf7\x8f\x1b\xa\x12\x6a\xff\xda\x44\x9e\xc7\x87\xc1\x1\xbc\x7a\x60\x82\x7e\x27\x8b\xac\xcc\x30\xd7\xab\xbd\xdb\x31\x99\x36\x91\x25\xf3\x4c\x7b\x50\xeb\xd3\xef\xa\xa2\xa3\x69\x93\x30\xa8\xf5\x8d\xd3\xee\x41\xad\x4f\x16\x71\x21\x3e\x14\x6d\xed\xd0\xef\x89\xf1\xd3\x89\xf1\x4b\xad\x9d\x70\x5c\x9f\x71\xb6\x76\xc8\x33\xe0\x9c\x5c\xdc\x9e\xbf\x2f\xc6\xce\x24\xc6\x8a\x59\xd2\x47\x9a\xe2\xc6\xc\x2b\x1\xee\xf1\x3f\xc8\xdf\xed\x26\x1f\x57\x22\xbe\xcb\x5f\x6\x47\x66\x7a\xae\x7f\x98\xe7\xad\xb3\xdb\x5c\xeb\x26\x7\x73\xad\x89\xe2\xb9\xfe\x51\x3e\x43\x2e\xc1\x5c\xab\x61\xf1\x5c\x43\x2e\x3e\xd7\x7c\xaa\x7f\x9c\xc5\x5\xa6\x3a\x3e\x3e\x94\xa3\xd8\x54\xc3\x75\xc7\xa6\xfa\xe7\x82\x28\x7b\xaa\xc1\x52\x93\x53\xad\x29\xd8\x54\xff\x44\x8c\xcf\x98\x6a\x5\x95\x53\xad\x47\x8a\x59\xfa\xa9\x18\x9b\x39\xd5\xa\xae\xa7\x5a\x8f\x6f\xd4\x7b\x7d\x49\xf2\xb3\xac\x4a\x5c\xab\xf7\xa4\xb6\xe9\x4a\x68\x13\xfb\x16\xcc\x8b\xd9\xaa\x36\xa3\x79\xfa\x29\x87\x3f\xdc\x3\x4c\xc4\xc5\xe3\x62\x65\xb1\x8f\xe7\xe8\xa7\x21\x62\x8d\x99\xc8\xc3\xb8\x50\x89\x21\xb\xf4\x33\x12\x52\x56\x90\x5\x32\x87\x8b\x2\xc1\x21\x7e\x85\x7e\xd6\xa6\xe1\xdf\xa4\xf9\xa7\xb3\xc\xf2\x4\xfd\x9c\x40\x40\x1b\x39\xae\x68\xce\x72\x9e\x80\x7e\xde\x0\x31\x9e\x40\x67\xc4\x3e\x9d\xa7\x5f\xb0\x1d\x9d\x67\x0\x1d\xda\x22\xfd\xa2\x1d\xed\x62\x9c\x32\xfb\x78\x81\xbe\x6b\x53\x5c\x20\x73\xb8\x50\xd6\x88\xf9\xb3\xf4\x4b\x32\xe\x4d\x32\x7f\x96\x63\xae\xac\x5c\xbb\x54\x59\x5b\xba\xbe\x32\x3f\x4f\xbf\xac\x30\xcc\x28\x6c\x31\x86\xd7\xfa\x1c\xfd\x8a\x81\xe1\x36\xf2\x8\x9e\xa8\x80\xfa\xce\x2f\xd0\xaf\x26\xbc\x2d\x8\x54\x39\x46\xf9\xf4\x6b\x9\x94\x1f\x17\x50\x80\x9e\xa0\x5f\x87\x5\xe4\x20\x50\x65\x91\x5d\x40\xbf\x91\x0\x5\xcc\x1f\x88\xe9\x7c\xa5\x42\xbf\x99\x40\x9d\x67\x28\x10\xd3\x62\xa5\x42\xdf\x4b\x44\xb5\x38\xdb\xc5\x45\xf3\x27\x5e\x1\xa3\xaa\x7c\xce\xc\x55\xc9\x6\x1e\xaf\xb5\xf5\xb3\x14\x34\xbf\xdf\xe7\x31\x20\xcb\xec\x45\x4c\x92\x3b\xf0\xa4\x84\x9d\xdb\xd1\x8e\x74\xcd\xde\x92\x69\x7c\x50\x2c\xaf\x3c\xb7\x89\xf\x4f\xe6\x17\x51\xcc\x0\x77\xd5\x21\x83\x93\xc2\xe0\x40\x86\x65\x3c\x9d\xb6\x4f\xe\x39\x8a\x29\x1c\xc5\x74\xe\x63\xdf\x1b\x72\x1c\x48\xe1\x38\x90\xe4\x48\xec\x63\x43\x8e\xa9\x14\x8e\xa9\x74\xe\x63\x5f\x1a\x72\x90\x14\xe\x2\x39\x2e\xe1\x99\xf4\x5d\x66\xc8\x72\x28\x85\xe5\x50\x6\x8b\xb9\x63\xc\x59\x46\x52\x58\x46\x20\x4b\x19\xd3\xac\xbd\x5f\xc8\x33\x99\xc2\x33\x99\xc5\x63\xed\xe1\x42\x9e\x52\xa\x4f\x29\xb5\xdb\xe0\x8e\xec\xdd\xfa\x35\xf\x19\x96\xf0\xe1\x94\x4d\xd6\xbb\x51\x20\x48\xf1\xc\x2e\xd9\x3b\xa7\x70\xfc\x68\xca\xf8\xd1\x94\x26\xb1\x77\x43\x21\xc7\x58\xa\xc7\x58\x32\xd\x7b\x7b\xf3\x6e\x14\x5\x48\xf1\x9\x84\xef\xdb\x65\x9f\x32\x85\xeb\x26\xe4\xba\x7\xcf\xcf\x80\x60\x76\xf0\xfd\xbb\xed\x53\xa6\x4\xf3\x9c\x19\xcc\x1e\x1f\xa9\x1\xae\x3f\x86\x44\x73\xa6\x6d\x4d\xa6\xf8\xd\xa1\xdf\x61\x9f\xb2\x1\x61\xf4\xf0\xb1\xcc\xdd\xc9\x94\x30\x2e\x9a\x61\xec\xe5\xd9\x9b\xd8\xe9\xdc\x5\x8c\xc1\x96\xeb\x21\xec\x94\xd7\xd7\x4b\x39\xf6\x66\x79\x29\x2c\x21\xf1\xe6\xb5\x52\x9e\x5\xb0\xb6\x72\xb9\xf4\xbe\xfa\x87\xe6\x5e\xc5\xe3\xf0\xa9\xc4\x22\x1e\x5b\xba\x76\x65\x69\xa3\x22\x18\xf4\x47\xc1\x3\x3e\x32\xb6\x43\xd8\x79\xf1\xe6\x2b\xe2\xcd\x5b\x83\x3b\xe2\xcd\xe6\xd2\x87\x4a\xf9\xd9\x7c\x9\x2d\x17\xf5\x6e\x22\xbb\x3d\x5e\x1d\x19\xfd\x97\x53\x7a\xdf\x99\x7b\x10\x4f\x58\x9b\xd4\x5\x8c\x6a\xea\xe\x59\x9b\x9b\xc1\xd3\xec\xcb\xfb\xea\x4e\xa7\xdd\xff\x60\xd4\xab\xcb\x7a\xcf\x9d\xc1\x13\x2c\xc4\xf5\x56\x63\x47\x5a\x1e\xc0\x7\xf8\xde\x26\xc6\x23\xb7\xcb\xd5\x46\x2f\x2a\xe5\xc8\x18\x3e\x78\xfb\x46\x77\x10\x95\xd0\xa9\x8b\x78\x1c\x6e\x2\x4f\xe2\xf1\xf2\x7a\xb8\x72\xe5\xf2\x9a\x4c\xe\x18\x44\x7a\x86\xe1\xb5\x52\x7e\x79\x11\x7b\xb5\x76\xd3\xfe\xe\x9a\x3a\x35\xab\xe8\xdf\x8\xbd\x97\x1f\x11\xa1\x6d\x8e\x8\xeb\x7f\x2\x0\x0\xff\xff\x90\x72\x7d\xae");
  }
}
