<?hh // strict
namespace google\protobuf;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/descriptor.proto

class FileDescriptorSet implements \Protobuf\Message {
  public vec<\google\protobuf\FileDescriptorProto> $file;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'file' => vec<\google\protobuf\FileDescriptorProto>,
  ) $s = shape()) {
    $this->file = $s['file'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.FileDescriptorSet";
  }

  public static function ParseFrom(string $input): ?FileDescriptorSet {
    $msg = new FileDescriptorSet();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\FileDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->file []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->file as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('file', 'file', $this->file);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'file':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FileDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->file []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileDescriptorSet)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->file as $v) {
      $nv = new \google\protobuf\FileDescriptorProto();
      $nv->CopyFrom($v);
      $this->file []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class FileDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private string $package;
  private bool $was_package_set;
  public vec<string> $dependency;
  public vec<int> $public_dependency;
  public vec<int> $weak_dependency;
  public vec<\google\protobuf\DescriptorProto> $message_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\ServiceDescriptorProto> $service;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  private ?\google\protobuf\FileOptions $options;
  private bool $was_options_set;
  private ?\google\protobuf\SourceCodeInfo $source_code_info;
  private bool $was_source_code_info_set;
  private string $syntax;
  private bool $was_syntax_set;
  private string $edition;
  private bool $was_edition_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'package' => string,
    ?'dependency' => vec<string>,
    ?'public_dependency' => vec<int>,
    ?'weak_dependency' => vec<int>,
    ?'message_type' => vec<\google\protobuf\DescriptorProto>,
    ?'enum_type' => vec<\google\protobuf\EnumDescriptorProto>,
    ?'service' => vec<\google\protobuf\ServiceDescriptorProto>,
    ?'extension' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'options' => ?\google\protobuf\FileOptions,
    ?'source_code_info' => ?\google\protobuf\SourceCodeInfo,
    ?'syntax' => string,
    ?'edition' => string,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'package')) {
      $this->package = $s['package'];
      $this->was_package_set = true;
    } else {
      $this->package = '';
      $this->was_package_set = false;
    }
    $this->dependency = $s['dependency'] ?? vec[];
    $this->public_dependency = $s['public_dependency'] ?? vec[];
    $this->weak_dependency = $s['weak_dependency'] ?? vec[];
    $this->message_type = $s['message_type'] ?? vec[];
    $this->enum_type = $s['enum_type'] ?? vec[];
    $this->service = $s['service'] ?? vec[];
    $this->extension = $s['extension'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    if (Shapes::keyExists($s, 'source_code_info')) {
      $this->source_code_info = $s['source_code_info'];
      $this->was_source_code_info_set = true;
    } else {
      $this->source_code_info = null;
      $this->was_source_code_info_set = false;
    }
    if (Shapes::keyExists($s, 'syntax')) {
      $this->syntax = $s['syntax'];
      $this->was_syntax_set = true;
    } else {
      $this->syntax = '';
      $this->was_syntax_set = false;
    }
    if (Shapes::keyExists($s, 'edition')) {
      $this->edition = $s['edition'];
      $this->was_edition_set = true;
    } else {
      $this->edition = '';
      $this->was_edition_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getPackage(): string {
    return $this->package;
  }

  public function setPackage(string $v): void {
    $this->package = $v;
    $this->was_package_set = true;
  }

  public function hasPackage(): bool {
    return $this->was_package_set;
  }

  public function getOptions(): ?\google\protobuf\FileOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\FileOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function getSourceCodeInfo(): ?\google\protobuf\SourceCodeInfo {
    return $this->source_code_info;
  }

  public function setSourceCodeInfo(?\google\protobuf\SourceCodeInfo $v): void {
    $this->source_code_info = $v;
    $this->was_source_code_info_set = true;
  }

  public function hasSourceCodeInfo(): bool {
    return $this->was_source_code_info_set;
  }

  public function getSyntax(): string {
    return $this->syntax;
  }

  public function setSyntax(string $v): void {
    $this->syntax = $v;
    $this->was_syntax_set = true;
  }

  public function hasSyntax(): bool {
    return $this->was_syntax_set;
  }

  public function getEdition(): string {
    return $this->edition;
  }

  public function setEdition(string $v): void {
    $this->edition = $v;
    $this->was_edition_set = true;
  }

  public function hasEdition(): bool {
    return $this->was_edition_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FileDescriptorProto";
  }

  public static function ParseFrom(string $input): ?FileDescriptorProto {
    $msg = new FileDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->package = $d->readString();
          $this->was_package_set = true;
          break;
        case 3:
          $this->dependency []= $d->readString();
          break;
        case 4:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->message_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\ServiceDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->service []= $obj;
          break;
        case 7:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 8:
          if ($this->options is null) {
            $this->options = new \google\protobuf\FileOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          if ($this->source_code_info is null) {
            $this->source_code_info = new \google\protobuf\SourceCodeInfo();
            $this->was_source_code_info_set = true;
          }
          $this->source_code_info->MergeFrom($d->readDecoder());
          break;
        case 10:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->public_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->public_dependency []= $d->readVarint32Signed();
          }
          break;
        case 11:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->weak_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->weak_dependency []= $d->readVarint32Signed();
          }
          break;
        case 12:
          $this->syntax = $d->readString();
          $this->was_syntax_set = true;
          break;
        case 13:
          $this->edition = $d->readString();
          $this->was_edition_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_package_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->package);
    }
    foreach ($this->dependency as $elem) {
      $e->writeTag(3, 2);
      $e->writeString($elem);
    }
    foreach ($this->message_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->service as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 7);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 8);
      }
    }
    $msg = $this->source_code_info;
    if ($msg != null) {
      if ($this->was_source_code_info_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 9);
      }
    }
    foreach ($this->public_dependency as $elem) {
      $e->writeTag(10, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->weak_dependency as $elem) {
      $e->writeTag(11, 0);
      $e->writeVarint($elem);
    }
    if ($this->was_syntax_set) {
      $e->writeTag(12, 2);
      $e->writeString($this->syntax);
    }
    if ($this->was_edition_set) {
      $e->writeTag(13, 2);
      $e->writeString($this->edition);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasPackage()) {
      $e->writeString('package', 'package', $this->package, false);
    }
    $e->writePrimitiveList('dependency', 'dependency', $this->dependency);
    $e->writeMessageList('message_type', 'messageType', $this->message_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('service', 'service', $this->service);
    $e->writeMessageList('extension', 'extension', $this->extension);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    if ($this->hasSourceCodeInfo()) {
      $e->writeMessage('source_code_info', 'sourceCodeInfo', $this->source_code_info, false);
    }
    $e->writePrimitiveList('public_dependency', 'publicDependency', $this->public_dependency);
    $e->writePrimitiveList('weak_dependency', 'weakDependency', $this->weak_dependency);
    if ($this->hasSyntax()) {
      $e->writeString('syntax', 'syntax', $this->syntax, false);
    }
    if ($this->hasEdition()) {
      $e->writeString('edition', 'edition', $this->edition, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'package':
          $this->package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_package_set = true;
          break;
        case 'dependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->dependency []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'message_type': case 'messageType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->message_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'service':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\ServiceDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->service []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\FileOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'source_code_info': case 'sourceCodeInfo':
          if ($v is null) break;
          if ($this->source_code_info is null) {
            $this->source_code_info = new \google\protobuf\SourceCodeInfo();
            $this->was_source_code_info_set = true;
          }
          $this->source_code_info->MergeJsonFrom($v);
          break;
        case 'public_dependency': case 'publicDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->public_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'weak_dependency': case 'weakDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->weak_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'syntax':
          $this->syntax = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_syntax_set = true;
          break;
        case 'edition':
          $this->edition = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_edition_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasPackage()) {
      $this->setPackage($o->getPackage());
    }
    $this->dependency = $o->dependency;
    foreach ($o->message_type as $v) {
      $nv = new \google\protobuf\DescriptorProto();
      $nv->CopyFrom($v);
      $this->message_type []= $nv;
    }
    foreach ($o->enum_type as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto();
      $nv->CopyFrom($v);
      $this->enum_type []= $nv;
    }
    foreach ($o->service as $v) {
      $nv = new \google\protobuf\ServiceDescriptorProto();
      $nv->CopyFrom($v);
      $this->service []= $nv;
    }
    foreach ($o->extension as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->extension []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FileOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $tmp = $o->source_code_info;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\SourceCodeInfo();
      $nv->CopyFrom($tmp);
      $this->setSourceCodeInfo($nv);
    } else if ($o->hasSourceCodeInfo()) {
      $this->setSourceCodeInfo(null);
    }
    $this->public_dependency = $o->public_dependency;
    $this->weak_dependency = $o->weak_dependency;
    if ($o->hasSyntax()) {
      $this->setSyntax($o->getSyntax());
    }
    if ($o->hasEdition()) {
      $this->setEdition($o->getEdition());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto_ExtensionRange implements \Protobuf\Message {
  private int $start;
  private bool $was_start_set;
  private int $end;
  private bool $was_end_set;
  private ?\google\protobuf\ExtensionRangeOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
    ?'options' => ?\google\protobuf\ExtensionRangeOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'start')) {
      $this->start = $s['start'];
      $this->was_start_set = true;
    } else {
      $this->start = 0;
      $this->was_start_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getStart(): int {
    return $this->start;
  }

  public function setStart(int $v): void {
    $this->start = $v;
    $this->was_start_set = true;
  }

  public function hasStart(): bool {
    return $this->was_start_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function getOptions(): ?\google\protobuf\ExtensionRangeOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\ExtensionRangeOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto.ExtensionRange";
  }

  public static function ParseFrom(string $input): ?DescriptorProto_ExtensionRange {
    $msg = new DescriptorProto_ExtensionRange();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          $this->was_start_set = true;
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\ExtensionRangeOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_start_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->was_end_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasStart()) {
      $e->writeInt32('start', 'start', $this->start, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_start_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\ExtensionRangeOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto_ExtensionRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasStart()) {
      $this->setStart($o->getStart());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\ExtensionRangeOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto_ReservedRange implements \Protobuf\Message {
  private int $start;
  private bool $was_start_set;
  private int $end;
  private bool $was_end_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'start')) {
      $this->start = $s['start'];
      $this->was_start_set = true;
    } else {
      $this->start = 0;
      $this->was_start_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getStart(): int {
    return $this->start;
  }

  public function setStart(int $v): void {
    $this->start = $v;
    $this->was_start_set = true;
  }

  public function hasStart(): bool {
    return $this->was_start_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto.ReservedRange";
  }

  public static function ParseFrom(string $input): ?DescriptorProto_ReservedRange {
    $msg = new DescriptorProto_ReservedRange();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          $this->was_start_set = true;
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_start_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->was_end_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasStart()) {
      $e->writeInt32('start', 'start', $this->start, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_start_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto_ReservedRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasStart()) {
      $this->setStart($o->getStart());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  public vec<\google\protobuf\FieldDescriptorProto> $field;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  public vec<\google\protobuf\DescriptorProto> $nested_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\DescriptorProto_ExtensionRange> $extension_range;
  public vec<\google\protobuf\OneofDescriptorProto> $oneof_decl;
  private ?\google\protobuf\MessageOptions $options;
  private bool $was_options_set;
  public vec<\google\protobuf\DescriptorProto_ReservedRange> $reserved_range;
  public vec<string> $reserved_name;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'field' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'extension' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'nested_type' => vec<\google\protobuf\DescriptorProto>,
    ?'enum_type' => vec<\google\protobuf\EnumDescriptorProto>,
    ?'extension_range' => vec<\google\protobuf\DescriptorProto_ExtensionRange>,
    ?'oneof_decl' => vec<\google\protobuf\OneofDescriptorProto>,
    ?'options' => ?\google\protobuf\MessageOptions,
    ?'reserved_range' => vec<\google\protobuf\DescriptorProto_ReservedRange>,
    ?'reserved_name' => vec<string>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    $this->field = $s['field'] ?? vec[];
    $this->extension = $s['extension'] ?? vec[];
    $this->nested_type = $s['nested_type'] ?? vec[];
    $this->enum_type = $s['enum_type'] ?? vec[];
    $this->extension_range = $s['extension_range'] ?? vec[];
    $this->oneof_decl = $s['oneof_decl'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->reserved_range = $s['reserved_range'] ?? vec[];
    $this->reserved_name = $s['reserved_name'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\MessageOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\MessageOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto";
  }

  public static function ParseFrom(string $input): ?DescriptorProto {
    $msg = new DescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->field []= $obj;
          break;
        case 3:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->nested_type []= $obj;
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
          $obj->MergeFrom($d->readDecoder());
          $this->extension_range []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 7:
          if ($this->options is null) {
            $this->options = new \google\protobuf\MessageOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 8:
          $obj = new \google\protobuf\OneofDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->oneof_decl []= $obj;
          break;
        case 9:
          $obj = new \google\protobuf\DescriptorProto_ReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 10:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->field as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    foreach ($this->nested_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->extension_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 7);
      }
    }
    foreach ($this->oneof_decl as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 9);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(10, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    $e->writeMessageList('field', 'field', $this->field);
    $e->writeMessageList('nested_type', 'nestedType', $this->nested_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('extension_range', 'extensionRange', $this->extension_range);
    $e->writeMessageList('extension', 'extension', $this->extension);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    $e->writeMessageList('oneof_decl', 'oneofDecl', $this->oneof_decl);
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'field':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->field []= $obj;
          }
          break;
        case 'nested_type': case 'nestedType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->nested_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'extension_range': case 'extensionRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
            $obj->MergeJsonFrom($vv);
            $this->extension_range []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\MessageOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_decl': case 'oneofDecl':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\OneofDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->oneof_decl []= $obj;
          }
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    foreach ($o->field as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->field []= $nv;
    }
    foreach ($o->nested_type as $v) {
      $nv = new \google\protobuf\DescriptorProto();
      $nv->CopyFrom($v);
      $this->nested_type []= $nv;
    }
    foreach ($o->enum_type as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto();
      $nv->CopyFrom($v);
      $this->enum_type []= $nv;
    }
    foreach ($o->extension_range as $v) {
      $nv = new \google\protobuf\DescriptorProto_ExtensionRange();
      $nv->CopyFrom($v);
      $this->extension_range []= $nv;
    }
    foreach ($o->extension as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->extension []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\MessageOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    foreach ($o->oneof_decl as $v) {
      $nv = new \google\protobuf\OneofDescriptorProto();
      $nv->CopyFrom($v);
      $this->oneof_decl []= $nv;
    }
    foreach ($o->reserved_range as $v) {
      $nv = new \google\protobuf\DescriptorProto_ReservedRange();
      $nv->CopyFrom($v);
      $this->reserved_range []= $nv;
    }
    $this->reserved_name = $o->reserved_name;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype ExtensionRangeOptions_VerificationState_enum_t as int = int;
abstract class ExtensionRangeOptions_VerificationState {
  const ExtensionRangeOptions_VerificationState_enum_t DECLARATION = 0;
  const ExtensionRangeOptions_VerificationState_enum_t UNVERIFIED = 1;
  private static dict<int, string> $itos = dict[
    0 => 'DECLARATION',
    1 => 'UNVERIFIED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'DECLARATION' => 0,
    'UNVERIFIED' => 1,
  ];
  public static function FromMixed(mixed $m): ExtensionRangeOptions_VerificationState_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): ExtensionRangeOptions_VerificationState_enum_t {
    return $i;
  }
}

class ExtensionRangeOptions_Declaration implements \Protobuf\Message {
  private int $number;
  private bool $was_number_set;
  private string $full_name;
  private bool $was_full_name_set;
  private string $type;
  private bool $was_type_set;
  private bool $is_repeated;
  private bool $was_is_repeated_set;
  private bool $reserved;
  private bool $was_reserved_set;
  private bool $repeated;
  private bool $was_repeated_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'number' => int,
    ?'full_name' => string,
    ?'type' => string,
    ?'is_repeated' => bool,
    ?'reserved' => bool,
    ?'repeated' => bool,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'number')) {
      $this->number = $s['number'];
      $this->was_number_set = true;
    } else {
      $this->number = 0;
      $this->was_number_set = false;
    }
    if (Shapes::keyExists($s, 'full_name')) {
      $this->full_name = $s['full_name'];
      $this->was_full_name_set = true;
    } else {
      $this->full_name = '';
      $this->was_full_name_set = false;
    }
    if (Shapes::keyExists($s, 'type')) {
      $this->type = $s['type'];
      $this->was_type_set = true;
    } else {
      $this->type = '';
      $this->was_type_set = false;
    }
    if (Shapes::keyExists($s, 'is_repeated')) {
      $this->is_repeated = $s['is_repeated'];
      $this->was_is_repeated_set = true;
    } else {
      $this->is_repeated = false;
      $this->was_is_repeated_set = false;
    }
    if (Shapes::keyExists($s, 'reserved')) {
      $this->reserved = $s['reserved'];
      $this->was_reserved_set = true;
    } else {
      $this->reserved = false;
      $this->was_reserved_set = false;
    }
    if (Shapes::keyExists($s, 'repeated')) {
      $this->repeated = $s['repeated'];
      $this->was_repeated_set = true;
    } else {
      $this->repeated = false;
      $this->was_repeated_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getNumber(): int {
    return $this->number;
  }

  public function setNumber(int $v): void {
    $this->number = $v;
    $this->was_number_set = true;
  }

  public function hasNumber(): bool {
    return $this->was_number_set;
  }

  public function getFullName(): string {
    return $this->full_name;
  }

  public function setFullName(string $v): void {
    $this->full_name = $v;
    $this->was_full_name_set = true;
  }

  public function hasFullName(): bool {
    return $this->was_full_name_set;
  }

  public function getType(): string {
    return $this->type;
  }

  public function setType(string $v): void {
    $this->type = $v;
    $this->was_type_set = true;
  }

  public function hasType(): bool {
    return $this->was_type_set;
  }

  public function getIsRepeated(): bool {
    return $this->is_repeated;
  }

  public function setIsRepeated(bool $v): void {
    $this->is_repeated = $v;
    $this->was_is_repeated_set = true;
  }

  public function hasIsRepeated(): bool {
    return $this->was_is_repeated_set;
  }

  public function getReserved(): bool {
    return $this->reserved;
  }

  public function setReserved(bool $v): void {
    $this->reserved = $v;
    $this->was_reserved_set = true;
  }

  public function hasReserved(): bool {
    return $this->was_reserved_set;
  }

  public function getRepeated(): bool {
    return $this->repeated;
  }

  public function setRepeated(bool $v): void {
    $this->repeated = $v;
    $this->was_repeated_set = true;
  }

  public function hasRepeated(): bool {
    return $this->was_repeated_set;
  }

  public function MessageName(): string {
    return "google.protobuf.ExtensionRangeOptions.Declaration";
  }

  public static function ParseFrom(string $input): ?ExtensionRangeOptions_Declaration {
    $msg = new ExtensionRangeOptions_Declaration();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->number = $d->readVarint32Signed();
          $this->was_number_set = true;
          break;
        case 2:
          $this->full_name = $d->readString();
          $this->was_full_name_set = true;
          break;
        case 3:
          $this->type = $d->readString();
          $this->was_type_set = true;
          break;
        case 4:
          $this->is_repeated = $d->readBool();
          $this->was_is_repeated_set = true;
          break;
        case 5:
          $this->reserved = $d->readBool();
          $this->was_reserved_set = true;
          break;
        case 6:
          $this->repeated = $d->readBool();
          $this->was_repeated_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_number_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->number);
    }
    if ($this->was_full_name_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->full_name);
    }
    if ($this->was_type_set) {
      $e->writeTag(3, 2);
      $e->writeString($this->type);
    }
    if ($this->was_is_repeated_set) {
      $e->writeTag(4, 0);
      $e->writeBool($this->is_repeated);
    }
    if ($this->was_reserved_set) {
      $e->writeTag(5, 0);
      $e->writeBool($this->reserved);
    }
    if ($this->was_repeated_set) {
      $e->writeTag(6, 0);
      $e->writeBool($this->repeated);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasNumber()) {
      $e->writeInt32('number', 'number', $this->number, false);
    }
    if ($this->hasFullName()) {
      $e->writeString('full_name', 'fullName', $this->full_name, false);
    }
    if ($this->hasType()) {
      $e->writeString('type', 'type', $this->type, false);
    }
    if ($this->hasIsRepeated()) {
      $e->writeBool('is_repeated', 'isRepeated', $this->is_repeated, false);
    }
    if ($this->hasReserved()) {
      $e->writeBool('reserved', 'reserved', $this->reserved, false);
    }
    if ($this->hasRepeated()) {
      $e->writeBool('repeated', 'repeated', $this->repeated, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_number_set = true;
          break;
        case 'full_name': case 'fullName':
          $this->full_name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_full_name_set = true;
          break;
        case 'type':
          $this->type = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_type_set = true;
          break;
        case 'is_repeated': case 'isRepeated':
          $this->is_repeated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_is_repeated_set = true;
          break;
        case 'reserved':
          $this->reserved = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_reserved_set = true;
          break;
        case 'repeated':
          $this->repeated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_repeated_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ExtensionRangeOptions_Declaration)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasNumber()) {
      $this->setNumber($o->getNumber());
    }
    if ($o->hasFullName()) {
      $this->setFullName($o->getFullName());
    }
    if ($o->hasType()) {
      $this->setType($o->getType());
    }
    if ($o->hasIsRepeated()) {
      $this->setIsRepeated($o->getIsRepeated());
    }
    if ($o->hasReserved()) {
      $this->setReserved($o->getReserved());
    }
    if ($o->hasRepeated()) {
      $this->setRepeated($o->getRepeated());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ExtensionRangeOptions implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  public vec<\google\protobuf\ExtensionRangeOptions_Declaration> $declaration;
  private \google\protobuf\ExtensionRangeOptions_VerificationState_enum_t $verification;
  private bool $was_verification_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
    ?'declaration' => vec<\google\protobuf\ExtensionRangeOptions_Declaration>,
    ?'verification' => \google\protobuf\ExtensionRangeOptions_VerificationState_enum_t,
  ) $s = shape()) {
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->declaration = $s['declaration'] ?? vec[];
    if (Shapes::keyExists($s, 'verification')) {
      $this->verification = $s['verification'];
      $this->was_verification_set = true;
    } else {
      $this->verification = \google\protobuf\ExtensionRangeOptions_VerificationState::UNVERIFIED;
      $this->was_verification_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getVerification(): \google\protobuf\ExtensionRangeOptions_VerificationState_enum_t {
    return $this->verification;
  }

  public function setVerification(\google\protobuf\ExtensionRangeOptions_VerificationState_enum_t $v): void {
    $this->verification = $v;
    $this->was_verification_set = true;
  }

  public function hasVerification(): bool {
    return $this->was_verification_set;
  }

  public function MessageName(): string {
    return "google.protobuf.ExtensionRangeOptions";
  }

  public static function ParseFrom(string $input): ?ExtensionRangeOptions {
    $msg = new ExtensionRangeOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $obj = new \google\protobuf\ExtensionRangeOptions_Declaration();
          $obj->MergeFrom($d->readDecoder());
          $this->declaration []= $obj;
          break;
        case 3:
          $this->verification = \google\protobuf\ExtensionRangeOptions_VerificationState::FromInt($d->readVarint());
          $this->was_verification_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->declaration as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    if ($this->was_verification_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->verification);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('declaration', 'declaration', $this->declaration);
    if ($this->hasVerification()) {
      $e->writeEnum('verification', 'verification', \google\protobuf\ExtensionRangeOptions_VerificationState::ToStringDict(), $this->verification, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'declaration':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\ExtensionRangeOptions_Declaration();
            $obj->MergeJsonFrom($vv);
            $this->declaration []= $obj;
          }
          break;
        case 'verification':
          $this->verification = \google\protobuf\ExtensionRangeOptions_VerificationState::FromMixed($v);
          $this->was_verification_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ExtensionRangeOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->declaration as $v) {
      $nv = new \google\protobuf\ExtensionRangeOptions_Declaration();
      $nv->CopyFrom($v);
      $this->declaration []= $nv;
    }
    if ($o->hasVerification()) {
      $this->setVerification($o->getVerification());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FieldDescriptorProto_Type_enum_t as int = int;
abstract class FieldDescriptorProto_Type {
  const FieldDescriptorProto_Type_enum_t TYPE_DOUBLE = 1;
  const FieldDescriptorProto_Type_enum_t TYPE_FLOAT = 2;
  const FieldDescriptorProto_Type_enum_t TYPE_INT64 = 3;
  const FieldDescriptorProto_Type_enum_t TYPE_UINT64 = 4;
  const FieldDescriptorProto_Type_enum_t TYPE_INT32 = 5;
  const FieldDescriptorProto_Type_enum_t TYPE_FIXED64 = 6;
  const FieldDescriptorProto_Type_enum_t TYPE_FIXED32 = 7;
  const FieldDescriptorProto_Type_enum_t TYPE_BOOL = 8;
  const FieldDescriptorProto_Type_enum_t TYPE_STRING = 9;
  const FieldDescriptorProto_Type_enum_t TYPE_GROUP = 10;
  const FieldDescriptorProto_Type_enum_t TYPE_MESSAGE = 11;
  const FieldDescriptorProto_Type_enum_t TYPE_BYTES = 12;
  const FieldDescriptorProto_Type_enum_t TYPE_UINT32 = 13;
  const FieldDescriptorProto_Type_enum_t TYPE_ENUM = 14;
  const FieldDescriptorProto_Type_enum_t TYPE_SFIXED32 = 15;
  const FieldDescriptorProto_Type_enum_t TYPE_SFIXED64 = 16;
  const FieldDescriptorProto_Type_enum_t TYPE_SINT32 = 17;
  const FieldDescriptorProto_Type_enum_t TYPE_SINT64 = 18;
  private static dict<int, string> $itos = dict[
    1 => 'TYPE_DOUBLE',
    2 => 'TYPE_FLOAT',
    3 => 'TYPE_INT64',
    4 => 'TYPE_UINT64',
    5 => 'TYPE_INT32',
    6 => 'TYPE_FIXED64',
    7 => 'TYPE_FIXED32',
    8 => 'TYPE_BOOL',
    9 => 'TYPE_STRING',
    10 => 'TYPE_GROUP',
    11 => 'TYPE_MESSAGE',
    12 => 'TYPE_BYTES',
    13 => 'TYPE_UINT32',
    14 => 'TYPE_ENUM',
    15 => 'TYPE_SFIXED32',
    16 => 'TYPE_SFIXED64',
    17 => 'TYPE_SINT32',
    18 => 'TYPE_SINT64',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'TYPE_DOUBLE' => 1,
    'TYPE_FLOAT' => 2,
    'TYPE_INT64' => 3,
    'TYPE_UINT64' => 4,
    'TYPE_INT32' => 5,
    'TYPE_FIXED64' => 6,
    'TYPE_FIXED32' => 7,
    'TYPE_BOOL' => 8,
    'TYPE_STRING' => 9,
    'TYPE_GROUP' => 10,
    'TYPE_MESSAGE' => 11,
    'TYPE_BYTES' => 12,
    'TYPE_UINT32' => 13,
    'TYPE_ENUM' => 14,
    'TYPE_SFIXED32' => 15,
    'TYPE_SFIXED64' => 16,
    'TYPE_SINT32' => 17,
    'TYPE_SINT64' => 18,
  ];
  public static function FromMixed(mixed $m): FieldDescriptorProto_Type_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldDescriptorProto_Type_enum_t {
    return $i;
  }
}

newtype FieldDescriptorProto_Label_enum_t as int = int;
abstract class FieldDescriptorProto_Label {
  const FieldDescriptorProto_Label_enum_t LABEL_OPTIONAL = 1;
  const FieldDescriptorProto_Label_enum_t LABEL_REQUIRED = 2;
  const FieldDescriptorProto_Label_enum_t LABEL_REPEATED = 3;
  private static dict<int, string> $itos = dict[
    1 => 'LABEL_OPTIONAL',
    2 => 'LABEL_REQUIRED',
    3 => 'LABEL_REPEATED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'LABEL_OPTIONAL' => 1,
    'LABEL_REQUIRED' => 2,
    'LABEL_REPEATED' => 3,
  ];
  public static function FromMixed(mixed $m): FieldDescriptorProto_Label_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldDescriptorProto_Label_enum_t {
    return $i;
  }
}

class FieldDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private int $number;
  private bool $was_number_set;
  private \google\protobuf\FieldDescriptorProto_Label_enum_t $label;
  private bool $was_label_set;
  private \google\protobuf\FieldDescriptorProto_Type_enum_t $type;
  private bool $was_type_set;
  private string $type_name;
  private bool $was_type_name_set;
  private string $extendee;
  private bool $was_extendee_set;
  private string $default_value;
  private bool $was_default_value_set;
  private int $oneof_index;
  private bool $was_oneof_index_set;
  private string $json_name;
  private bool $was_json_name_set;
  private ?\google\protobuf\FieldOptions $options;
  private bool $was_options_set;
  private bool $proto3_optional;
  private bool $was_proto3_optional_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'number' => int,
    ?'label' => \google\protobuf\FieldDescriptorProto_Label_enum_t,
    ?'type' => \google\protobuf\FieldDescriptorProto_Type_enum_t,
    ?'type_name' => string,
    ?'extendee' => string,
    ?'default_value' => string,
    ?'oneof_index' => int,
    ?'json_name' => string,
    ?'options' => ?\google\protobuf\FieldOptions,
    ?'proto3_optional' => bool,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'number')) {
      $this->number = $s['number'];
      $this->was_number_set = true;
    } else {
      $this->number = 0;
      $this->was_number_set = false;
    }
    if (Shapes::keyExists($s, 'label')) {
      $this->label = $s['label'];
      $this->was_label_set = true;
    } else {
      $this->label = \google\protobuf\FieldDescriptorProto_Label::LABEL_OPTIONAL;
      $this->was_label_set = false;
    }
    if (Shapes::keyExists($s, 'type')) {
      $this->type = $s['type'];
      $this->was_type_set = true;
    } else {
      $this->type = \google\protobuf\FieldDescriptorProto_Type::TYPE_DOUBLE;
      $this->was_type_set = false;
    }
    if (Shapes::keyExists($s, 'type_name')) {
      $this->type_name = $s['type_name'];
      $this->was_type_name_set = true;
    } else {
      $this->type_name = '';
      $this->was_type_name_set = false;
    }
    if (Shapes::keyExists($s, 'extendee')) {
      $this->extendee = $s['extendee'];
      $this->was_extendee_set = true;
    } else {
      $this->extendee = '';
      $this->was_extendee_set = false;
    }
    if (Shapes::keyExists($s, 'default_value')) {
      $this->default_value = $s['default_value'];
      $this->was_default_value_set = true;
    } else {
      $this->default_value = '';
      $this->was_default_value_set = false;
    }
    if (Shapes::keyExists($s, 'oneof_index')) {
      $this->oneof_index = $s['oneof_index'];
      $this->was_oneof_index_set = true;
    } else {
      $this->oneof_index = 0;
      $this->was_oneof_index_set = false;
    }
    if (Shapes::keyExists($s, 'json_name')) {
      $this->json_name = $s['json_name'];
      $this->was_json_name_set = true;
    } else {
      $this->json_name = '';
      $this->was_json_name_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    if (Shapes::keyExists($s, 'proto3_optional')) {
      $this->proto3_optional = $s['proto3_optional'];
      $this->was_proto3_optional_set = true;
    } else {
      $this->proto3_optional = false;
      $this->was_proto3_optional_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getNumber(): int {
    return $this->number;
  }

  public function setNumber(int $v): void {
    $this->number = $v;
    $this->was_number_set = true;
  }

  public function hasNumber(): bool {
    return $this->was_number_set;
  }

  public function getLabel(): \google\protobuf\FieldDescriptorProto_Label_enum_t {
    return $this->label;
  }

  public function setLabel(\google\protobuf\FieldDescriptorProto_Label_enum_t $v): void {
    $this->label = $v;
    $this->was_label_set = true;
  }

  public function hasLabel(): bool {
    return $this->was_label_set;
  }

  public function getType(): \google\protobuf\FieldDescriptorProto_Type_enum_t {
    return $this->type;
  }

  public function setType(\google\protobuf\FieldDescriptorProto_Type_enum_t $v): void {
    $this->type = $v;
    $this->was_type_set = true;
  }

  public function hasType(): bool {
    return $this->was_type_set;
  }

  public function getTypeName(): string {
    return $this->type_name;
  }

  public function setTypeName(string $v): void {
    $this->type_name = $v;
    $this->was_type_name_set = true;
  }

  public function hasTypeName(): bool {
    return $this->was_type_name_set;
  }

  public function getExtendee(): string {
    return $this->extendee;
  }

  public function setExtendee(string $v): void {
    $this->extendee = $v;
    $this->was_extendee_set = true;
  }

  public function hasExtendee(): bool {
    return $this->was_extendee_set;
  }

  public function getDefaultValue(): string {
    return $this->default_value;
  }

  public function setDefaultValue(string $v): void {
    $this->default_value = $v;
    $this->was_default_value_set = true;
  }

  public function hasDefaultValue(): bool {
    return $this->was_default_value_set;
  }

  public function getOneofIndex(): int {
    return $this->oneof_index;
  }

  public function setOneofIndex(int $v): void {
    $this->oneof_index = $v;
    $this->was_oneof_index_set = true;
  }

  public function hasOneofIndex(): bool {
    return $this->was_oneof_index_set;
  }

  public function getJsonName(): string {
    return $this->json_name;
  }

  public function setJsonName(string $v): void {
    $this->json_name = $v;
    $this->was_json_name_set = true;
  }

  public function hasJsonName(): bool {
    return $this->was_json_name_set;
  }

  public function getOptions(): ?\google\protobuf\FieldOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\FieldOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function getProto3Optional(): bool {
    return $this->proto3_optional;
  }

  public function setProto3Optional(bool $v): void {
    $this->proto3_optional = $v;
    $this->was_proto3_optional_set = true;
  }

  public function hasProto3Optional(): bool {
    return $this->was_proto3_optional_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FieldDescriptorProto";
  }

  public static function ParseFrom(string $input): ?FieldDescriptorProto {
    $msg = new FieldDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->extendee = $d->readString();
          $this->was_extendee_set = true;
          break;
        case 3:
          $this->number = $d->readVarint32Signed();
          $this->was_number_set = true;
          break;
        case 4:
          $this->label = \google\protobuf\FieldDescriptorProto_Label::FromInt($d->readVarint());
          $this->was_label_set = true;
          break;
        case 5:
          $this->type = \google\protobuf\FieldDescriptorProto_Type::FromInt($d->readVarint());
          $this->was_type_set = true;
          break;
        case 6:
          $this->type_name = $d->readString();
          $this->was_type_name_set = true;
          break;
        case 7:
          $this->default_value = $d->readString();
          $this->was_default_value_set = true;
          break;
        case 8:
          if ($this->options is null) {
            $this->options = new \google\protobuf\FieldOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          $this->oneof_index = $d->readVarint32Signed();
          $this->was_oneof_index_set = true;
          break;
        case 10:
          $this->json_name = $d->readString();
          $this->was_json_name_set = true;
          break;
        case 17:
          $this->proto3_optional = $d->readBool();
          $this->was_proto3_optional_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_extendee_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->extendee);
    }
    if ($this->was_number_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->number);
    }
    if ($this->was_label_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->label);
    }
    if ($this->was_type_set) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->type);
    }
    if ($this->was_type_name_set) {
      $e->writeTag(6, 2);
      $e->writeString($this->type_name);
    }
    if ($this->was_default_value_set) {
      $e->writeTag(7, 2);
      $e->writeString($this->default_value);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 8);
      }
    }
    if ($this->was_oneof_index_set) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->oneof_index);
    }
    if ($this->was_json_name_set) {
      $e->writeTag(10, 2);
      $e->writeString($this->json_name);
    }
    if ($this->was_proto3_optional_set) {
      $e->writeTag(17, 0);
      $e->writeBool($this->proto3_optional);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasExtendee()) {
      $e->writeString('extendee', 'extendee', $this->extendee, false);
    }
    if ($this->hasNumber()) {
      $e->writeInt32('number', 'number', $this->number, false);
    }
    if ($this->hasLabel()) {
      $e->writeEnum('label', 'label', \google\protobuf\FieldDescriptorProto_Label::ToStringDict(), $this->label, false);
    }
    if ($this->hasType()) {
      $e->writeEnum('type', 'type', \google\protobuf\FieldDescriptorProto_Type::ToStringDict(), $this->type, false);
    }
    if ($this->hasTypeName()) {
      $e->writeString('type_name', 'typeName', $this->type_name, false);
    }
    if ($this->hasDefaultValue()) {
      $e->writeString('default_value', 'defaultValue', $this->default_value, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    if ($this->hasOneofIndex()) {
      $e->writeInt32('oneof_index', 'oneofIndex', $this->oneof_index, false);
    }
    if ($this->hasJsonName()) {
      $e->writeString('json_name', 'jsonName', $this->json_name, false);
    }
    if ($this->hasProto3Optional()) {
      $e->writeBool('proto3_optional', 'proto3Optional', $this->proto3_optional, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'extendee':
          $this->extendee = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_extendee_set = true;
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_number_set = true;
          break;
        case 'label':
          $this->label = \google\protobuf\FieldDescriptorProto_Label::FromMixed($v);
          $this->was_label_set = true;
          break;
        case 'type':
          $this->type = \google\protobuf\FieldDescriptorProto_Type::FromMixed($v);
          $this->was_type_set = true;
          break;
        case 'type_name': case 'typeName':
          $this->type_name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_type_name_set = true;
          break;
        case 'default_value': case 'defaultValue':
          $this->default_value = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_default_value_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\FieldOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_index': case 'oneofIndex':
          $this->oneof_index = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_oneof_index_set = true;
          break;
        case 'json_name': case 'jsonName':
          $this->json_name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_json_name_set = true;
          break;
        case 'proto3_optional': case 'proto3Optional':
          $this->proto3_optional = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_proto3_optional_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FieldDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasExtendee()) {
      $this->setExtendee($o->getExtendee());
    }
    if ($o->hasNumber()) {
      $this->setNumber($o->getNumber());
    }
    if ($o->hasLabel()) {
      $this->setLabel($o->getLabel());
    }
    if ($o->hasType()) {
      $this->setType($o->getType());
    }
    if ($o->hasTypeName()) {
      $this->setTypeName($o->getTypeName());
    }
    if ($o->hasDefaultValue()) {
      $this->setDefaultValue($o->getDefaultValue());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FieldOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    if ($o->hasOneofIndex()) {
      $this->setOneofIndex($o->getOneofIndex());
    }
    if ($o->hasJsonName()) {
      $this->setJsonName($o->getJsonName());
    }
    if ($o->hasProto3Optional()) {
      $this->setProto3Optional($o->getProto3Optional());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class OneofDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private ?\google\protobuf\OneofOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'options' => ?\google\protobuf\OneofOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\OneofOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\OneofOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.OneofDescriptorProto";
  }

  public static function ParseFrom(string $input): ?OneofDescriptorProto {
    $msg = new OneofDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          if ($this->options is null) {
            $this->options = new \google\protobuf\OneofOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 2);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\OneofOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is OneofDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\OneofOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumDescriptorProto_EnumReservedRange implements \Protobuf\Message {
  private int $start;
  private bool $was_start_set;
  private int $end;
  private bool $was_end_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'start')) {
      $this->start = $s['start'];
      $this->was_start_set = true;
    } else {
      $this->start = 0;
      $this->was_start_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getStart(): int {
    return $this->start;
  }

  public function setStart(int $v): void {
    $this->start = $v;
    $this->was_start_set = true;
  }

  public function hasStart(): bool {
    return $this->was_start_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumDescriptorProto.EnumReservedRange";
  }

  public static function ParseFrom(string $input): ?EnumDescriptorProto_EnumReservedRange {
    $msg = new EnumDescriptorProto_EnumReservedRange();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          $this->was_start_set = true;
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_start_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->was_end_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasStart()) {
      $e->writeInt32('start', 'start', $this->start, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_start_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumDescriptorProto_EnumReservedRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasStart()) {
      $this->setStart($o->getStart());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  public vec<\google\protobuf\EnumValueDescriptorProto> $value;
  private ?\google\protobuf\EnumOptions $options;
  private bool $was_options_set;
  public vec<\google\protobuf\EnumDescriptorProto_EnumReservedRange> $reserved_range;
  public vec<string> $reserved_name;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'value' => vec<\google\protobuf\EnumValueDescriptorProto>,
    ?'options' => ?\google\protobuf\EnumOptions,
    ?'reserved_range' => vec<\google\protobuf\EnumDescriptorProto_EnumReservedRange>,
    ?'reserved_name' => vec<string>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    $this->value = $s['value'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->reserved_range = $s['reserved_range'] ?? vec[];
    $this->reserved_name = $s['reserved_name'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\EnumOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\EnumOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumDescriptorProto";
  }

  public static function ParseFrom(string $input): ?EnumDescriptorProto {
    $msg = new EnumDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $obj = new \google\protobuf\EnumValueDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->value []= $obj;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 5:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->value as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(5, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    $e->writeMessageList('value', 'value', $this->value);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'value':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumValueDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->value []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    foreach ($o->value as $v) {
      $nv = new \google\protobuf\EnumValueDescriptorProto();
      $nv->CopyFrom($v);
      $this->value []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\EnumOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    foreach ($o->reserved_range as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
      $nv->CopyFrom($v);
      $this->reserved_range []= $nv;
    }
    $this->reserved_name = $o->reserved_name;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumValueDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private int $number;
  private bool $was_number_set;
  private ?\google\protobuf\EnumValueOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'number' => int,
    ?'options' => ?\google\protobuf\EnumValueOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'number')) {
      $this->number = $s['number'];
      $this->was_number_set = true;
    } else {
      $this->number = 0;
      $this->was_number_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getNumber(): int {
    return $this->number;
  }

  public function setNumber(int $v): void {
    $this->number = $v;
    $this->was_number_set = true;
  }

  public function hasNumber(): bool {
    return $this->was_number_set;
  }

  public function getOptions(): ?\google\protobuf\EnumValueOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\EnumValueOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumValueDescriptorProto";
  }

  public static function ParseFrom(string $input): ?EnumValueDescriptorProto {
    $msg = new EnumValueDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->number = $d->readVarint32Signed();
          $this->was_number_set = true;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumValueOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_number_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->number);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasNumber()) {
      $e->writeInt32('number', 'number', $this->number, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_number_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumValueOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumValueDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasNumber()) {
      $this->setNumber($o->getNumber());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\EnumValueOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ServiceDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  public vec<\google\protobuf\MethodDescriptorProto> $method;
  private ?\google\protobuf\ServiceOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'method' => vec<\google\protobuf\MethodDescriptorProto>,
    ?'options' => ?\google\protobuf\ServiceOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    $this->method = $s['method'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\ServiceOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\ServiceOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.ServiceDescriptorProto";
  }

  public static function ParseFrom(string $input): ?ServiceDescriptorProto {
    $msg = new ServiceDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $obj = new \google\protobuf\MethodDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->method []= $obj;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\ServiceOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->method as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    $e->writeMessageList('method', 'method', $this->method);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'method':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\MethodDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->method []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\ServiceOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ServiceDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    foreach ($o->method as $v) {
      $nv = new \google\protobuf\MethodDescriptorProto();
      $nv->CopyFrom($v);
      $this->method []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\ServiceOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class MethodDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private string $input_type;
  private bool $was_input_type_set;
  private string $output_type;
  private bool $was_output_type_set;
  private ?\google\protobuf\MethodOptions $options;
  private bool $was_options_set;
  private bool $client_streaming;
  private bool $was_client_streaming_set;
  private bool $server_streaming;
  private bool $was_server_streaming_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'input_type' => string,
    ?'output_type' => string,
    ?'options' => ?\google\protobuf\MethodOptions,
    ?'client_streaming' => bool,
    ?'server_streaming' => bool,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'input_type')) {
      $this->input_type = $s['input_type'];
      $this->was_input_type_set = true;
    } else {
      $this->input_type = '';
      $this->was_input_type_set = false;
    }
    if (Shapes::keyExists($s, 'output_type')) {
      $this->output_type = $s['output_type'];
      $this->was_output_type_set = true;
    } else {
      $this->output_type = '';
      $this->was_output_type_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    if (Shapes::keyExists($s, 'client_streaming')) {
      $this->client_streaming = $s['client_streaming'];
      $this->was_client_streaming_set = true;
    } else {
      $this->client_streaming = false;
      $this->was_client_streaming_set = false;
    }
    if (Shapes::keyExists($s, 'server_streaming')) {
      $this->server_streaming = $s['server_streaming'];
      $this->was_server_streaming_set = true;
    } else {
      $this->server_streaming = false;
      $this->was_server_streaming_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getInputType(): string {
    return $this->input_type;
  }

  public function setInputType(string $v): void {
    $this->input_type = $v;
    $this->was_input_type_set = true;
  }

  public function hasInputType(): bool {
    return $this->was_input_type_set;
  }

  public function getOutputType(): string {
    return $this->output_type;
  }

  public function setOutputType(string $v): void {
    $this->output_type = $v;
    $this->was_output_type_set = true;
  }

  public function hasOutputType(): bool {
    return $this->was_output_type_set;
  }

  public function getOptions(): ?\google\protobuf\MethodOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\MethodOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function getClientStreaming(): bool {
    return $this->client_streaming;
  }

  public function setClientStreaming(bool $v): void {
    $this->client_streaming = $v;
    $this->was_client_streaming_set = true;
  }

  public function hasClientStreaming(): bool {
    return $this->was_client_streaming_set;
  }

  public function getServerStreaming(): bool {
    return $this->server_streaming;
  }

  public function setServerStreaming(bool $v): void {
    $this->server_streaming = $v;
    $this->was_server_streaming_set = true;
  }

  public function hasServerStreaming(): bool {
    return $this->was_server_streaming_set;
  }

  public function MessageName(): string {
    return "google.protobuf.MethodDescriptorProto";
  }

  public static function ParseFrom(string $input): ?MethodDescriptorProto {
    $msg = new MethodDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->input_type = $d->readString();
          $this->was_input_type_set = true;
          break;
        case 3:
          $this->output_type = $d->readString();
          $this->was_output_type_set = true;
          break;
        case 4:
          if ($this->options is null) {
            $this->options = new \google\protobuf\MethodOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 5:
          $this->client_streaming = $d->readBool();
          $this->was_client_streaming_set = true;
          break;
        case 6:
          $this->server_streaming = $d->readBool();
          $this->was_server_streaming_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_input_type_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->input_type);
    }
    if ($this->was_output_type_set) {
      $e->writeTag(3, 2);
      $e->writeString($this->output_type);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 4);
      }
    }
    if ($this->was_client_streaming_set) {
      $e->writeTag(5, 0);
      $e->writeBool($this->client_streaming);
    }
    if ($this->was_server_streaming_set) {
      $e->writeTag(6, 0);
      $e->writeBool($this->server_streaming);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasInputType()) {
      $e->writeString('input_type', 'inputType', $this->input_type, false);
    }
    if ($this->hasOutputType()) {
      $e->writeString('output_type', 'outputType', $this->output_type, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    if ($this->hasClientStreaming()) {
      $e->writeBool('client_streaming', 'clientStreaming', $this->client_streaming, false);
    }
    if ($this->hasServerStreaming()) {
      $e->writeBool('server_streaming', 'serverStreaming', $this->server_streaming, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'input_type': case 'inputType':
          $this->input_type = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_input_type_set = true;
          break;
        case 'output_type': case 'outputType':
          $this->output_type = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_output_type_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\MethodOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'client_streaming': case 'clientStreaming':
          $this->client_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_client_streaming_set = true;
          break;
        case 'server_streaming': case 'serverStreaming':
          $this->server_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_server_streaming_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MethodDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasInputType()) {
      $this->setInputType($o->getInputType());
    }
    if ($o->hasOutputType()) {
      $this->setOutputType($o->getOutputType());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\MethodOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    if ($o->hasClientStreaming()) {
      $this->setClientStreaming($o->getClientStreaming());
    }
    if ($o->hasServerStreaming()) {
      $this->setServerStreaming($o->getServerStreaming());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FileOptions_OptimizeMode_enum_t as int = int;
abstract class FileOptions_OptimizeMode {
  const FileOptions_OptimizeMode_enum_t SPEED = 1;
  const FileOptions_OptimizeMode_enum_t CODE_SIZE = 2;
  const FileOptions_OptimizeMode_enum_t LITE_RUNTIME = 3;
  private static dict<int, string> $itos = dict[
    1 => 'SPEED',
    2 => 'CODE_SIZE',
    3 => 'LITE_RUNTIME',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'SPEED' => 1,
    'CODE_SIZE' => 2,
    'LITE_RUNTIME' => 3,
  ];
  public static function FromMixed(mixed $m): FileOptions_OptimizeMode_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FileOptions_OptimizeMode_enum_t {
    return $i;
  }
}

class FileOptions implements \Protobuf\Message {
  private string $java_package;
  private bool $was_java_package_set;
  private string $java_outer_classname;
  private bool $was_java_outer_classname_set;
  private bool $java_multiple_files;
  private bool $was_java_multiple_files_set;
  private bool $java_generate_equals_and_hash;
  private bool $was_java_generate_equals_and_hash_set;
  private bool $java_string_check_utf8;
  private bool $was_java_string_check_utf8_set;
  private \google\protobuf\FileOptions_OptimizeMode_enum_t $optimize_for;
  private bool $was_optimize_for_set;
  private string $go_package;
  private bool $was_go_package_set;
  private bool $cc_generic_services;
  private bool $was_cc_generic_services_set;
  private bool $java_generic_services;
  private bool $was_java_generic_services_set;
  private bool $py_generic_services;
  private bool $was_py_generic_services_set;
  private bool $php_generic_services;
  private bool $was_php_generic_services_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  private bool $cc_enable_arenas;
  private bool $was_cc_enable_arenas_set;
  private string $objc_class_prefix;
  private bool $was_objc_class_prefix_set;
  private string $csharp_namespace;
  private bool $was_csharp_namespace_set;
  private string $swift_prefix;
  private bool $was_swift_prefix_set;
  private string $php_class_prefix;
  private bool $was_php_class_prefix_set;
  private string $php_namespace;
  private bool $was_php_namespace_set;
  private string $php_metadata_namespace;
  private bool $was_php_metadata_namespace_set;
  private string $ruby_package;
  private bool $was_ruby_package_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'java_package' => string,
    ?'java_outer_classname' => string,
    ?'java_multiple_files' => bool,
    ?'java_generate_equals_and_hash' => bool,
    ?'java_string_check_utf8' => bool,
    ?'optimize_for' => \google\protobuf\FileOptions_OptimizeMode_enum_t,
    ?'go_package' => string,
    ?'cc_generic_services' => bool,
    ?'java_generic_services' => bool,
    ?'py_generic_services' => bool,
    ?'php_generic_services' => bool,
    ?'deprecated' => bool,
    ?'cc_enable_arenas' => bool,
    ?'objc_class_prefix' => string,
    ?'csharp_namespace' => string,
    ?'swift_prefix' => string,
    ?'php_class_prefix' => string,
    ?'php_namespace' => string,
    ?'php_metadata_namespace' => string,
    ?'ruby_package' => string,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'java_package')) {
      $this->java_package = $s['java_package'];
      $this->was_java_package_set = true;
    } else {
      $this->java_package = '';
      $this->was_java_package_set = false;
    }
    if (Shapes::keyExists($s, 'java_outer_classname')) {
      $this->java_outer_classname = $s['java_outer_classname'];
      $this->was_java_outer_classname_set = true;
    } else {
      $this->java_outer_classname = '';
      $this->was_java_outer_classname_set = false;
    }
    if (Shapes::keyExists($s, 'java_multiple_files')) {
      $this->java_multiple_files = $s['java_multiple_files'];
      $this->was_java_multiple_files_set = true;
    } else {
      $this->java_multiple_files = false;
      $this->was_java_multiple_files_set = false;
    }
    if (Shapes::keyExists($s, 'java_generate_equals_and_hash')) {
      $this->java_generate_equals_and_hash = $s['java_generate_equals_and_hash'];
      $this->was_java_generate_equals_and_hash_set = true;
    } else {
      $this->java_generate_equals_and_hash = false;
      $this->was_java_generate_equals_and_hash_set = false;
    }
    if (Shapes::keyExists($s, 'java_string_check_utf8')) {
      $this->java_string_check_utf8 = $s['java_string_check_utf8'];
      $this->was_java_string_check_utf8_set = true;
    } else {
      $this->java_string_check_utf8 = false;
      $this->was_java_string_check_utf8_set = false;
    }
    if (Shapes::keyExists($s, 'optimize_for')) {
      $this->optimize_for = $s['optimize_for'];
      $this->was_optimize_for_set = true;
    } else {
      $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::SPEED;
      $this->was_optimize_for_set = false;
    }
    if (Shapes::keyExists($s, 'go_package')) {
      $this->go_package = $s['go_package'];
      $this->was_go_package_set = true;
    } else {
      $this->go_package = '';
      $this->was_go_package_set = false;
    }
    if (Shapes::keyExists($s, 'cc_generic_services')) {
      $this->cc_generic_services = $s['cc_generic_services'];
      $this->was_cc_generic_services_set = true;
    } else {
      $this->cc_generic_services = false;
      $this->was_cc_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'java_generic_services')) {
      $this->java_generic_services = $s['java_generic_services'];
      $this->was_java_generic_services_set = true;
    } else {
      $this->java_generic_services = false;
      $this->was_java_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'py_generic_services')) {
      $this->py_generic_services = $s['py_generic_services'];
      $this->was_py_generic_services_set = true;
    } else {
      $this->py_generic_services = false;
      $this->was_py_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'php_generic_services')) {
      $this->php_generic_services = $s['php_generic_services'];
      $this->was_php_generic_services_set = true;
    } else {
      $this->php_generic_services = false;
      $this->was_php_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'cc_enable_arenas')) {
      $this->cc_enable_arenas = $s['cc_enable_arenas'];
      $this->was_cc_enable_arenas_set = true;
    } else {
      $this->cc_enable_arenas = true;
      $this->was_cc_enable_arenas_set = false;
    }
    if (Shapes::keyExists($s, 'objc_class_prefix')) {
      $this->objc_class_prefix = $s['objc_class_prefix'];
      $this->was_objc_class_prefix_set = true;
    } else {
      $this->objc_class_prefix = '';
      $this->was_objc_class_prefix_set = false;
    }
    if (Shapes::keyExists($s, 'csharp_namespace')) {
      $this->csharp_namespace = $s['csharp_namespace'];
      $this->was_csharp_namespace_set = true;
    } else {
      $this->csharp_namespace = '';
      $this->was_csharp_namespace_set = false;
    }
    if (Shapes::keyExists($s, 'swift_prefix')) {
      $this->swift_prefix = $s['swift_prefix'];
      $this->was_swift_prefix_set = true;
    } else {
      $this->swift_prefix = '';
      $this->was_swift_prefix_set = false;
    }
    if (Shapes::keyExists($s, 'php_class_prefix')) {
      $this->php_class_prefix = $s['php_class_prefix'];
      $this->was_php_class_prefix_set = true;
    } else {
      $this->php_class_prefix = '';
      $this->was_php_class_prefix_set = false;
    }
    if (Shapes::keyExists($s, 'php_namespace')) {
      $this->php_namespace = $s['php_namespace'];
      $this->was_php_namespace_set = true;
    } else {
      $this->php_namespace = '';
      $this->was_php_namespace_set = false;
    }
    if (Shapes::keyExists($s, 'php_metadata_namespace')) {
      $this->php_metadata_namespace = $s['php_metadata_namespace'];
      $this->was_php_metadata_namespace_set = true;
    } else {
      $this->php_metadata_namespace = '';
      $this->was_php_metadata_namespace_set = false;
    }
    if (Shapes::keyExists($s, 'ruby_package')) {
      $this->ruby_package = $s['ruby_package'];
      $this->was_ruby_package_set = true;
    } else {
      $this->ruby_package = '';
      $this->was_ruby_package_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getJavaPackage(): string {
    return $this->java_package;
  }

  public function setJavaPackage(string $v): void {
    $this->java_package = $v;
    $this->was_java_package_set = true;
  }

  public function hasJavaPackage(): bool {
    return $this->was_java_package_set;
  }

  public function getJavaOuterClassname(): string {
    return $this->java_outer_classname;
  }

  public function setJavaOuterClassname(string $v): void {
    $this->java_outer_classname = $v;
    $this->was_java_outer_classname_set = true;
  }

  public function hasJavaOuterClassname(): bool {
    return $this->was_java_outer_classname_set;
  }

  public function getJavaMultipleFiles(): bool {
    return $this->java_multiple_files;
  }

  public function setJavaMultipleFiles(bool $v): void {
    $this->java_multiple_files = $v;
    $this->was_java_multiple_files_set = true;
  }

  public function hasJavaMultipleFiles(): bool {
    return $this->was_java_multiple_files_set;
  }

  public function getJavaGenerateEqualsAndHash(): bool {
    return $this->java_generate_equals_and_hash;
  }

  public function setJavaGenerateEqualsAndHash(bool $v): void {
    $this->java_generate_equals_and_hash = $v;
    $this->was_java_generate_equals_and_hash_set = true;
  }

  public function hasJavaGenerateEqualsAndHash(): bool {
    return $this->was_java_generate_equals_and_hash_set;
  }

  public function getJavaStringCheckUtf8(): bool {
    return $this->java_string_check_utf8;
  }

  public function setJavaStringCheckUtf8(bool $v): void {
    $this->java_string_check_utf8 = $v;
    $this->was_java_string_check_utf8_set = true;
  }

  public function hasJavaStringCheckUtf8(): bool {
    return $this->was_java_string_check_utf8_set;
  }

  public function getOptimizeFor(): \google\protobuf\FileOptions_OptimizeMode_enum_t {
    return $this->optimize_for;
  }

  public function setOptimizeFor(\google\protobuf\FileOptions_OptimizeMode_enum_t $v): void {
    $this->optimize_for = $v;
    $this->was_optimize_for_set = true;
  }

  public function hasOptimizeFor(): bool {
    return $this->was_optimize_for_set;
  }

  public function getGoPackage(): string {
    return $this->go_package;
  }

  public function setGoPackage(string $v): void {
    $this->go_package = $v;
    $this->was_go_package_set = true;
  }

  public function hasGoPackage(): bool {
    return $this->was_go_package_set;
  }

  public function getCcGenericServices(): bool {
    return $this->cc_generic_services;
  }

  public function setCcGenericServices(bool $v): void {
    $this->cc_generic_services = $v;
    $this->was_cc_generic_services_set = true;
  }

  public function hasCcGenericServices(): bool {
    return $this->was_cc_generic_services_set;
  }

  public function getJavaGenericServices(): bool {
    return $this->java_generic_services;
  }

  public function setJavaGenericServices(bool $v): void {
    $this->java_generic_services = $v;
    $this->was_java_generic_services_set = true;
  }

  public function hasJavaGenericServices(): bool {
    return $this->was_java_generic_services_set;
  }

  public function getPyGenericServices(): bool {
    return $this->py_generic_services;
  }

  public function setPyGenericServices(bool $v): void {
    $this->py_generic_services = $v;
    $this->was_py_generic_services_set = true;
  }

  public function hasPyGenericServices(): bool {
    return $this->was_py_generic_services_set;
  }

  public function getPhpGenericServices(): bool {
    return $this->php_generic_services;
  }

  public function setPhpGenericServices(bool $v): void {
    $this->php_generic_services = $v;
    $this->was_php_generic_services_set = true;
  }

  public function hasPhpGenericServices(): bool {
    return $this->was_php_generic_services_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getCcEnableArenas(): bool {
    return $this->cc_enable_arenas;
  }

  public function setCcEnableArenas(bool $v): void {
    $this->cc_enable_arenas = $v;
    $this->was_cc_enable_arenas_set = true;
  }

  public function hasCcEnableArenas(): bool {
    return $this->was_cc_enable_arenas_set;
  }

  public function getObjcClassPrefix(): string {
    return $this->objc_class_prefix;
  }

  public function setObjcClassPrefix(string $v): void {
    $this->objc_class_prefix = $v;
    $this->was_objc_class_prefix_set = true;
  }

  public function hasObjcClassPrefix(): bool {
    return $this->was_objc_class_prefix_set;
  }

  public function getCsharpNamespace(): string {
    return $this->csharp_namespace;
  }

  public function setCsharpNamespace(string $v): void {
    $this->csharp_namespace = $v;
    $this->was_csharp_namespace_set = true;
  }

  public function hasCsharpNamespace(): bool {
    return $this->was_csharp_namespace_set;
  }

  public function getSwiftPrefix(): string {
    return $this->swift_prefix;
  }

  public function setSwiftPrefix(string $v): void {
    $this->swift_prefix = $v;
    $this->was_swift_prefix_set = true;
  }

  public function hasSwiftPrefix(): bool {
    return $this->was_swift_prefix_set;
  }

  public function getPhpClassPrefix(): string {
    return $this->php_class_prefix;
  }

  public function setPhpClassPrefix(string $v): void {
    $this->php_class_prefix = $v;
    $this->was_php_class_prefix_set = true;
  }

  public function hasPhpClassPrefix(): bool {
    return $this->was_php_class_prefix_set;
  }

  public function getPhpNamespace(): string {
    return $this->php_namespace;
  }

  public function setPhpNamespace(string $v): void {
    $this->php_namespace = $v;
    $this->was_php_namespace_set = true;
  }

  public function hasPhpNamespace(): bool {
    return $this->was_php_namespace_set;
  }

  public function getPhpMetadataNamespace(): string {
    return $this->php_metadata_namespace;
  }

  public function setPhpMetadataNamespace(string $v): void {
    $this->php_metadata_namespace = $v;
    $this->was_php_metadata_namespace_set = true;
  }

  public function hasPhpMetadataNamespace(): bool {
    return $this->was_php_metadata_namespace_set;
  }

  public function getRubyPackage(): string {
    return $this->ruby_package;
  }

  public function setRubyPackage(string $v): void {
    $this->ruby_package = $v;
    $this->was_ruby_package_set = true;
  }

  public function hasRubyPackage(): bool {
    return $this->was_ruby_package_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FileOptions";
  }

  public static function ParseFrom(string $input): ?FileOptions {
    $msg = new FileOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->java_package = $d->readString();
          $this->was_java_package_set = true;
          break;
        case 8:
          $this->java_outer_classname = $d->readString();
          $this->was_java_outer_classname_set = true;
          break;
        case 9:
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::FromInt($d->readVarint());
          $this->was_optimize_for_set = true;
          break;
        case 10:
          $this->java_multiple_files = $d->readBool();
          $this->was_java_multiple_files_set = true;
          break;
        case 11:
          $this->go_package = $d->readString();
          $this->was_go_package_set = true;
          break;
        case 16:
          $this->cc_generic_services = $d->readBool();
          $this->was_cc_generic_services_set = true;
          break;
        case 17:
          $this->java_generic_services = $d->readBool();
          $this->was_java_generic_services_set = true;
          break;
        case 18:
          $this->py_generic_services = $d->readBool();
          $this->was_py_generic_services_set = true;
          break;
        case 20:
          $this->java_generate_equals_and_hash = $d->readBool();
          $this->was_java_generate_equals_and_hash_set = true;
          break;
        case 23:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 27:
          $this->java_string_check_utf8 = $d->readBool();
          $this->was_java_string_check_utf8_set = true;
          break;
        case 31:
          $this->cc_enable_arenas = $d->readBool();
          $this->was_cc_enable_arenas_set = true;
          break;
        case 36:
          $this->objc_class_prefix = $d->readString();
          $this->was_objc_class_prefix_set = true;
          break;
        case 37:
          $this->csharp_namespace = $d->readString();
          $this->was_csharp_namespace_set = true;
          break;
        case 39:
          $this->swift_prefix = $d->readString();
          $this->was_swift_prefix_set = true;
          break;
        case 40:
          $this->php_class_prefix = $d->readString();
          $this->was_php_class_prefix_set = true;
          break;
        case 41:
          $this->php_namespace = $d->readString();
          $this->was_php_namespace_set = true;
          break;
        case 42:
          $this->php_generic_services = $d->readBool();
          $this->was_php_generic_services_set = true;
          break;
        case 44:
          $this->php_metadata_namespace = $d->readString();
          $this->was_php_metadata_namespace_set = true;
          break;
        case 45:
          $this->ruby_package = $d->readString();
          $this->was_ruby_package_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_java_package_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->java_package);
    }
    if ($this->was_java_outer_classname_set) {
      $e->writeTag(8, 2);
      $e->writeString($this->java_outer_classname);
    }
    if ($this->was_optimize_for_set) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->optimize_for);
    }
    if ($this->was_java_multiple_files_set) {
      $e->writeTag(10, 0);
      $e->writeBool($this->java_multiple_files);
    }
    if ($this->was_go_package_set) {
      $e->writeTag(11, 2);
      $e->writeString($this->go_package);
    }
    if ($this->was_cc_generic_services_set) {
      $e->writeTag(16, 0);
      $e->writeBool($this->cc_generic_services);
    }
    if ($this->was_java_generic_services_set) {
      $e->writeTag(17, 0);
      $e->writeBool($this->java_generic_services);
    }
    if ($this->was_py_generic_services_set) {
      $e->writeTag(18, 0);
      $e->writeBool($this->py_generic_services);
    }
    if ($this->was_java_generate_equals_and_hash_set) {
      $e->writeTag(20, 0);
      $e->writeBool($this->java_generate_equals_and_hash);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(23, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_java_string_check_utf8_set) {
      $e->writeTag(27, 0);
      $e->writeBool($this->java_string_check_utf8);
    }
    if ($this->was_cc_enable_arenas_set) {
      $e->writeTag(31, 0);
      $e->writeBool($this->cc_enable_arenas);
    }
    if ($this->was_objc_class_prefix_set) {
      $e->writeTag(36, 2);
      $e->writeString($this->objc_class_prefix);
    }
    if ($this->was_csharp_namespace_set) {
      $e->writeTag(37, 2);
      $e->writeString($this->csharp_namespace);
    }
    if ($this->was_swift_prefix_set) {
      $e->writeTag(39, 2);
      $e->writeString($this->swift_prefix);
    }
    if ($this->was_php_class_prefix_set) {
      $e->writeTag(40, 2);
      $e->writeString($this->php_class_prefix);
    }
    if ($this->was_php_namespace_set) {
      $e->writeTag(41, 2);
      $e->writeString($this->php_namespace);
    }
    if ($this->was_php_generic_services_set) {
      $e->writeTag(42, 0);
      $e->writeBool($this->php_generic_services);
    }
    if ($this->was_php_metadata_namespace_set) {
      $e->writeTag(44, 2);
      $e->writeString($this->php_metadata_namespace);
    }
    if ($this->was_ruby_package_set) {
      $e->writeTag(45, 2);
      $e->writeString($this->ruby_package);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasJavaPackage()) {
      $e->writeString('java_package', 'javaPackage', $this->java_package, false);
    }
    if ($this->hasJavaOuterClassname()) {
      $e->writeString('java_outer_classname', 'javaOuterClassname', $this->java_outer_classname, false);
    }
    if ($this->hasOptimizeFor()) {
      $e->writeEnum('optimize_for', 'optimizeFor', \google\protobuf\FileOptions_OptimizeMode::ToStringDict(), $this->optimize_for, false);
    }
    if ($this->hasJavaMultipleFiles()) {
      $e->writeBool('java_multiple_files', 'javaMultipleFiles', $this->java_multiple_files, false);
    }
    if ($this->hasGoPackage()) {
      $e->writeString('go_package', 'goPackage', $this->go_package, false);
    }
    if ($this->hasCcGenericServices()) {
      $e->writeBool('cc_generic_services', 'ccGenericServices', $this->cc_generic_services, false);
    }
    if ($this->hasJavaGenericServices()) {
      $e->writeBool('java_generic_services', 'javaGenericServices', $this->java_generic_services, false);
    }
    if ($this->hasPyGenericServices()) {
      $e->writeBool('py_generic_services', 'pyGenericServices', $this->py_generic_services, false);
    }
    if ($this->hasJavaGenerateEqualsAndHash()) {
      $e->writeBool('java_generate_equals_and_hash', 'javaGenerateEqualsAndHash', $this->java_generate_equals_and_hash, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasJavaStringCheckUtf8()) {
      $e->writeBool('java_string_check_utf8', 'javaStringCheckUtf8', $this->java_string_check_utf8, false);
    }
    if ($this->hasCcEnableArenas()) {
      $e->writeBool('cc_enable_arenas', 'ccEnableArenas', $this->cc_enable_arenas, false);
    }
    if ($this->hasObjcClassPrefix()) {
      $e->writeString('objc_class_prefix', 'objcClassPrefix', $this->objc_class_prefix, false);
    }
    if ($this->hasCsharpNamespace()) {
      $e->writeString('csharp_namespace', 'csharpNamespace', $this->csharp_namespace, false);
    }
    if ($this->hasSwiftPrefix()) {
      $e->writeString('swift_prefix', 'swiftPrefix', $this->swift_prefix, false);
    }
    if ($this->hasPhpClassPrefix()) {
      $e->writeString('php_class_prefix', 'phpClassPrefix', $this->php_class_prefix, false);
    }
    if ($this->hasPhpNamespace()) {
      $e->writeString('php_namespace', 'phpNamespace', $this->php_namespace, false);
    }
    if ($this->hasPhpGenericServices()) {
      $e->writeBool('php_generic_services', 'phpGenericServices', $this->php_generic_services, false);
    }
    if ($this->hasPhpMetadataNamespace()) {
      $e->writeString('php_metadata_namespace', 'phpMetadataNamespace', $this->php_metadata_namespace, false);
    }
    if ($this->hasRubyPackage()) {
      $e->writeString('ruby_package', 'rubyPackage', $this->ruby_package, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'java_package': case 'javaPackage':
          $this->java_package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_java_package_set = true;
          break;
        case 'java_outer_classname': case 'javaOuterClassname':
          $this->java_outer_classname = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_java_outer_classname_set = true;
          break;
        case 'optimize_for': case 'optimizeFor':
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::FromMixed($v);
          $this->was_optimize_for_set = true;
          break;
        case 'java_multiple_files': case 'javaMultipleFiles':
          $this->java_multiple_files = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_multiple_files_set = true;
          break;
        case 'go_package': case 'goPackage':
          $this->go_package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_go_package_set = true;
          break;
        case 'cc_generic_services': case 'ccGenericServices':
          $this->cc_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_cc_generic_services_set = true;
          break;
        case 'java_generic_services': case 'javaGenericServices':
          $this->java_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_generic_services_set = true;
          break;
        case 'py_generic_services': case 'pyGenericServices':
          $this->py_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_py_generic_services_set = true;
          break;
        case 'java_generate_equals_and_hash': case 'javaGenerateEqualsAndHash':
          $this->java_generate_equals_and_hash = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_generate_equals_and_hash_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'java_string_check_utf8': case 'javaStringCheckUtf8':
          $this->java_string_check_utf8 = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_string_check_utf8_set = true;
          break;
        case 'cc_enable_arenas': case 'ccEnableArenas':
          $this->cc_enable_arenas = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_cc_enable_arenas_set = true;
          break;
        case 'objc_class_prefix': case 'objcClassPrefix':
          $this->objc_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_objc_class_prefix_set = true;
          break;
        case 'csharp_namespace': case 'csharpNamespace':
          $this->csharp_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_csharp_namespace_set = true;
          break;
        case 'swift_prefix': case 'swiftPrefix':
          $this->swift_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_swift_prefix_set = true;
          break;
        case 'php_class_prefix': case 'phpClassPrefix':
          $this->php_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_php_class_prefix_set = true;
          break;
        case 'php_namespace': case 'phpNamespace':
          $this->php_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_php_namespace_set = true;
          break;
        case 'php_generic_services': case 'phpGenericServices':
          $this->php_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_php_generic_services_set = true;
          break;
        case 'php_metadata_namespace': case 'phpMetadataNamespace':
          $this->php_metadata_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_php_metadata_namespace_set = true;
          break;
        case 'ruby_package': case 'rubyPackage':
          $this->ruby_package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_ruby_package_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasJavaPackage()) {
      $this->setJavaPackage($o->getJavaPackage());
    }
    if ($o->hasJavaOuterClassname()) {
      $this->setJavaOuterClassname($o->getJavaOuterClassname());
    }
    if ($o->hasOptimizeFor()) {
      $this->setOptimizeFor($o->getOptimizeFor());
    }
    if ($o->hasJavaMultipleFiles()) {
      $this->setJavaMultipleFiles($o->getJavaMultipleFiles());
    }
    if ($o->hasGoPackage()) {
      $this->setGoPackage($o->getGoPackage());
    }
    if ($o->hasCcGenericServices()) {
      $this->setCcGenericServices($o->getCcGenericServices());
    }
    if ($o->hasJavaGenericServices()) {
      $this->setJavaGenericServices($o->getJavaGenericServices());
    }
    if ($o->hasPyGenericServices()) {
      $this->setPyGenericServices($o->getPyGenericServices());
    }
    if ($o->hasJavaGenerateEqualsAndHash()) {
      $this->setJavaGenerateEqualsAndHash($o->getJavaGenerateEqualsAndHash());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasJavaStringCheckUtf8()) {
      $this->setJavaStringCheckUtf8($o->getJavaStringCheckUtf8());
    }
    if ($o->hasCcEnableArenas()) {
      $this->setCcEnableArenas($o->getCcEnableArenas());
    }
    if ($o->hasObjcClassPrefix()) {
      $this->setObjcClassPrefix($o->getObjcClassPrefix());
    }
    if ($o->hasCsharpNamespace()) {
      $this->setCsharpNamespace($o->getCsharpNamespace());
    }
    if ($o->hasSwiftPrefix()) {
      $this->setSwiftPrefix($o->getSwiftPrefix());
    }
    if ($o->hasPhpClassPrefix()) {
      $this->setPhpClassPrefix($o->getPhpClassPrefix());
    }
    if ($o->hasPhpNamespace()) {
      $this->setPhpNamespace($o->getPhpNamespace());
    }
    if ($o->hasPhpGenericServices()) {
      $this->setPhpGenericServices($o->getPhpGenericServices());
    }
    if ($o->hasPhpMetadataNamespace()) {
      $this->setPhpMetadataNamespace($o->getPhpMetadataNamespace());
    }
    if ($o->hasRubyPackage()) {
      $this->setRubyPackage($o->getRubyPackage());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class MessageOptions implements \Protobuf\Message {
  private bool $message_set_wire_format;
  private bool $was_message_set_wire_format_set;
  private bool $no_standard_descriptor_accessor;
  private bool $was_no_standard_descriptor_accessor_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  private bool $map_entry;
  private bool $was_map_entry_set;
  private bool $deprecated_legacy_json_field_conflicts;
  private bool $was_deprecated_legacy_json_field_conflicts_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'message_set_wire_format' => bool,
    ?'no_standard_descriptor_accessor' => bool,
    ?'deprecated' => bool,
    ?'map_entry' => bool,
    ?'deprecated_legacy_json_field_conflicts' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'message_set_wire_format')) {
      $this->message_set_wire_format = $s['message_set_wire_format'];
      $this->was_message_set_wire_format_set = true;
    } else {
      $this->message_set_wire_format = false;
      $this->was_message_set_wire_format_set = false;
    }
    if (Shapes::keyExists($s, 'no_standard_descriptor_accessor')) {
      $this->no_standard_descriptor_accessor = $s['no_standard_descriptor_accessor'];
      $this->was_no_standard_descriptor_accessor_set = true;
    } else {
      $this->no_standard_descriptor_accessor = false;
      $this->was_no_standard_descriptor_accessor_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'map_entry')) {
      $this->map_entry = $s['map_entry'];
      $this->was_map_entry_set = true;
    } else {
      $this->map_entry = false;
      $this->was_map_entry_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated_legacy_json_field_conflicts')) {
      $this->deprecated_legacy_json_field_conflicts = $s['deprecated_legacy_json_field_conflicts'];
      $this->was_deprecated_legacy_json_field_conflicts_set = true;
    } else {
      $this->deprecated_legacy_json_field_conflicts = false;
      $this->was_deprecated_legacy_json_field_conflicts_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getMessageSetWireFormat(): bool {
    return $this->message_set_wire_format;
  }

  public function setMessageSetWireFormat(bool $v): void {
    $this->message_set_wire_format = $v;
    $this->was_message_set_wire_format_set = true;
  }

  public function hasMessageSetWireFormat(): bool {
    return $this->was_message_set_wire_format_set;
  }

  public function getNoStandardDescriptorAccessor(): bool {
    return $this->no_standard_descriptor_accessor;
  }

  public function setNoStandardDescriptorAccessor(bool $v): void {
    $this->no_standard_descriptor_accessor = $v;
    $this->was_no_standard_descriptor_accessor_set = true;
  }

  public function hasNoStandardDescriptorAccessor(): bool {
    return $this->was_no_standard_descriptor_accessor_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getMapEntry(): bool {
    return $this->map_entry;
  }

  public function setMapEntry(bool $v): void {
    $this->map_entry = $v;
    $this->was_map_entry_set = true;
  }

  public function hasMapEntry(): bool {
    return $this->was_map_entry_set;
  }

  public function getDeprecatedLegacyJsonFieldConflicts(): bool {
    return $this->deprecated_legacy_json_field_conflicts;
  }

  public function setDeprecatedLegacyJsonFieldConflicts(bool $v): void {
    $this->deprecated_legacy_json_field_conflicts = $v;
    $this->was_deprecated_legacy_json_field_conflicts_set = true;
  }

  public function hasDeprecatedLegacyJsonFieldConflicts(): bool {
    return $this->was_deprecated_legacy_json_field_conflicts_set;
  }

  public function MessageName(): string {
    return "google.protobuf.MessageOptions";
  }

  public static function ParseFrom(string $input): ?MessageOptions {
    $msg = new MessageOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->message_set_wire_format = $d->readBool();
          $this->was_message_set_wire_format_set = true;
          break;
        case 2:
          $this->no_standard_descriptor_accessor = $d->readBool();
          $this->was_no_standard_descriptor_accessor_set = true;
          break;
        case 3:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 7:
          $this->map_entry = $d->readBool();
          $this->was_map_entry_set = true;
          break;
        case 11:
          $this->deprecated_legacy_json_field_conflicts = $d->readBool();
          $this->was_deprecated_legacy_json_field_conflicts_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_message_set_wire_format_set) {
      $e->writeTag(1, 0);
      $e->writeBool($this->message_set_wire_format);
    }
    if ($this->was_no_standard_descriptor_accessor_set) {
      $e->writeTag(2, 0);
      $e->writeBool($this->no_standard_descriptor_accessor);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_map_entry_set) {
      $e->writeTag(7, 0);
      $e->writeBool($this->map_entry);
    }
    if ($this->was_deprecated_legacy_json_field_conflicts_set) {
      $e->writeTag(11, 0);
      $e->writeBool($this->deprecated_legacy_json_field_conflicts);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasMessageSetWireFormat()) {
      $e->writeBool('message_set_wire_format', 'messageSetWireFormat', $this->message_set_wire_format, false);
    }
    if ($this->hasNoStandardDescriptorAccessor()) {
      $e->writeBool('no_standard_descriptor_accessor', 'noStandardDescriptorAccessor', $this->no_standard_descriptor_accessor, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasMapEntry()) {
      $e->writeBool('map_entry', 'mapEntry', $this->map_entry, false);
    }
    if ($this->hasDeprecatedLegacyJsonFieldConflicts()) {
      $e->writeBool('deprecated_legacy_json_field_conflicts', 'deprecatedLegacyJsonFieldConflicts', $this->deprecated_legacy_json_field_conflicts, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'message_set_wire_format': case 'messageSetWireFormat':
          $this->message_set_wire_format = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_message_set_wire_format_set = true;
          break;
        case 'no_standard_descriptor_accessor': case 'noStandardDescriptorAccessor':
          $this->no_standard_descriptor_accessor = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_no_standard_descriptor_accessor_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'map_entry': case 'mapEntry':
          $this->map_entry = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_map_entry_set = true;
          break;
        case 'deprecated_legacy_json_field_conflicts': case 'deprecatedLegacyJsonFieldConflicts':
          $this->deprecated_legacy_json_field_conflicts = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_legacy_json_field_conflicts_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MessageOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasMessageSetWireFormat()) {
      $this->setMessageSetWireFormat($o->getMessageSetWireFormat());
    }
    if ($o->hasNoStandardDescriptorAccessor()) {
      $this->setNoStandardDescriptorAccessor($o->getNoStandardDescriptorAccessor());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasMapEntry()) {
      $this->setMapEntry($o->getMapEntry());
    }
    if ($o->hasDeprecatedLegacyJsonFieldConflicts()) {
      $this->setDeprecatedLegacyJsonFieldConflicts($o->getDeprecatedLegacyJsonFieldConflicts());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FieldOptions_CType_enum_t as int = int;
abstract class FieldOptions_CType {
  const FieldOptions_CType_enum_t STRING = 0;
  const FieldOptions_CType_enum_t CORD = 1;
  const FieldOptions_CType_enum_t STRING_PIECE = 2;
  private static dict<int, string> $itos = dict[
    0 => 'STRING',
    1 => 'CORD',
    2 => 'STRING_PIECE',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'STRING' => 0,
    'CORD' => 1,
    'STRING_PIECE' => 2,
  ];
  public static function FromMixed(mixed $m): FieldOptions_CType_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_CType_enum_t {
    return $i;
  }
}

newtype FieldOptions_JSType_enum_t as int = int;
abstract class FieldOptions_JSType {
  const FieldOptions_JSType_enum_t JS_NORMAL = 0;
  const FieldOptions_JSType_enum_t JS_STRING = 1;
  const FieldOptions_JSType_enum_t JS_NUMBER = 2;
  private static dict<int, string> $itos = dict[
    0 => 'JS_NORMAL',
    1 => 'JS_STRING',
    2 => 'JS_NUMBER',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'JS_NORMAL' => 0,
    'JS_STRING' => 1,
    'JS_NUMBER' => 2,
  ];
  public static function FromMixed(mixed $m): FieldOptions_JSType_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_JSType_enum_t {
    return $i;
  }
}

newtype FieldOptions_OptionRetention_enum_t as int = int;
abstract class FieldOptions_OptionRetention {
  const FieldOptions_OptionRetention_enum_t RETENTION_UNKNOWN = 0;
  const FieldOptions_OptionRetention_enum_t RETENTION_RUNTIME = 1;
  const FieldOptions_OptionRetention_enum_t RETENTION_SOURCE = 2;
  private static dict<int, string> $itos = dict[
    0 => 'RETENTION_UNKNOWN',
    1 => 'RETENTION_RUNTIME',
    2 => 'RETENTION_SOURCE',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'RETENTION_UNKNOWN' => 0,
    'RETENTION_RUNTIME' => 1,
    'RETENTION_SOURCE' => 2,
  ];
  public static function FromMixed(mixed $m): FieldOptions_OptionRetention_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_OptionRetention_enum_t {
    return $i;
  }
}

newtype FieldOptions_OptionTargetType_enum_t as int = int;
abstract class FieldOptions_OptionTargetType {
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_UNKNOWN = 0;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_FILE = 1;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_EXTENSION_RANGE = 2;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_MESSAGE = 3;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_FIELD = 4;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_ONEOF = 5;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_ENUM = 6;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_ENUM_ENTRY = 7;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_SERVICE = 8;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_METHOD = 9;
  private static dict<int, string> $itos = dict[
    0 => 'TARGET_TYPE_UNKNOWN',
    1 => 'TARGET_TYPE_FILE',
    2 => 'TARGET_TYPE_EXTENSION_RANGE',
    3 => 'TARGET_TYPE_MESSAGE',
    4 => 'TARGET_TYPE_FIELD',
    5 => 'TARGET_TYPE_ONEOF',
    6 => 'TARGET_TYPE_ENUM',
    7 => 'TARGET_TYPE_ENUM_ENTRY',
    8 => 'TARGET_TYPE_SERVICE',
    9 => 'TARGET_TYPE_METHOD',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'TARGET_TYPE_UNKNOWN' => 0,
    'TARGET_TYPE_FILE' => 1,
    'TARGET_TYPE_EXTENSION_RANGE' => 2,
    'TARGET_TYPE_MESSAGE' => 3,
    'TARGET_TYPE_FIELD' => 4,
    'TARGET_TYPE_ONEOF' => 5,
    'TARGET_TYPE_ENUM' => 6,
    'TARGET_TYPE_ENUM_ENTRY' => 7,
    'TARGET_TYPE_SERVICE' => 8,
    'TARGET_TYPE_METHOD' => 9,
  ];
  public static function FromMixed(mixed $m): FieldOptions_OptionTargetType_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_OptionTargetType_enum_t {
    return $i;
  }
}

class FieldOptions implements \Protobuf\Message {
  private \google\protobuf\FieldOptions_CType_enum_t $ctype;
  private bool $was_ctype_set;
  private bool $packed;
  private bool $was_packed_set;
  private \google\protobuf\FieldOptions_JSType_enum_t $jstype;
  private bool $was_jstype_set;
  private bool $lazy;
  private bool $was_lazy_set;
  private bool $unverified_lazy;
  private bool $was_unverified_lazy_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  private bool $weak;
  private bool $was_weak_set;
  private bool $debug_redact;
  private bool $was_debug_redact_set;
  private \google\protobuf\FieldOptions_OptionRetention_enum_t $retention;
  private bool $was_retention_set;
  private \google\protobuf\FieldOptions_OptionTargetType_enum_t $target;
  private bool $was_target_set;
  public vec<\google\protobuf\FieldOptions_OptionTargetType_enum_t> $targets;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'ctype' => \google\protobuf\FieldOptions_CType_enum_t,
    ?'packed' => bool,
    ?'jstype' => \google\protobuf\FieldOptions_JSType_enum_t,
    ?'lazy' => bool,
    ?'unverified_lazy' => bool,
    ?'deprecated' => bool,
    ?'weak' => bool,
    ?'debug_redact' => bool,
    ?'retention' => \google\protobuf\FieldOptions_OptionRetention_enum_t,
    ?'target' => \google\protobuf\FieldOptions_OptionTargetType_enum_t,
    ?'targets' => vec<\google\protobuf\FieldOptions_OptionTargetType_enum_t>,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'ctype')) {
      $this->ctype = $s['ctype'];
      $this->was_ctype_set = true;
    } else {
      $this->ctype = \google\protobuf\FieldOptions_CType::STRING;
      $this->was_ctype_set = false;
    }
    if (Shapes::keyExists($s, 'packed')) {
      $this->packed = $s['packed'];
      $this->was_packed_set = true;
    } else {
      $this->packed = false;
      $this->was_packed_set = false;
    }
    if (Shapes::keyExists($s, 'jstype')) {
      $this->jstype = $s['jstype'];
      $this->was_jstype_set = true;
    } else {
      $this->jstype = \google\protobuf\FieldOptions_JSType::JS_NORMAL;
      $this->was_jstype_set = false;
    }
    if (Shapes::keyExists($s, 'lazy')) {
      $this->lazy = $s['lazy'];
      $this->was_lazy_set = true;
    } else {
      $this->lazy = false;
      $this->was_lazy_set = false;
    }
    if (Shapes::keyExists($s, 'unverified_lazy')) {
      $this->unverified_lazy = $s['unverified_lazy'];
      $this->was_unverified_lazy_set = true;
    } else {
      $this->unverified_lazy = false;
      $this->was_unverified_lazy_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'weak')) {
      $this->weak = $s['weak'];
      $this->was_weak_set = true;
    } else {
      $this->weak = false;
      $this->was_weak_set = false;
    }
    if (Shapes::keyExists($s, 'debug_redact')) {
      $this->debug_redact = $s['debug_redact'];
      $this->was_debug_redact_set = true;
    } else {
      $this->debug_redact = false;
      $this->was_debug_redact_set = false;
    }
    if (Shapes::keyExists($s, 'retention')) {
      $this->retention = $s['retention'];
      $this->was_retention_set = true;
    } else {
      $this->retention = \google\protobuf\FieldOptions_OptionRetention::RETENTION_UNKNOWN;
      $this->was_retention_set = false;
    }
    if (Shapes::keyExists($s, 'target')) {
      $this->target = $s['target'];
      $this->was_target_set = true;
    } else {
      $this->target = \google\protobuf\FieldOptions_OptionTargetType::TARGET_TYPE_UNKNOWN;
      $this->was_target_set = false;
    }
    $this->targets = $s['targets'] ?? vec[];
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getCtype(): \google\protobuf\FieldOptions_CType_enum_t {
    return $this->ctype;
  }

  public function setCtype(\google\protobuf\FieldOptions_CType_enum_t $v): void {
    $this->ctype = $v;
    $this->was_ctype_set = true;
  }

  public function hasCtype(): bool {
    return $this->was_ctype_set;
  }

  public function getPacked(): bool {
    return $this->packed;
  }

  public function setPacked(bool $v): void {
    $this->packed = $v;
    $this->was_packed_set = true;
  }

  public function hasPacked(): bool {
    return $this->was_packed_set;
  }

  public function getJstype(): \google\protobuf\FieldOptions_JSType_enum_t {
    return $this->jstype;
  }

  public function setJstype(\google\protobuf\FieldOptions_JSType_enum_t $v): void {
    $this->jstype = $v;
    $this->was_jstype_set = true;
  }

  public function hasJstype(): bool {
    return $this->was_jstype_set;
  }

  public function getLazy(): bool {
    return $this->lazy;
  }

  public function setLazy(bool $v): void {
    $this->lazy = $v;
    $this->was_lazy_set = true;
  }

  public function hasLazy(): bool {
    return $this->was_lazy_set;
  }

  public function getUnverifiedLazy(): bool {
    return $this->unverified_lazy;
  }

  public function setUnverifiedLazy(bool $v): void {
    $this->unverified_lazy = $v;
    $this->was_unverified_lazy_set = true;
  }

  public function hasUnverifiedLazy(): bool {
    return $this->was_unverified_lazy_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getWeak(): bool {
    return $this->weak;
  }

  public function setWeak(bool $v): void {
    $this->weak = $v;
    $this->was_weak_set = true;
  }

  public function hasWeak(): bool {
    return $this->was_weak_set;
  }

  public function getDebugRedact(): bool {
    return $this->debug_redact;
  }

  public function setDebugRedact(bool $v): void {
    $this->debug_redact = $v;
    $this->was_debug_redact_set = true;
  }

  public function hasDebugRedact(): bool {
    return $this->was_debug_redact_set;
  }

  public function getRetention(): \google\protobuf\FieldOptions_OptionRetention_enum_t {
    return $this->retention;
  }

  public function setRetention(\google\protobuf\FieldOptions_OptionRetention_enum_t $v): void {
    $this->retention = $v;
    $this->was_retention_set = true;
  }

  public function hasRetention(): bool {
    return $this->was_retention_set;
  }

  public function getTarget(): \google\protobuf\FieldOptions_OptionTargetType_enum_t {
    return $this->target;
  }

  public function setTarget(\google\protobuf\FieldOptions_OptionTargetType_enum_t $v): void {
    $this->target = $v;
    $this->was_target_set = true;
  }

  public function hasTarget(): bool {
    return $this->was_target_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FieldOptions";
  }

  public static function ParseFrom(string $input): ?FieldOptions {
    $msg = new FieldOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->ctype = \google\protobuf\FieldOptions_CType::FromInt($d->readVarint());
          $this->was_ctype_set = true;
          break;
        case 2:
          $this->packed = $d->readBool();
          $this->was_packed_set = true;
          break;
        case 3:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 5:
          $this->lazy = $d->readBool();
          $this->was_lazy_set = true;
          break;
        case 6:
          $this->jstype = \google\protobuf\FieldOptions_JSType::FromInt($d->readVarint());
          $this->was_jstype_set = true;
          break;
        case 10:
          $this->weak = $d->readBool();
          $this->was_weak_set = true;
          break;
        case 15:
          $this->unverified_lazy = $d->readBool();
          $this->was_unverified_lazy_set = true;
          break;
        case 16:
          $this->debug_redact = $d->readBool();
          $this->was_debug_redact_set = true;
          break;
        case 17:
          $this->retention = \google\protobuf\FieldOptions_OptionRetention::FromInt($d->readVarint());
          $this->was_retention_set = true;
          break;
        case 18:
          $this->target = \google\protobuf\FieldOptions_OptionTargetType::FromInt($d->readVarint());
          $this->was_target_set = true;
          break;
        case 19:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->targets []= \google\protobuf\FieldOptions_OptionTargetType::FromInt($packed->readVarint());
            }
          } else {
            $this->targets []= \google\protobuf\FieldOptions_OptionTargetType::FromInt($d->readVarint());
          }
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_ctype_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->ctype);
    }
    if ($this->was_packed_set) {
      $e->writeTag(2, 0);
      $e->writeBool($this->packed);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_lazy_set) {
      $e->writeTag(5, 0);
      $e->writeBool($this->lazy);
    }
    if ($this->was_jstype_set) {
      $e->writeTag(6, 0);
      $e->writeVarint($this->jstype);
    }
    if ($this->was_weak_set) {
      $e->writeTag(10, 0);
      $e->writeBool($this->weak);
    }
    if ($this->was_unverified_lazy_set) {
      $e->writeTag(15, 0);
      $e->writeBool($this->unverified_lazy);
    }
    if ($this->was_debug_redact_set) {
      $e->writeTag(16, 0);
      $e->writeBool($this->debug_redact);
    }
    if ($this->was_retention_set) {
      $e->writeTag(17, 0);
      $e->writeVarint($this->retention);
    }
    if ($this->was_target_set) {
      $e->writeTag(18, 0);
      $e->writeVarint($this->target);
    }
    foreach ($this->targets as $elem) {
      $e->writeTag(19, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasCtype()) {
      $e->writeEnum('ctype', 'ctype', \google\protobuf\FieldOptions_CType::ToStringDict(), $this->ctype, false);
    }
    if ($this->hasPacked()) {
      $e->writeBool('packed', 'packed', $this->packed, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasLazy()) {
      $e->writeBool('lazy', 'lazy', $this->lazy, false);
    }
    if ($this->hasJstype()) {
      $e->writeEnum('jstype', 'jstype', \google\protobuf\FieldOptions_JSType::ToStringDict(), $this->jstype, false);
    }
    if ($this->hasWeak()) {
      $e->writeBool('weak', 'weak', $this->weak, false);
    }
    if ($this->hasUnverifiedLazy()) {
      $e->writeBool('unverified_lazy', 'unverifiedLazy', $this->unverified_lazy, false);
    }
    if ($this->hasDebugRedact()) {
      $e->writeBool('debug_redact', 'debugRedact', $this->debug_redact, false);
    }
    if ($this->hasRetention()) {
      $e->writeEnum('retention', 'retention', \google\protobuf\FieldOptions_OptionRetention::ToStringDict(), $this->retention, false);
    }
    if ($this->hasTarget()) {
      $e->writeEnum('target', 'target', \google\protobuf\FieldOptions_OptionTargetType::ToStringDict(), $this->target, false);
    }
    $e->writeEnumList('targets', 'targets', \google\protobuf\FieldOptions_OptionTargetType::ToStringDict(), $this->targets);
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'ctype':
          $this->ctype = \google\protobuf\FieldOptions_CType::FromMixed($v);
          $this->was_ctype_set = true;
          break;
        case 'packed':
          $this->packed = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_packed_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'lazy':
          $this->lazy = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_lazy_set = true;
          break;
        case 'jstype':
          $this->jstype = \google\protobuf\FieldOptions_JSType::FromMixed($v);
          $this->was_jstype_set = true;
          break;
        case 'weak':
          $this->weak = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_weak_set = true;
          break;
        case 'unverified_lazy': case 'unverifiedLazy':
          $this->unverified_lazy = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_unverified_lazy_set = true;
          break;
        case 'debug_redact': case 'debugRedact':
          $this->debug_redact = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_debug_redact_set = true;
          break;
        case 'retention':
          $this->retention = \google\protobuf\FieldOptions_OptionRetention::FromMixed($v);
          $this->was_retention_set = true;
          break;
        case 'target':
          $this->target = \google\protobuf\FieldOptions_OptionTargetType::FromMixed($v);
          $this->was_target_set = true;
          break;
        case 'targets':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->targets []= \google\protobuf\FieldOptions_OptionTargetType::FromMixed($vv);
          }
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FieldOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasCtype()) {
      $this->setCtype($o->getCtype());
    }
    if ($o->hasPacked()) {
      $this->setPacked($o->getPacked());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasLazy()) {
      $this->setLazy($o->getLazy());
    }
    if ($o->hasJstype()) {
      $this->setJstype($o->getJstype());
    }
    if ($o->hasWeak()) {
      $this->setWeak($o->getWeak());
    }
    if ($o->hasUnverifiedLazy()) {
      $this->setUnverifiedLazy($o->getUnverifiedLazy());
    }
    if ($o->hasDebugRedact()) {
      $this->setDebugRedact($o->getDebugRedact());
    }
    if ($o->hasRetention()) {
      $this->setRetention($o->getRetention());
    }
    if ($o->hasTarget()) {
      $this->setTarget($o->getTarget());
    }
    $this->targets = $o->targets;
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class OneofOptions implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.OneofOptions";
  }

  public static function ParseFrom(string $input): ?OneofOptions {
    $msg = new OneofOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is OneofOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumOptions implements \Protobuf\Message {
  private bool $allow_alias;
  private bool $was_allow_alias_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  private bool $deprecated_legacy_json_field_conflicts;
  private bool $was_deprecated_legacy_json_field_conflicts_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'allow_alias' => bool,
    ?'deprecated' => bool,
    ?'deprecated_legacy_json_field_conflicts' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'allow_alias')) {
      $this->allow_alias = $s['allow_alias'];
      $this->was_allow_alias_set = true;
    } else {
      $this->allow_alias = false;
      $this->was_allow_alias_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated_legacy_json_field_conflicts')) {
      $this->deprecated_legacy_json_field_conflicts = $s['deprecated_legacy_json_field_conflicts'];
      $this->was_deprecated_legacy_json_field_conflicts_set = true;
    } else {
      $this->deprecated_legacy_json_field_conflicts = false;
      $this->was_deprecated_legacy_json_field_conflicts_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getAllowAlias(): bool {
    return $this->allow_alias;
  }

  public function setAllowAlias(bool $v): void {
    $this->allow_alias = $v;
    $this->was_allow_alias_set = true;
  }

  public function hasAllowAlias(): bool {
    return $this->was_allow_alias_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getDeprecatedLegacyJsonFieldConflicts(): bool {
    return $this->deprecated_legacy_json_field_conflicts;
  }

  public function setDeprecatedLegacyJsonFieldConflicts(bool $v): void {
    $this->deprecated_legacy_json_field_conflicts = $v;
    $this->was_deprecated_legacy_json_field_conflicts_set = true;
  }

  public function hasDeprecatedLegacyJsonFieldConflicts(): bool {
    return $this->was_deprecated_legacy_json_field_conflicts_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumOptions";
  }

  public static function ParseFrom(string $input): ?EnumOptions {
    $msg = new EnumOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $this->allow_alias = $d->readBool();
          $this->was_allow_alias_set = true;
          break;
        case 3:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 6:
          $this->deprecated_legacy_json_field_conflicts = $d->readBool();
          $this->was_deprecated_legacy_json_field_conflicts_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_allow_alias_set) {
      $e->writeTag(2, 0);
      $e->writeBool($this->allow_alias);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_deprecated_legacy_json_field_conflicts_set) {
      $e->writeTag(6, 0);
      $e->writeBool($this->deprecated_legacy_json_field_conflicts);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasAllowAlias()) {
      $e->writeBool('allow_alias', 'allowAlias', $this->allow_alias, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasDeprecatedLegacyJsonFieldConflicts()) {
      $e->writeBool('deprecated_legacy_json_field_conflicts', 'deprecatedLegacyJsonFieldConflicts', $this->deprecated_legacy_json_field_conflicts, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'allow_alias': case 'allowAlias':
          $this->allow_alias = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_allow_alias_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'deprecated_legacy_json_field_conflicts': case 'deprecatedLegacyJsonFieldConflicts':
          $this->deprecated_legacy_json_field_conflicts = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_legacy_json_field_conflicts_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasAllowAlias()) {
      $this->setAllowAlias($o->getAllowAlias());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasDeprecatedLegacyJsonFieldConflicts()) {
      $this->setDeprecatedLegacyJsonFieldConflicts($o->getDeprecatedLegacyJsonFieldConflicts());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumValueOptions implements \Protobuf\Message {
  private bool $deprecated;
  private bool $was_deprecated_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'deprecated' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumValueOptions";
  }

  public static function ParseFrom(string $input): ?EnumValueOptions {
    $msg = new EnumValueOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_deprecated_set) {
      $e->writeTag(1, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumValueOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ServiceOptions implements \Protobuf\Message {
  private bool $deprecated;
  private bool $was_deprecated_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'deprecated' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function MessageName(): string {
    return "google.protobuf.ServiceOptions";
  }

  public static function ParseFrom(string $input): ?ServiceOptions {
    $msg = new ServiceOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_deprecated_set) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ServiceOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype MethodOptions_IdempotencyLevel_enum_t as int = int;
abstract class MethodOptions_IdempotencyLevel {
  const MethodOptions_IdempotencyLevel_enum_t IDEMPOTENCY_UNKNOWN = 0;
  const MethodOptions_IdempotencyLevel_enum_t NO_SIDE_EFFECTS = 1;
  const MethodOptions_IdempotencyLevel_enum_t IDEMPOTENT = 2;
  private static dict<int, string> $itos = dict[
    0 => 'IDEMPOTENCY_UNKNOWN',
    1 => 'NO_SIDE_EFFECTS',
    2 => 'IDEMPOTENT',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'IDEMPOTENCY_UNKNOWN' => 0,
    'NO_SIDE_EFFECTS' => 1,
    'IDEMPOTENT' => 2,
  ];
  public static function FromMixed(mixed $m): MethodOptions_IdempotencyLevel_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): MethodOptions_IdempotencyLevel_enum_t {
    return $i;
  }
}

class MethodOptions implements \Protobuf\Message {
  private bool $deprecated;
  private bool $was_deprecated_set;
  private \google\protobuf\MethodOptions_IdempotencyLevel_enum_t $idempotency_level;
  private bool $was_idempotency_level_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'deprecated' => bool,
    ?'idempotency_level' => \google\protobuf\MethodOptions_IdempotencyLevel_enum_t,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'idempotency_level')) {
      $this->idempotency_level = $s['idempotency_level'];
      $this->was_idempotency_level_set = true;
    } else {
      $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::IDEMPOTENCY_UNKNOWN;
      $this->was_idempotency_level_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getIdempotencyLevel(): \google\protobuf\MethodOptions_IdempotencyLevel_enum_t {
    return $this->idempotency_level;
  }

  public function setIdempotencyLevel(\google\protobuf\MethodOptions_IdempotencyLevel_enum_t $v): void {
    $this->idempotency_level = $v;
    $this->was_idempotency_level_set = true;
  }

  public function hasIdempotencyLevel(): bool {
    return $this->was_idempotency_level_set;
  }

  public function MessageName(): string {
    return "google.protobuf.MethodOptions";
  }

  public static function ParseFrom(string $input): ?MethodOptions {
    $msg = new MethodOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 34:
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::FromInt($d->readVarint());
          $this->was_idempotency_level_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_deprecated_set) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_idempotency_level_set) {
      $e->writeTag(34, 0);
      $e->writeVarint($this->idempotency_level);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasIdempotencyLevel()) {
      $e->writeEnum('idempotency_level', 'idempotencyLevel', \google\protobuf\MethodOptions_IdempotencyLevel::ToStringDict(), $this->idempotency_level, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'idempotency_level': case 'idempotencyLevel':
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::FromMixed($v);
          $this->was_idempotency_level_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MethodOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasIdempotencyLevel()) {
      $this->setIdempotencyLevel($o->getIdempotencyLevel());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UninterpretedOption_NamePart implements \Protobuf\Message {
  public string $name_part;
  public bool $is_extension;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name_part' => string,
    ?'is_extension' => bool,
  ) $s = shape()) {
    $this->name_part = $s['name_part'] ?? '';
    $this->is_extension = $s['is_extension'] ?? false;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.UninterpretedOption.NamePart";
  }

  public static function ParseFrom(string $input): ?UninterpretedOption_NamePart {
    $msg = new UninterpretedOption_NamePart();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name_part = $d->readString();
          break;
        case 2:
          $this->is_extension = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name_part !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name_part);
    }
    if ($this->is_extension !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->is_extension);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name_part', 'namePart', $this->name_part, false);
    $e->writeBool('is_extension', 'isExtension', $this->is_extension, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name_part': case 'namePart':
          $this->name_part = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'is_extension': case 'isExtension':
          $this->is_extension = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UninterpretedOption_NamePart)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name_part = $o->name_part;
    $this->is_extension = $o->is_extension;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UninterpretedOption implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption_NamePart> $name;
  private string $identifier_value;
  private bool $was_identifier_value_set;
  private int $positive_int_value;
  private bool $was_positive_int_value_set;
  private int $negative_int_value;
  private bool $was_negative_int_value_set;
  private float $double_value;
  private bool $was_double_value_set;
  private string $string_value;
  private bool $was_string_value_set;
  private string $aggregate_value;
  private bool $was_aggregate_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => vec<\google\protobuf\UninterpretedOption_NamePart>,
    ?'identifier_value' => string,
    ?'positive_int_value' => int,
    ?'negative_int_value' => int,
    ?'double_value' => float,
    ?'string_value' => string,
    ?'aggregate_value' => string,
  ) $s = shape()) {
    $this->name = $s['name'] ?? vec[];
    if (Shapes::keyExists($s, 'identifier_value')) {
      $this->identifier_value = $s['identifier_value'];
      $this->was_identifier_value_set = true;
    } else {
      $this->identifier_value = '';
      $this->was_identifier_value_set = false;
    }
    if (Shapes::keyExists($s, 'positive_int_value')) {
      $this->positive_int_value = $s['positive_int_value'];
      $this->was_positive_int_value_set = true;
    } else {
      $this->positive_int_value = 0;
      $this->was_positive_int_value_set = false;
    }
    if (Shapes::keyExists($s, 'negative_int_value')) {
      $this->negative_int_value = $s['negative_int_value'];
      $this->was_negative_int_value_set = true;
    } else {
      $this->negative_int_value = 0;
      $this->was_negative_int_value_set = false;
    }
    if (Shapes::keyExists($s, 'double_value')) {
      $this->double_value = $s['double_value'];
      $this->was_double_value_set = true;
    } else {
      $this->double_value = 0.0;
      $this->was_double_value_set = false;
    }
    if (Shapes::keyExists($s, 'string_value')) {
      $this->string_value = $s['string_value'];
      $this->was_string_value_set = true;
    } else {
      $this->string_value = '';
      $this->was_string_value_set = false;
    }
    if (Shapes::keyExists($s, 'aggregate_value')) {
      $this->aggregate_value = $s['aggregate_value'];
      $this->was_aggregate_value_set = true;
    } else {
      $this->aggregate_value = '';
      $this->was_aggregate_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getIdentifierValue(): string {
    return $this->identifier_value;
  }

  public function setIdentifierValue(string $v): void {
    $this->identifier_value = $v;
    $this->was_identifier_value_set = true;
  }

  public function hasIdentifierValue(): bool {
    return $this->was_identifier_value_set;
  }

  public function getPositiveIntValue(): int {
    return $this->positive_int_value;
  }

  public function setPositiveIntValue(int $v): void {
    $this->positive_int_value = $v;
    $this->was_positive_int_value_set = true;
  }

  public function hasPositiveIntValue(): bool {
    return $this->was_positive_int_value_set;
  }

  public function getNegativeIntValue(): int {
    return $this->negative_int_value;
  }

  public function setNegativeIntValue(int $v): void {
    $this->negative_int_value = $v;
    $this->was_negative_int_value_set = true;
  }

  public function hasNegativeIntValue(): bool {
    return $this->was_negative_int_value_set;
  }

  public function getDoubleValue(): float {
    return $this->double_value;
  }

  public function setDoubleValue(float $v): void {
    $this->double_value = $v;
    $this->was_double_value_set = true;
  }

  public function hasDoubleValue(): bool {
    return $this->was_double_value_set;
  }

  public function getStringValue(): string {
    return $this->string_value;
  }

  public function setStringValue(string $v): void {
    $this->string_value = $v;
    $this->was_string_value_set = true;
  }

  public function hasStringValue(): bool {
    return $this->was_string_value_set;
  }

  public function getAggregateValue(): string {
    return $this->aggregate_value;
  }

  public function setAggregateValue(string $v): void {
    $this->aggregate_value = $v;
    $this->was_aggregate_value_set = true;
  }

  public function hasAggregateValue(): bool {
    return $this->was_aggregate_value_set;
  }

  public function MessageName(): string {
    return "google.protobuf.UninterpretedOption";
  }

  public static function ParseFrom(string $input): ?UninterpretedOption {
    $msg = new UninterpretedOption();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $obj = new \google\protobuf\UninterpretedOption_NamePart();
          $obj->MergeFrom($d->readDecoder());
          $this->name []= $obj;
          break;
        case 3:
          $this->identifier_value = $d->readString();
          $this->was_identifier_value_set = true;
          break;
        case 4:
          $this->positive_int_value = $d->readVarint();
          $this->was_positive_int_value_set = true;
          break;
        case 5:
          $this->negative_int_value = $d->readVarint();
          $this->was_negative_int_value_set = true;
          break;
        case 6:
          $this->double_value = $d->readDouble();
          $this->was_double_value_set = true;
          break;
        case 7:
          $this->string_value = $d->readString();
          $this->was_string_value_set = true;
          break;
        case 8:
          $this->aggregate_value = $d->readString();
          $this->was_aggregate_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->name as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    if ($this->was_identifier_value_set) {
      $e->writeTag(3, 2);
      $e->writeString($this->identifier_value);
    }
    if ($this->was_positive_int_value_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->positive_int_value);
    }
    if ($this->was_negative_int_value_set) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->negative_int_value);
    }
    if ($this->was_double_value_set) {
      $e->writeTag(6, 1);
      $e->writeDouble($this->double_value);
    }
    if ($this->was_string_value_set) {
      $e->writeTag(7, 2);
      $e->writeString($this->string_value);
    }
    if ($this->was_aggregate_value_set) {
      $e->writeTag(8, 2);
      $e->writeString($this->aggregate_value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('name', 'name', $this->name);
    if ($this->hasIdentifierValue()) {
      $e->writeString('identifier_value', 'identifierValue', $this->identifier_value, false);
    }
    if ($this->hasPositiveIntValue()) {
      $e->writeInt64Unsigned('positive_int_value', 'positiveIntValue', $this->positive_int_value, false);
    }
    if ($this->hasNegativeIntValue()) {
      $e->writeInt64Signed('negative_int_value', 'negativeIntValue', $this->negative_int_value, false);
    }
    if ($this->hasDoubleValue()) {
      $e->writeFloat('double_value', 'doubleValue', $this->double_value, false);
    }
    if ($this->hasStringValue()) {
      $e->writeBytes('string_value', 'stringValue', $this->string_value, false);
    }
    if ($this->hasAggregateValue()) {
      $e->writeString('aggregate_value', 'aggregateValue', $this->aggregate_value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption_NamePart();
            $obj->MergeJsonFrom($vv);
            $this->name []= $obj;
          }
          break;
        case 'identifier_value': case 'identifierValue':
          $this->identifier_value = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_identifier_value_set = true;
          break;
        case 'positive_int_value': case 'positiveIntValue':
          $this->positive_int_value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          $this->was_positive_int_value_set = true;
          break;
        case 'negative_int_value': case 'negativeIntValue':
          $this->negative_int_value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_negative_int_value_set = true;
          break;
        case 'double_value': case 'doubleValue':
          $this->double_value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          $this->was_double_value_set = true;
          break;
        case 'string_value': case 'stringValue':
          $this->string_value = \Protobuf\Internal\JsonDecoder::readBytes($v);
          $this->was_string_value_set = true;
          break;
        case 'aggregate_value': case 'aggregateValue':
          $this->aggregate_value = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_aggregate_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UninterpretedOption)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->name as $v) {
      $nv = new \google\protobuf\UninterpretedOption_NamePart();
      $nv->CopyFrom($v);
      $this->name []= $nv;
    }
    if ($o->hasIdentifierValue()) {
      $this->setIdentifierValue($o->getIdentifierValue());
    }
    if ($o->hasPositiveIntValue()) {
      $this->setPositiveIntValue($o->getPositiveIntValue());
    }
    if ($o->hasNegativeIntValue()) {
      $this->setNegativeIntValue($o->getNegativeIntValue());
    }
    if ($o->hasDoubleValue()) {
      $this->setDoubleValue($o->getDoubleValue());
    }
    if ($o->hasStringValue()) {
      $this->setStringValue($o->getStringValue());
    }
    if ($o->hasAggregateValue()) {
      $this->setAggregateValue($o->getAggregateValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class SourceCodeInfo_Location implements \Protobuf\Message {
  public vec<int> $path;
  public vec<int> $span;
  private string $leading_comments;
  private bool $was_leading_comments_set;
  private string $trailing_comments;
  private bool $was_trailing_comments_set;
  public vec<string> $leading_detached_comments;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'path' => vec<int>,
    ?'span' => vec<int>,
    ?'leading_comments' => string,
    ?'trailing_comments' => string,
    ?'leading_detached_comments' => vec<string>,
  ) $s = shape()) {
    $this->path = $s['path'] ?? vec[];
    $this->span = $s['span'] ?? vec[];
    if (Shapes::keyExists($s, 'leading_comments')) {
      $this->leading_comments = $s['leading_comments'];
      $this->was_leading_comments_set = true;
    } else {
      $this->leading_comments = '';
      $this->was_leading_comments_set = false;
    }
    if (Shapes::keyExists($s, 'trailing_comments')) {
      $this->trailing_comments = $s['trailing_comments'];
      $this->was_trailing_comments_set = true;
    } else {
      $this->trailing_comments = '';
      $this->was_trailing_comments_set = false;
    }
    $this->leading_detached_comments = $s['leading_detached_comments'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getLeadingComments(): string {
    return $this->leading_comments;
  }

  public function setLeadingComments(string $v): void {
    $this->leading_comments = $v;
    $this->was_leading_comments_set = true;
  }

  public function hasLeadingComments(): bool {
    return $this->was_leading_comments_set;
  }

  public function getTrailingComments(): string {
    return $this->trailing_comments;
  }

  public function setTrailingComments(string $v): void {
    $this->trailing_comments = $v;
    $this->was_trailing_comments_set = true;
  }

  public function hasTrailingComments(): bool {
    return $this->was_trailing_comments_set;
  }

  public function MessageName(): string {
    return "google.protobuf.SourceCodeInfo.Location";
  }

  public static function ParseFrom(string $input): ?SourceCodeInfo_Location {
    $msg = new SourceCodeInfo_Location();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->span []= $packed->readVarint32Signed();
            }
          } else {
            $this->span []= $d->readVarint32Signed();
          }
          break;
        case 3:
          $this->leading_comments = $d->readString();
          $this->was_leading_comments_set = true;
          break;
        case 4:
          $this->trailing_comments = $d->readString();
          $this->was_trailing_comments_set = true;
          break;
        case 6:
          $this->leading_detached_comments []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if (\count($this->path) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->path as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 1);
    }
    if (\count($this->span) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->span as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 2);
    }
    if ($this->was_leading_comments_set) {
      $e->writeTag(3, 2);
      $e->writeString($this->leading_comments);
    }
    if ($this->was_trailing_comments_set) {
      $e->writeTag(4, 2);
      $e->writeString($this->trailing_comments);
    }
    foreach ($this->leading_detached_comments as $elem) {
      $e->writeTag(6, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    $e->writePrimitiveList('span', 'span', $this->span);
    if ($this->hasLeadingComments()) {
      $e->writeString('leading_comments', 'leadingComments', $this->leading_comments, false);
    }
    if ($this->hasTrailingComments()) {
      $e->writeString('trailing_comments', 'trailingComments', $this->trailing_comments, false);
    }
    $e->writePrimitiveList('leading_detached_comments', 'leadingDetachedComments', $this->leading_detached_comments);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'span':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->span []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'leading_comments': case 'leadingComments':
          $this->leading_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_leading_comments_set = true;
          break;
        case 'trailing_comments': case 'trailingComments':
          $this->trailing_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_trailing_comments_set = true;
          break;
        case 'leading_detached_comments': case 'leadingDetachedComments':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->leading_detached_comments []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is SourceCodeInfo_Location)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->path = $o->path;
    $this->span = $o->span;
    if ($o->hasLeadingComments()) {
      $this->setLeadingComments($o->getLeadingComments());
    }
    if ($o->hasTrailingComments()) {
      $this->setTrailingComments($o->getTrailingComments());
    }
    $this->leading_detached_comments = $o->leading_detached_comments;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class SourceCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\SourceCodeInfo_Location> $location;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'location' => vec<\google\protobuf\SourceCodeInfo_Location>,
  ) $s = shape()) {
    $this->location = $s['location'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.SourceCodeInfo";
  }

  public static function ParseFrom(string $input): ?SourceCodeInfo {
    $msg = new SourceCodeInfo();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\SourceCodeInfo_Location();
          $obj->MergeFrom($d->readDecoder());
          $this->location []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->location as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('location', 'location', $this->location);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'location':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\SourceCodeInfo_Location();
            $obj->MergeJsonFrom($vv);
            $this->location []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is SourceCodeInfo)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->location as $v) {
      $nv = new \google\protobuf\SourceCodeInfo_Location();
      $nv->CopyFrom($v);
      $this->location []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype GeneratedCodeInfo_Annotation_Semantic_enum_t as int = int;
abstract class GeneratedCodeInfo_Annotation_Semantic {
  const GeneratedCodeInfo_Annotation_Semantic_enum_t NONE = 0;
  const GeneratedCodeInfo_Annotation_Semantic_enum_t SET = 1;
  const GeneratedCodeInfo_Annotation_Semantic_enum_t ALIAS = 2;
  private static dict<int, string> $itos = dict[
    0 => 'NONE',
    1 => 'SET',
    2 => 'ALIAS',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'NONE' => 0,
    'SET' => 1,
    'ALIAS' => 2,
  ];
  public static function FromMixed(mixed $m): GeneratedCodeInfo_Annotation_Semantic_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): GeneratedCodeInfo_Annotation_Semantic_enum_t {
    return $i;
  }
}

class GeneratedCodeInfo_Annotation implements \Protobuf\Message {
  public vec<int> $path;
  private string $source_file;
  private bool $was_source_file_set;
  private int $begin;
  private bool $was_begin_set;
  private int $end;
  private bool $was_end_set;
  private \google\protobuf\GeneratedCodeInfo_Annotation_Semantic_enum_t $semantic;
  private bool $was_semantic_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'path' => vec<int>,
    ?'source_file' => string,
    ?'begin' => int,
    ?'end' => int,
    ?'semantic' => \google\protobuf\GeneratedCodeInfo_Annotation_Semantic_enum_t,
  ) $s = shape()) {
    $this->path = $s['path'] ?? vec[];
    if (Shapes::keyExists($s, 'source_file')) {
      $this->source_file = $s['source_file'];
      $this->was_source_file_set = true;
    } else {
      $this->source_file = '';
      $this->was_source_file_set = false;
    }
    if (Shapes::keyExists($s, 'begin')) {
      $this->begin = $s['begin'];
      $this->was_begin_set = true;
    } else {
      $this->begin = 0;
      $this->was_begin_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    if (Shapes::keyExists($s, 'semantic')) {
      $this->semantic = $s['semantic'];
      $this->was_semantic_set = true;
    } else {
      $this->semantic = \google\protobuf\GeneratedCodeInfo_Annotation_Semantic::NONE;
      $this->was_semantic_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getSourceFile(): string {
    return $this->source_file;
  }

  public function setSourceFile(string $v): void {
    $this->source_file = $v;
    $this->was_source_file_set = true;
  }

  public function hasSourceFile(): bool {
    return $this->was_source_file_set;
  }

  public function getBegin(): int {
    return $this->begin;
  }

  public function setBegin(int $v): void {
    $this->begin = $v;
    $this->was_begin_set = true;
  }

  public function hasBegin(): bool {
    return $this->was_begin_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function getSemantic(): \google\protobuf\GeneratedCodeInfo_Annotation_Semantic_enum_t {
    return $this->semantic;
  }

  public function setSemantic(\google\protobuf\GeneratedCodeInfo_Annotation_Semantic_enum_t $v): void {
    $this->semantic = $v;
    $this->was_semantic_set = true;
  }

  public function hasSemantic(): bool {
    return $this->was_semantic_set;
  }

  public function MessageName(): string {
    return "google.protobuf.GeneratedCodeInfo.Annotation";
  }

  public static function ParseFrom(string $input): ?GeneratedCodeInfo_Annotation {
    $msg = new GeneratedCodeInfo_Annotation();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          $this->source_file = $d->readString();
          $this->was_source_file_set = true;
          break;
        case 3:
          $this->begin = $d->readVarint32Signed();
          $this->was_begin_set = true;
          break;
        case 4:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        case 5:
          $this->semantic = \google\protobuf\GeneratedCodeInfo_Annotation_Semantic::FromInt($d->readVarint());
          $this->was_semantic_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if (\count($this->path) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->path as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 1);
    }
    if ($this->was_source_file_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->source_file);
    }
    if ($this->was_begin_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->begin);
    }
    if ($this->was_end_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->end);
    }
    if ($this->was_semantic_set) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->semantic);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    if ($this->hasSourceFile()) {
      $e->writeString('source_file', 'sourceFile', $this->source_file, false);
    }
    if ($this->hasBegin()) {
      $e->writeInt32('begin', 'begin', $this->begin, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
    if ($this->hasSemantic()) {
      $e->writeEnum('semantic', 'semantic', \google\protobuf\GeneratedCodeInfo_Annotation_Semantic::ToStringDict(), $this->semantic, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'source_file': case 'sourceFile':
          $this->source_file = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_source_file_set = true;
          break;
        case 'begin':
          $this->begin = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_begin_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        case 'semantic':
          $this->semantic = \google\protobuf\GeneratedCodeInfo_Annotation_Semantic::FromMixed($v);
          $this->was_semantic_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is GeneratedCodeInfo_Annotation)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->path = $o->path;
    if ($o->hasSourceFile()) {
      $this->setSourceFile($o->getSourceFile());
    }
    if ($o->hasBegin()) {
      $this->setBegin($o->getBegin());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    if ($o->hasSemantic()) {
      $this->setSemantic($o->getSemantic());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class GeneratedCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\GeneratedCodeInfo_Annotation> $annotation;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'annotation' => vec<\google\protobuf\GeneratedCodeInfo_Annotation>,
  ) $s = shape()) {
    $this->annotation = $s['annotation'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.GeneratedCodeInfo";
  }

  public static function ParseFrom(string $input): ?GeneratedCodeInfo {
    $msg = new GeneratedCodeInfo();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
          $obj->MergeFrom($d->readDecoder());
          $this->annotation []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->annotation as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('annotation', 'annotation', $this->annotation);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'annotation':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
            $obj->MergeJsonFrom($vv);
            $this->annotation []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is GeneratedCodeInfo)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->annotation as $v) {
      $nv = new \google\protobuf\GeneratedCodeInfo_Annotation();
      $nv->CopyFrom($v);
      $this->annotation []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_descriptor__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/descriptor.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 12261 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\xcc\x5a\x4f\x6f\x1b\xc9\xb1\x37\xff\x8a\x2c\x52\x64\xab\x25\xdb\xb4\xbc\xbb\x96\xe9\x5d\x5b\xf6\xae\xe9\x85\xfc\x67\xbd\xda\x87\x7d\x8f\x22\x47\x32\xb5\x14\xa9\x37\xa4\xbc\xf6\x2\xf\x83\xd6\xb0\x49\x8d\x3d\x9c\x99\x9d\x19\xda\xd6\x1e\x1e\xc\x3c\x3c\x20\x1\x72\xc9\x2d\x8\x82\x1c\x72\x59\x20\x40\x4e\x1\x2\x4\x39\xe5\xb\x4\xf9\x8\x1\x72\x48\x80\x7c\x81\x9c\x82\xa0\xbb\x67\x86\x33\x43\xca\x96\x17\xf0\x26\x27\xa9\xab\x7e\x55\x5d\x5d\x5d\x53\x5d\xd5\x4d\x58\x1b\x99\xe6\x48\xa7\xb7\x2c\xdb\x74\xcd\xc3\xc9\xf0\xd6\x80\x3a\xaa\xad\x59\xae\x69\xd7\x38\xd\x97\x5\xa2\xe6\x23\xaa\x7b\xb0\xb4\xad\xe9\xb4\x19\x0\x7b\xd4\xc5\xf7\x21\x3d\xd4\x74\x5a\x49\xac\xa5\xd6\xb\x1b\xef\xd7\x62\x42\xb5\xa8\xc4\x3e\x23\xcb\x5c\xa2\xfa\x8f\x34\x2c\xcf\xe1\x62\xc\x69\x83\x8c\x99\xc6\xc4\x7a\x5e\xe6\xff\xe3\xa\x2c\x58\x44\x7d\x4a\x46\xb4\x92\xe4\x64\x7f\x88\xdf\x3\x18\x50\x8b\x1a\x3\x6a\xa8\xc7\x95\xd4\x5a\x6a\x3d\x2f\x87\x28\xf8\x43\x58\xb2\x26\x87\xba\xa6\x2a\x21\x18\xac\xa5\xd6\x33\x32\x12\x8c\xe6\x14\x7c\xd\xca\xcf\x29\x79\x1a\x86\x16\x38\xb4\xc4\xc8\x21\x60\x3\x8a\x63\xea\x38\x64\x44\x15\xf7\xd8\xa2\x95\x34\x5f\xfd\xda\xcc\xea\xe3\x2b\x2f\x78\x52\xfd\x63\x8b\xe2\x3a\xe4\xa9\x31\x19\xb\xd\x99\x13\xfc\x27\x19\x93\x71\x5c\x4b\x8e\x89\x79\x2a\x16\x1c\x6a\x3f\xd3\x54\x5a\xc9\x72\x5\xd7\x66\x14\xf4\x4\x3f\xae\xc3\x97\xc3\xd\xc8\xd3\x17\x2e\x35\x1c\xcd\x34\x2a\xb\x5c\xc9\x7\x73\x76\x91\xea\x83\xb8\x8a\xa9\x1c\xbe\x7\xb\xa6\xe5\x6a\xa6\xe1\x54\x72\x6b\x89\xf5\xc2\xc6\x3b\x73\x3\xa1\x2b\x30\xb2\xf\xc6\x2d\x40\x8e\x39\xb1\x55\xaa\xa8\xe6\x80\x2a\x9a\x31\x34\x2b\x79\xae\xe0\xd2\xec\x42\x38\xb0\x61\xe\x68\xcb\x18\x9a\x72\xc9\x89\x8c\xf1\x39\xc8\x3a\xc7\x86\x4b\x5e\x54\x8a\x3c\x42\xbc\x11\xb\x1d\x3a\xd0\xd8\x74\x95\x45\x11\x3a\xde\xb0\xfa\xdb\x2c\x94\x4f\x13\x7c\x9f\x41\x66\xc8\xd6\x5f\x49\xbe\x89\x77\x84\x4c\xd4\xbd\xd9\xef\xe8\xde\x3a\x14\xc\xea\xb8\x74\x20\x62\x25\x75\xca\x68\x3\x21\x34\x1b\x6c\xe9\xef\x14\x6c\x8f\xa0\x1c\x98\xa4\xd8\xc4\x18\xf9\x51\x7b\xeb\x75\x96\xd4\x24\x5f\x4e\x66\x62\x72\x89\x46\xc6\xb8\x9\x60\x1a\xd4\x1c\x2a\x3\xaa\xea\x95\xdc\x9\x5e\xea\x32\xc8\x8c\x97\x4c\x41\x55\x75\xfc\xe9\x34\x8\x17\x4e\x88\xa1\x3d\xf1\xf9\xcd\xc4\xe1\x1\x94\x6c\xca\xbe\x8\x3a\xf0\x56\x96\xe7\x46\xd4\x5e\xbb\x32\xd9\x13\x13\xb\x5b\xb4\xc3\x43\x7c\x5\x2\x82\xc2\xc3\xa\x78\x7e\x2a\xfa\xc4\xe\x19\xd3\xd5\x6f\xa0\x14\x75\xf\x5e\x81\x8c\xe3\x12\xdb\xe5\x51\x98\x91\xc5\x0\x23\x48\x51\x63\xc0\xf3\x5f\x46\x66\xff\xe2\xff\x9a\x2e\x38\xc5\x17\x7c\x75\x76\x47\x23\x9a\xe3\xeb\x5e\xfd\x4\x16\x23\xb\x38\xed\xd4\xd5\x5f\xa5\xe1\xec\x5c\xdd\xf8\x11\xac\x4c\xc\xcd\x70\xa9\x6d\xd9\x94\x85\xac\x98\xab\xf2\x97\x85\x13\x82\xee\x20\x8c\x16\x5a\xe4\xe5\xc9\x2c\x11\x3f\x86\x2\x8b\xf\x62\x13\xae\x50\x7c\x8d\x1b\xa7\x5b\x72\xad\x39\x95\xdc\x4a\xfd\x20\x91\x94\xc3\xba\xf0\x11\x14\x9f\x51\x5b\x1b\x6a\xaa\xd0\xcd\xdc\x59\xda\xb8\x7f\x4a\xdd\xf\x43\xa2\x3d\x97\xb8\x74\x13\xe\x3a\xf\x25\xb9\xb5\xdd\x92\x9a\x72\x44\xf3\xea\xaf\x13\x50\x8\xd9\xc2\xd2\x96\x31\x19\x1f\x52\xdb\xf3\xb8\x37\xc2\x17\x21\x3f\x9c\xe8\xba\x8\x1b\x71\xe6\xe5\x18\x81\x85\xc\xcb\x52\x5e\x22\xe0\x59\x8a\xfd\x8f\xaf\x40\x41\x73\x14\x9b\x5a\x94\xb8\x74\x50\x49\xaf\x25\xd6\x73\x5b\xc9\x4a\x42\x6\xcd\x91\x3d\x2a\x5e\x85\x9c\x1f\x7b\x95\xc\x43\xc8\xc1\x58\xf0\x3c\xe9\xac\xcf\x13\xe3\xea\x1d\x58\x9a\x59\x24\x2e\x43\xa1\x29\x35\xda\x75\xb9\xde\x6f\x75\x3b\xe8\xc\x2e\x41\x68\xdd\x28\x71\x23\x9f\xfb\xeb\x2\x7a\xf9\xf2\xe5\xcb\x64\xf5\xf7\x59\x58\x99\x97\xe5\xe6\x26\xdc\xa9\x4f\x52\x11\x9f\xd4\x21\xa3\x93\x43\xaa\xf3\xc5\x95\x36\x3e\x3c\x55\x1e\xad\xb5\x99\x88\x2c\x24\xf1\xe7\x9e\xe7\x32\x5c\xc3\x8d\xd3\x69\x60\xd9\xcf\xf3\xf2\x45\xc8\xb3\xbf\x62\x5b\xb2\x62\x5b\x18\x81\x6f\xcb\x2a\xe4\x78\x62\x1b\xd0\x60\xcb\xfc\x31\x4b\x5\x3\x3a\x24\x13\xdd\x55\x9e\x11\x7d\x42\x79\x8a\xca\xcb\x45\x8f\xf8\x90\xd1\xf0\x25\x28\x88\x3c\xa8\x19\x3\xfa\x82\x9f\x84\x19\x59\xa4\xc6\x16\xa3\xb0\xe9\x9f\x38\xa6\xe1\x27\x13\x3e\x5\x23\xf0\xe9\x3f\x89\x1f\xc2\xef\xce\x5f\xde\x4c\xf6\xbb\x6\x65\x8e\xb8\xed\x7d\xab\x44\xaf\x2c\xf1\x0\x28\x9\x72\xd7\xa3\x56\x7f\x93\x84\x34\x3f\xa\xca\x50\xe8\x3f\xde\x97\x94\x66\xf7\x60\xab\x2d\xa1\x4\xdb\x7a\x4e\xd8\x6e\x77\xeb\x7d\x94\xc\xc6\xad\x4e\xff\xde\x1d\x94\xa\x4\xe\x4\x21\x1d\x6\xdc\xde\x40\x19\x8c\xa0\x28\x14\xb4\x1e\x49\xcd\x7b\x77\x50\x36\x4a\xb9\xbd\x81\x16\xf0\x22\xe4\x39\x65\xab\xdb\x6d\xa3\x5c\xa0\xb3\xd7\x97\x5b\x9d\x1d\x94\xf\x74\xee\xc8\xdd\x83\x7d\x4\x81\x86\x3d\xa9\xd7\xab\xef\x48\xa8\x10\x20\xb6\x1e\xf7\xa5\x1e\x2a\x46\xcc\xba\xbd\x81\x16\x83\x29\xa4\xce\xc1\x1e\x2a\xe1\x25\x58\x14\x53\xf8\x46\x94\x63\xa4\x7b\x77\x10\x9a\x1a\x22\xb4\x2c\x45\x8\xf7\xee\x20\x5c\x6d\x40\x86\x87\x21\xc6\x50\x6a\xd7\xb7\xa4\xb6\xd2\xdd\x67\x1f\x4d\xbd\x8d\x12\x53\x9a\x2c\xfd\xf7\x41\x4b\x96\x9a\x28\x19\xa6\xed\x4b\xf5\xbe\xd4\x44\xa9\xaa\xa\x2b\xf3\x8e\xc0\xb9\x9f\x50\x28\x16\x92\x27\xc4\x2\xd7\x15\x8f\x85\xea\x9f\x93\xb0\x3c\xa7\xc\x98\x3b\xc9\x7f\x42\x46\xc4\xb2\x48\xc5\xd7\xe7\xd6\x13\x3c\xb2\x67\x8a\x23\x2e\x17\x2e\x1b\x53\x27\x94\x8d\x4c\xc5\x4c\xc0\xfe\xcf\xcc\x71\x2d\x2a\x9a\x7b\xa7\xa9\x68\x38\xed\xcd\x8e\xed\xcc\x9c\x63\xfb\x33\x58\x9a\x51\x74\xea\xe3\xf3\xff\x12\x50\x39\xc9\x39\xaf\x49\x89\xc9\x48\x4a\xfc\x2c\xee\xc1\xcb\x27\x6f\xc2\xcc\x5e\x7f\x9b\x80\x73\xf3\xdb\x83\xb9\x36\x7c\xe\xd9\x31\x75\x8f\x4c\xbf\x10\xbe\x3a\xa7\xbc\x62\xec\xf8\x66\x7b\x52\xe1\xfa\x2c\x75\x52\x8d\x2f\xac\x99\xb1\xf4\x87\x49\x38\x3b\x57\xf9\x5c\x43\xdf\x5\xd0\xc\x6b\xe2\x8a\x62\x57\x64\xe2\x3c\xa7\xf0\xe4\xc5\xb2\xec\xc4\xd\xf8\xe2\x10\x5\x41\xe2\x80\xfb\x53\x43\xd3\xdc\xd0\xf7\x4e\x58\xe9\x4c\x60\x7e\xc\x48\xd5\x35\x6a\xb8\x8a\xe3\xda\x94\x8c\x35\x63\x24\xce\xd9\xcd\xcc\x90\xe8\xe\x95\xcb\x82\xdd\xf3\xb9\x4c\x82\x7\x90\x1d\x92\xc8\x46\x24\x4\x3b\x90\xa8\xfe\x38\xf\x85\x50\x33\x85\x2f\x43\xf1\x9\x79\x46\x14\xbf\x41\x16\x9e\x28\x30\xda\xbe\xd7\x24\x7f\xc\x2b\x1c\x62\x4e\x5c\x6a\x2b\xaa\x4e\x1c\x87\x3b\x2d\xc7\xa1\x98\xf1\xba\x8c\xd5\xf0\x39\xf8\x2e\x2c\x73\x89\xf1\x44\x77\x35\x4b\xa7\xa\x6b\xd9\x1d\x7e\xe4\x4\x96\x2d\x31\xc4\x9e\x7\x60\x16\x39\xb8\x9\xef\x72\xb1\x11\x35\xa8\x4d\x5c\xaa\xd0\xaf\x27\x44\x77\x14\x62\xc\x94\x23\xe2\x1c\x55\x56\x82\xb2\xe4\x2\x3\xee\x78\x38\x89\xc3\xea\xc6\xe0\x1\x71\x8e\xf0\x26\x9c\xe3\x5a\x1c\xd7\xd6\x8c\x91\xa2\x1e\x51\xf5\xa9\x32\x71\x87\xf7\x2b\x17\xc3\xf3\x73\xb\x7b\x1c\xd3\x60\x90\x3\x77\x78\x1f\xf7\xa0\xc8\x36\x63\xac\x7d\x43\x95\xa1\x69\xf3\x33\xb4\x34\x27\x35\x85\x3c\x58\xeb\x7a\x2\x7b\xe6\x80\x6e\x66\x7a\xfb\x92\xd4\x94\xb\xbe\x96\x6d\xd3\x66\x1\x35\x32\x3\x7\x17\x44\x40\x8d\x4c\xdf\xbd\x77\x61\x59\x55\xc5\x9a\x35\x55\xf1\x1a\x6b\xa7\x82\x22\xce\x52\xd5\x1d\x1\xf0\x62\xdc\xc1\x9f\xc2\xd9\xa9\xb3\xc2\x82\x4b\x33\xab\x8c\x8b\xde\x85\x65\xeb\x78\x56\x10\x47\x66\xb4\x8e\xe3\x62\x9f\xc0\x8a\x75\x64\xcd\xca\xdd\x8\xcb\x61\xeb\xc8\x8a\xb\x7e\xc0\x6f\x59\x6c\xaa\xf2\xea\xf0\x7c\x18\x1e\x62\xe0\x1a\x20\x55\x55\xa8\x41\xe\x75\xaa\x10\x9b\x1a\xc4\xa9\x5c\xe2\xe0\xb4\x6b\x4f\xa8\x5c\x52\x55\x89\x33\xeb\x9c\x87\x6f\xc0\x92\x79\xf8\x44\x15\x11\xa9\x58\x36\x1d\x6a\x2f\x2a\xef\x73\xf7\x96\x19\x83\xc7\xe3\x3e\x27\xe3\xeb\x80\x54\xe7\x88\xd8\x16\x4f\xc9\x8e\x45\x54\x5a\xf9\x40\x40\x5\xbd\xe3\x93\xd9\x17\xe1\x3c\xd7\x86\xae\xaf\xf1\x9a\xf8\x22\x38\xcd\xd3\xb6\xe\x88\x79\x22\x32\xf1\x3a\x87\x95\xac\x23\x2b\x3c\xef\x15\x58\x64\xc8\xe9\xa4\xd7\x45\xe1\x66\x1d\x85\x66\xbc\x3\xe7\x18\x68\x4c\x5d\x32\x20\x2e\x9\xa1\x3f\xe2\x68\xe6\xf6\x3d\x8f\x19\xb1\xd3\x9e\x1c\x1e\x7\x81\x75\x53\xd8\xc9\x68\x7e\x68\xbd\xb5\x6e\xaa\xba\x9\xc5\x70\xdc\xe3\x3c\x88\xc8\x47\x9\x56\x4\x35\xba\x4d\x56\xbe\x7c\x25\xa1\x24\x2b\xa3\xda\xad\xbe\xa4\xc8\x7\x9d\x7e\x6b\x4f\x42\xa9\x50\x61\xbf\x9b\xce\x5d\x45\xd7\xaa\xbf\x4b\x41\x29\xda\x5b\xe3\xff\x80\xf3\xfe\x15\x99\x43\x5d\xe5\xb9\x66\xf3\xf\x72\x4c\xc4\xe1\x18\xc4\xcf\x8a\x87\xea\x51\xf7\x4b\xcd\x66\x9f\xdb\x98\xb8\xb8\xd\x97\xc\x53\x71\x5c\x62\xc\x88\x3d\x50\xa6\x97\x93\xa\x51\x55\xea\x38\xa6\x38\x8\x3\x2d\xef\x18\x66\xcf\x3\x4f\x4f\x88\xba\x7\x8d\x85\x6f\xea\xa4\xf0\xbd\x8\xf9\x31\xb1\x14\x6a\xb8\xf6\x31\xaf\xcf\x73\x72\x6e\x4c\x2c\x89\x8d\xf1\x43\xb8\x3a\x85\x2a\x3a\x1d\x11\xf5\x58\xe1\xc5\x38\xbf\xe8\x51\x54\xd3\x18\xea\x9a\xea\x3a\x3c\x3f\x88\x1c\x57\x9d\x4a\xb4\xb9\xc0\xae\x63\x1a\xbc\x6\x6f\xf8\xe8\xb7\xb7\xc3\xd1\x5d\x4a\xa3\xcc\x6e\x3a\x97\x41\xd9\xdd\x74\x2e\x8b\x16\x76\xd3\xb9\x1c\xca\xef\xa6\x73\x79\x4\xd5\xff\xcf\x43\x31\xdc\x19\xb0\x46\x4b\xe5\x67\x63\x82\x67\xcf\x2b\xaf\xec\x23\x6a\xd\x76\x68\x6e\x66\x45\x19\x2e\xb\x49\x56\xb0\xb0\xb0\xa6\xa2\xec\xc9\xc9\xde\x8\xef\x40\xf6\x89\xc3\x75\x67\xb9\xee\xf7\x5f\xad\x7b\xb7\xc7\x95\xe7\x77\x7b\x4a\xa7\x2b\xef\xd5\xdb\xb2\x27\x8e\x2f\x40\x5a\x27\xdf\x1c\x47\x8f\x57\x4e\xc2\x35\x28\x4f\xc\xd1\x75\xb3\xad\x62\xa8\x72\x18\x55\x9a\x72\xdb\xc\x7f\xca\xf0\xb8\x0\xe9\xe7\x94\x3c\x8d\x1e\x82\x9c\x84\xd7\xa1\x38\xa0\x87\x93\x91\x62\xd3\x1\x51\xdd\x68\xea\x2f\x70\x96\xcc\x39\xf8\xb\xc8\xb3\x3d\x32\xf8\x1e\x2f\x71\x17\xdc\x7c\xb5\xb\xbc\x2d\xf6\x85\xe4\xa9\x3c\xde\x85\xac\x4b\xec\x11\x75\x79\xe6\x2f\xcd\xb9\xae\x9a\xa3\xa9\xcf\x25\x98\x5b\x79\x8c\x7a\x1a\xf0\x3\x58\x10\xff\x39\x95\xe5\xb5\xd4\x9b\x2b\x93\x7d\xf1\xb7\x98\xb3\x6e\x41\x86\x7\x1b\x6\xf0\xc2\xd\x9d\xc1\x39\x48\x37\xba\x32\xcb\x5b\x8\x8a\x82\xaa\xec\xb7\xa4\x86\x84\x92\xd5\xbb\x90\x15\x11\xc4\x72\x5a\x10\x43\xe8\x8c\x37\xf4\x74\x24\x7c\xee\xc1\xde\x96\x24\xa3\x64\xf5\x0\xca\x31\xaf\xe3\xb3\xb0\x24\x4b\x7d\xa9\xc3\xba\x36\xe5\xa0\xf3\x45\xa7\xfb\x65\x7\x9d\x89\x92\xfd\x4\x99\xc0\x2b\x80\xa6\xe4\x5e\xf7\x40\xe6\xd6\xfc\x28\x9\x28\xee\x36\x7c\x1e\x96\xfb\x75\x79\x47\xea\x2b\xa2\x13\xd\x54\xaf\x0\xa\x33\xb6\x5b\xbc\xd1\xbe\x4\x17\xc3\x54\xe9\x51\x5f\xea\xf4\xf8\xe4\xf5\xce\xe\xcb\xd6\x31\x7d\x7e\xef\x9b\x62\xa6\x46\xf5\x49\xed\x26\x4a\xc7\xc9\xdd\x8e\xd4\xdd\x46\x99\xf8\xec\xbc\x1f\xce\xe2\x55\x38\x17\xa7\x2a\x52\xa7\x2f\x3f\x46\xb\xf1\x89\x7b\x92\xfc\xb0\xd5\x90\x50\xe\x9f\x3\x1c\xb5\xa8\xff\xa0\xdb\x44\xf9\x99\xfc\x54\x75\xa0\x18\x6e\x4a\xbf\x97\xd4\x58\xfd\x49\x12\xa\xa1\x26\x93\x75\x7\x44\xd7\xcd\xe7\xa\xd1\x35\xe2\x78\xd9\xb\x38\xa9\xce\x28\xa7\xcd\x16\xa7\x3f\x2f\xb2\xff\x8e\xe7\x45\x6\x65\xab\x3f\x4f\x0\x8a\x77\x8f\xb1\xe5\x27\x4e\x5a\xfe\xf7\xb2\x77\x3f\x4b\x40\x29\xda\x32\xc6\xcc\xbb\xfc\x2f\x35\xef\x4f\x49\x58\x8c\x34\x8a\xa7\xb5\xee\x6b\x58\xd2\x6\x74\x6c\x99\x2e\x35\xd4\x63\x45\xa7\xcf\xa8\x5e\xa9\xf2\x14\x7f\xeb\xd5\xad\x68\xad\x35\x95\x6b\x33\xb1\xcd\xe5\x56\x53\xda\xdb\xef\xf6\xa5\x4e\xe3\xb1\x9f\x5d\x64\xa4\xc5\x60\x6f\x31\x69\xef\x3\x8a\x1b\xc5\x72\xc5\x1c\xb3\xd0\x19\xbc\xc\xe5\x4e\x57\xe9\xb5\x9a\x92\x22\x6d\x6f\x4b\x8d\x7e\x4f\x5c\x2e\x6\xe8\x3e\x4a\x86\x5d\xfc\xd3\x14\x2c\xcf\xb1\x4\xd7\xbd\x6b\x1\x71\x53\x71\xf3\x34\xd6\xd7\x58\x61\xbe\x4f\x6c\xd7\xbb\x45\xb8\xe\xcc\x4b\x86\xcb\xea\x4\xdb\xbb\xb4\x15\x77\x5\xe5\x29\x5d\xdc\xdb\x7e\x4\xd8\x32\x1d\xcd\xd5\x9e\x51\x45\x33\xfc\x1b\xde\xf4\x5a\x62\x3d\x2d\x23\x9f\xd3\x32\xdc\x0\x6d\xd0\x11\x89\xa1\x59\x1d\x93\x92\x91\xcf\x9\xd0\x97\xa1\x38\x30\x27\xac\xa1\x12\x38\x96\x2d\x12\x72\x41\xd0\x2\x88\xd7\x2a\x4f\xaf\x96\x8b\x72\x41\xd0\x4\xe4\x1a\x94\xc9\x68\x64\x33\xe5\xbe\x22\xd1\xfc\x97\x2\x32\x7\xae\xee\x42\xce\xf7\x3\xab\x87\x99\x27\x14\x4b\xdc\x68\x25\xd7\xf3\x72\xce\xf0\x99\x97\xa1\xa8\x39\xca\xf4\x6d\x33\xb9\x96\x5c\xcf\xc9\x5\xcd\x9\xde\x48\xaa\xdf\x26\xa1\x14\x7d\xb5\xc5\x4d\xc8\xe9\xa6\xf7\xc8\x22\x7e\x32\xb0\xfe\x9a\x87\xde\x5a\xdb\xc3\xcb\x81\xe4\xea\x1f\x12\x90\xf3\xc9\xf8\x1c\xa4\x2d\xe2\x1e\x71\x75\x99\xad\x24\x4a\xc8\x7c\xcc\xe8\x8e\x45\xc4\x3b\x91\x47\x67\x63\xb6\xaf\x3a\x25\x3\x7e\xb3\x60\x8e\xc7\xd4\x70\x1d\x7f\x5f\x3d\x7a\xc3\x23\xe3\xf\x61\xc9\xb5\x89\xa6\x47\xb0\x69\x8e\x45\x3e\x23\x0\x6f\xc2\x5\x5f\xef\x80\xba\x44\x3d\xa2\x83\xa9\x50\x96\xdf\x20\x9e\xf7\x0\x4d\x8f\xef\xcb\x56\xff\x98\x84\x25\xff\x2e\x64\x10\x38\x6b\xf\x80\x18\x86\xe9\x86\xdd\x35\x1b\xca\x33\x72\xb5\x7a\x20\x24\x87\x14\xac\xfe\x2d\x1\x30\x65\x9d\xe8\xb7\x4b\x50\xf0\xde\xe4\xf9\xf\x3b\xc4\xf5\x19\x8\xd2\xb6\xa6\xf3\x4b\xce\x43\x3a\xd2\xc\xef\x75\x46\xc\xfc\x4b\xce\xf4\xf4\x79\x52\x86\x9c\x43\xc7\xc4\x70\x35\xd5\x7b\x6f\xb9\xf7\x46\xc6\xd7\x7a\x9e\xb4\x1c\xe8\xa9\xae\x43\xce\xa7\xb2\xc2\xaf\xd3\xed\x48\xe8\xc\x5e\x80\x54\x4f\xea\xa3\x4\x6b\x62\xeb\xed\x56\xbd\x87\x92\x5b\xff\xb\xcb\xaa\x39\x8e\x4f\xb8\x85\x62\x17\x88\xce\x83\xc4\x57\x37\x3d\xd0\xc8\xd4\x89\x31\xaa\x99\xf6\x68\xfa\xb3\x18\xd6\x6b\x38\xa1\x1f\xc7\x58\x87\x7f\x4f\x24\x7e\x91\x4c\xed\xec\x6f\xfd\x32\xb9\xba\x23\x4\xf7\xfd\xe5\xc8\x74\xa8\x53\x95\x19\xff\xcf\x0\x0\x0\xff\xff\x1a\x3c\x21\x80");
  }
}
