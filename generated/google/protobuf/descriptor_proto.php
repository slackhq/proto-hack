<?hh // strict
namespace google\protobuf;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/descriptor.proto

newtype Edition_enum_t as int = int;
abstract class Edition {
  const Edition_enum_t EDITION_UNKNOWN = 0;
  const Edition_enum_t EDITION_PROTO2 = 998;
  const Edition_enum_t EDITION_PROTO3 = 999;
  const Edition_enum_t EDITION_2023 = 1000;
  const Edition_enum_t EDITION_1_TEST_ONLY = 1;
  const Edition_enum_t EDITION_2_TEST_ONLY = 2;
  const Edition_enum_t EDITION_99997_TEST_ONLY = 99997;
  const Edition_enum_t EDITION_99998_TEST_ONLY = 99998;
  const Edition_enum_t EDITION_99999_TEST_ONLY = 99999;
  private static dict<int, string> $itos = dict[
    0 => 'EDITION_UNKNOWN',
    998 => 'EDITION_PROTO2',
    999 => 'EDITION_PROTO3',
    1000 => 'EDITION_2023',
    1 => 'EDITION_1_TEST_ONLY',
    2 => 'EDITION_2_TEST_ONLY',
    99997 => 'EDITION_99997_TEST_ONLY',
    99998 => 'EDITION_99998_TEST_ONLY',
    99999 => 'EDITION_99999_TEST_ONLY',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'EDITION_UNKNOWN' => 0,
    'EDITION_PROTO2' => 998,
    'EDITION_PROTO3' => 999,
    'EDITION_2023' => 1000,
    'EDITION_1_TEST_ONLY' => 1,
    'EDITION_2_TEST_ONLY' => 2,
    'EDITION_99997_TEST_ONLY' => 99997,
    'EDITION_99998_TEST_ONLY' => 99998,
    'EDITION_99999_TEST_ONLY' => 99999,
  ];
  public static function FromMixed(mixed $m): Edition_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): Edition_enum_t {
    return $i;
  }
}

class FileDescriptorSet implements \Protobuf\Message {
  public vec<\google\protobuf\FileDescriptorProto> $file;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'file' => vec<\google\protobuf\FileDescriptorProto>,
  ) $s = shape()) {
    $this->file = $s['file'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.FileDescriptorSet";
  }

  public static function ParseFrom(string $input): ?FileDescriptorSet {
    $msg = new FileDescriptorSet();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\FileDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->file []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->file as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('file', 'file', $this->file);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'file':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FileDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->file []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileDescriptorSet)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->file as $v) {
      $nv = new \google\protobuf\FileDescriptorProto();
      $nv->CopyFrom($v);
      $this->file []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class FileDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private string $package;
  private bool $was_package_set;
  public vec<string> $dependency;
  public vec<int> $public_dependency;
  public vec<int> $weak_dependency;
  public vec<\google\protobuf\DescriptorProto> $message_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\ServiceDescriptorProto> $service;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  private ?\google\protobuf\FileOptions $options;
  private bool $was_options_set;
  private ?\google\protobuf\SourceCodeInfo $source_code_info;
  private bool $was_source_code_info_set;
  private string $syntax;
  private bool $was_syntax_set;
  private \google\protobuf\Edition_enum_t $edition;
  private bool $was_edition_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'package' => string,
    ?'dependency' => vec<string>,
    ?'public_dependency' => vec<int>,
    ?'weak_dependency' => vec<int>,
    ?'message_type' => vec<\google\protobuf\DescriptorProto>,
    ?'enum_type' => vec<\google\protobuf\EnumDescriptorProto>,
    ?'service' => vec<\google\protobuf\ServiceDescriptorProto>,
    ?'extension' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'options' => ?\google\protobuf\FileOptions,
    ?'source_code_info' => ?\google\protobuf\SourceCodeInfo,
    ?'syntax' => string,
    ?'edition' => \google\protobuf\Edition_enum_t,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'package')) {
      $this->package = $s['package'];
      $this->was_package_set = true;
    } else {
      $this->package = '';
      $this->was_package_set = false;
    }
    $this->dependency = $s['dependency'] ?? vec[];
    $this->public_dependency = $s['public_dependency'] ?? vec[];
    $this->weak_dependency = $s['weak_dependency'] ?? vec[];
    $this->message_type = $s['message_type'] ?? vec[];
    $this->enum_type = $s['enum_type'] ?? vec[];
    $this->service = $s['service'] ?? vec[];
    $this->extension = $s['extension'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    if (Shapes::keyExists($s, 'source_code_info')) {
      $this->source_code_info = $s['source_code_info'];
      $this->was_source_code_info_set = true;
    } else {
      $this->source_code_info = null;
      $this->was_source_code_info_set = false;
    }
    if (Shapes::keyExists($s, 'syntax')) {
      $this->syntax = $s['syntax'];
      $this->was_syntax_set = true;
    } else {
      $this->syntax = '';
      $this->was_syntax_set = false;
    }
    if (Shapes::keyExists($s, 'edition')) {
      $this->edition = $s['edition'];
      $this->was_edition_set = true;
    } else {
      $this->edition = \google\protobuf\Edition::EDITION_UNKNOWN;
      $this->was_edition_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getPackage(): string {
    return $this->package;
  }

  public function setPackage(string $v): void {
    $this->package = $v;
    $this->was_package_set = true;
  }

  public function hasPackage(): bool {
    return $this->was_package_set;
  }

  public function getOptions(): ?\google\protobuf\FileOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\FileOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function getSourceCodeInfo(): ?\google\protobuf\SourceCodeInfo {
    return $this->source_code_info;
  }

  public function setSourceCodeInfo(?\google\protobuf\SourceCodeInfo $v): void {
    $this->source_code_info = $v;
    $this->was_source_code_info_set = true;
  }

  public function hasSourceCodeInfo(): bool {
    return $this->was_source_code_info_set;
  }

  public function getSyntax(): string {
    return $this->syntax;
  }

  public function setSyntax(string $v): void {
    $this->syntax = $v;
    $this->was_syntax_set = true;
  }

  public function hasSyntax(): bool {
    return $this->was_syntax_set;
  }

  public function getEdition(): \google\protobuf\Edition_enum_t {
    return $this->edition;
  }

  public function setEdition(\google\protobuf\Edition_enum_t $v): void {
    $this->edition = $v;
    $this->was_edition_set = true;
  }

  public function hasEdition(): bool {
    return $this->was_edition_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FileDescriptorProto";
  }

  public static function ParseFrom(string $input): ?FileDescriptorProto {
    $msg = new FileDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->package = $d->readString();
          $this->was_package_set = true;
          break;
        case 3:
          $this->dependency []= $d->readString();
          break;
        case 4:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->message_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\ServiceDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->service []= $obj;
          break;
        case 7:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 8:
          if ($this->options is null) {
            $this->options = new \google\protobuf\FileOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          if ($this->source_code_info is null) {
            $this->source_code_info = new \google\protobuf\SourceCodeInfo();
            $this->was_source_code_info_set = true;
          }
          $this->source_code_info->MergeFrom($d->readDecoder());
          break;
        case 10:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->public_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->public_dependency []= $d->readVarint32Signed();
          }
          break;
        case 11:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->weak_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->weak_dependency []= $d->readVarint32Signed();
          }
          break;
        case 12:
          $this->syntax = $d->readString();
          $this->was_syntax_set = true;
          break;
        case 14:
          $this->edition = \google\protobuf\Edition::FromInt($d->readVarint());
          $this->was_edition_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_package_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->package);
    }
    foreach ($this->dependency as $elem) {
      $e->writeTag(3, 2);
      $e->writeString($elem);
    }
    foreach ($this->message_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->service as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 7);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 8);
      }
    }
    $msg = $this->source_code_info;
    if ($msg != null) {
      if ($this->was_source_code_info_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 9);
      }
    }
    foreach ($this->public_dependency as $elem) {
      $e->writeTag(10, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->weak_dependency as $elem) {
      $e->writeTag(11, 0);
      $e->writeVarint($elem);
    }
    if ($this->was_syntax_set) {
      $e->writeTag(12, 2);
      $e->writeString($this->syntax);
    }
    if ($this->was_edition_set) {
      $e->writeTag(14, 0);
      $e->writeVarint($this->edition);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasPackage()) {
      $e->writeString('package', 'package', $this->package, false);
    }
    $e->writePrimitiveList('dependency', 'dependency', $this->dependency);
    $e->writeMessageList('message_type', 'messageType', $this->message_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('service', 'service', $this->service);
    $e->writeMessageList('extension', 'extension', $this->extension);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    if ($this->hasSourceCodeInfo()) {
      $e->writeMessage('source_code_info', 'sourceCodeInfo', $this->source_code_info, false);
    }
    $e->writePrimitiveList('public_dependency', 'publicDependency', $this->public_dependency);
    $e->writePrimitiveList('weak_dependency', 'weakDependency', $this->weak_dependency);
    if ($this->hasSyntax()) {
      $e->writeString('syntax', 'syntax', $this->syntax, false);
    }
    if ($this->hasEdition()) {
      $e->writeEnum('edition', 'edition', \google\protobuf\Edition::ToStringDict(), $this->edition, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'package':
          $this->package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_package_set = true;
          break;
        case 'dependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->dependency []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'message_type': case 'messageType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->message_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'service':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\ServiceDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->service []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\FileOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'source_code_info': case 'sourceCodeInfo':
          if ($v is null) break;
          if ($this->source_code_info is null) {
            $this->source_code_info = new \google\protobuf\SourceCodeInfo();
            $this->was_source_code_info_set = true;
          }
          $this->source_code_info->MergeJsonFrom($v);
          break;
        case 'public_dependency': case 'publicDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->public_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'weak_dependency': case 'weakDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->weak_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'syntax':
          $this->syntax = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_syntax_set = true;
          break;
        case 'edition':
          $this->edition = \google\protobuf\Edition::FromMixed($v);
          $this->was_edition_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasPackage()) {
      $this->setPackage($o->getPackage());
    }
    $this->dependency = $o->dependency;
    foreach ($o->message_type as $v) {
      $nv = new \google\protobuf\DescriptorProto();
      $nv->CopyFrom($v);
      $this->message_type []= $nv;
    }
    foreach ($o->enum_type as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto();
      $nv->CopyFrom($v);
      $this->enum_type []= $nv;
    }
    foreach ($o->service as $v) {
      $nv = new \google\protobuf\ServiceDescriptorProto();
      $nv->CopyFrom($v);
      $this->service []= $nv;
    }
    foreach ($o->extension as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->extension []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FileOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $tmp = $o->source_code_info;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\SourceCodeInfo();
      $nv->CopyFrom($tmp);
      $this->setSourceCodeInfo($nv);
    } else if ($o->hasSourceCodeInfo()) {
      $this->setSourceCodeInfo(null);
    }
    $this->public_dependency = $o->public_dependency;
    $this->weak_dependency = $o->weak_dependency;
    if ($o->hasSyntax()) {
      $this->setSyntax($o->getSyntax());
    }
    if ($o->hasEdition()) {
      $this->setEdition($o->getEdition());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto_ExtensionRange implements \Protobuf\Message {
  private int $start;
  private bool $was_start_set;
  private int $end;
  private bool $was_end_set;
  private ?\google\protobuf\ExtensionRangeOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
    ?'options' => ?\google\protobuf\ExtensionRangeOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'start')) {
      $this->start = $s['start'];
      $this->was_start_set = true;
    } else {
      $this->start = 0;
      $this->was_start_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getStart(): int {
    return $this->start;
  }

  public function setStart(int $v): void {
    $this->start = $v;
    $this->was_start_set = true;
  }

  public function hasStart(): bool {
    return $this->was_start_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function getOptions(): ?\google\protobuf\ExtensionRangeOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\ExtensionRangeOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto.ExtensionRange";
  }

  public static function ParseFrom(string $input): ?DescriptorProto_ExtensionRange {
    $msg = new DescriptorProto_ExtensionRange();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          $this->was_start_set = true;
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\ExtensionRangeOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_start_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->was_end_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasStart()) {
      $e->writeInt32('start', 'start', $this->start, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_start_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\ExtensionRangeOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto_ExtensionRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasStart()) {
      $this->setStart($o->getStart());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\ExtensionRangeOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto_ReservedRange implements \Protobuf\Message {
  private int $start;
  private bool $was_start_set;
  private int $end;
  private bool $was_end_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'start')) {
      $this->start = $s['start'];
      $this->was_start_set = true;
    } else {
      $this->start = 0;
      $this->was_start_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getStart(): int {
    return $this->start;
  }

  public function setStart(int $v): void {
    $this->start = $v;
    $this->was_start_set = true;
  }

  public function hasStart(): bool {
    return $this->was_start_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto.ReservedRange";
  }

  public static function ParseFrom(string $input): ?DescriptorProto_ReservedRange {
    $msg = new DescriptorProto_ReservedRange();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          $this->was_start_set = true;
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_start_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->was_end_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasStart()) {
      $e->writeInt32('start', 'start', $this->start, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_start_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto_ReservedRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasStart()) {
      $this->setStart($o->getStart());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  public vec<\google\protobuf\FieldDescriptorProto> $field;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  public vec<\google\protobuf\DescriptorProto> $nested_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\DescriptorProto_ExtensionRange> $extension_range;
  public vec<\google\protobuf\OneofDescriptorProto> $oneof_decl;
  private ?\google\protobuf\MessageOptions $options;
  private bool $was_options_set;
  public vec<\google\protobuf\DescriptorProto_ReservedRange> $reserved_range;
  public vec<string> $reserved_name;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'field' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'extension' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'nested_type' => vec<\google\protobuf\DescriptorProto>,
    ?'enum_type' => vec<\google\protobuf\EnumDescriptorProto>,
    ?'extension_range' => vec<\google\protobuf\DescriptorProto_ExtensionRange>,
    ?'oneof_decl' => vec<\google\protobuf\OneofDescriptorProto>,
    ?'options' => ?\google\protobuf\MessageOptions,
    ?'reserved_range' => vec<\google\protobuf\DescriptorProto_ReservedRange>,
    ?'reserved_name' => vec<string>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    $this->field = $s['field'] ?? vec[];
    $this->extension = $s['extension'] ?? vec[];
    $this->nested_type = $s['nested_type'] ?? vec[];
    $this->enum_type = $s['enum_type'] ?? vec[];
    $this->extension_range = $s['extension_range'] ?? vec[];
    $this->oneof_decl = $s['oneof_decl'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->reserved_range = $s['reserved_range'] ?? vec[];
    $this->reserved_name = $s['reserved_name'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\MessageOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\MessageOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto";
  }

  public static function ParseFrom(string $input): ?DescriptorProto {
    $msg = new DescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->field []= $obj;
          break;
        case 3:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->nested_type []= $obj;
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
          $obj->MergeFrom($d->readDecoder());
          $this->extension_range []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 7:
          if ($this->options is null) {
            $this->options = new \google\protobuf\MessageOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 8:
          $obj = new \google\protobuf\OneofDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->oneof_decl []= $obj;
          break;
        case 9:
          $obj = new \google\protobuf\DescriptorProto_ReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 10:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->field as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    foreach ($this->nested_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->extension_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 7);
      }
    }
    foreach ($this->oneof_decl as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 9);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(10, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    $e->writeMessageList('field', 'field', $this->field);
    $e->writeMessageList('nested_type', 'nestedType', $this->nested_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('extension_range', 'extensionRange', $this->extension_range);
    $e->writeMessageList('extension', 'extension', $this->extension);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    $e->writeMessageList('oneof_decl', 'oneofDecl', $this->oneof_decl);
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'field':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->field []= $obj;
          }
          break;
        case 'nested_type': case 'nestedType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->nested_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'extension_range': case 'extensionRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
            $obj->MergeJsonFrom($vv);
            $this->extension_range []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\MessageOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_decl': case 'oneofDecl':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\OneofDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->oneof_decl []= $obj;
          }
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    foreach ($o->field as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->field []= $nv;
    }
    foreach ($o->nested_type as $v) {
      $nv = new \google\protobuf\DescriptorProto();
      $nv->CopyFrom($v);
      $this->nested_type []= $nv;
    }
    foreach ($o->enum_type as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto();
      $nv->CopyFrom($v);
      $this->enum_type []= $nv;
    }
    foreach ($o->extension_range as $v) {
      $nv = new \google\protobuf\DescriptorProto_ExtensionRange();
      $nv->CopyFrom($v);
      $this->extension_range []= $nv;
    }
    foreach ($o->extension as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->extension []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\MessageOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    foreach ($o->oneof_decl as $v) {
      $nv = new \google\protobuf\OneofDescriptorProto();
      $nv->CopyFrom($v);
      $this->oneof_decl []= $nv;
    }
    foreach ($o->reserved_range as $v) {
      $nv = new \google\protobuf\DescriptorProto_ReservedRange();
      $nv->CopyFrom($v);
      $this->reserved_range []= $nv;
    }
    $this->reserved_name = $o->reserved_name;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype ExtensionRangeOptions_VerificationState_enum_t as int = int;
abstract class ExtensionRangeOptions_VerificationState {
  const ExtensionRangeOptions_VerificationState_enum_t DECLARATION = 0;
  const ExtensionRangeOptions_VerificationState_enum_t UNVERIFIED = 1;
  private static dict<int, string> $itos = dict[
    0 => 'DECLARATION',
    1 => 'UNVERIFIED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'DECLARATION' => 0,
    'UNVERIFIED' => 1,
  ];
  public static function FromMixed(mixed $m): ExtensionRangeOptions_VerificationState_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): ExtensionRangeOptions_VerificationState_enum_t {
    return $i;
  }
}

class ExtensionRangeOptions_Declaration implements \Protobuf\Message {
  private int $number;
  private bool $was_number_set;
  private string $full_name;
  private bool $was_full_name_set;
  private string $type;
  private bool $was_type_set;
  private bool $reserved;
  private bool $was_reserved_set;
  private bool $repeated;
  private bool $was_repeated_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'number' => int,
    ?'full_name' => string,
    ?'type' => string,
    ?'reserved' => bool,
    ?'repeated' => bool,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'number')) {
      $this->number = $s['number'];
      $this->was_number_set = true;
    } else {
      $this->number = 0;
      $this->was_number_set = false;
    }
    if (Shapes::keyExists($s, 'full_name')) {
      $this->full_name = $s['full_name'];
      $this->was_full_name_set = true;
    } else {
      $this->full_name = '';
      $this->was_full_name_set = false;
    }
    if (Shapes::keyExists($s, 'type')) {
      $this->type = $s['type'];
      $this->was_type_set = true;
    } else {
      $this->type = '';
      $this->was_type_set = false;
    }
    if (Shapes::keyExists($s, 'reserved')) {
      $this->reserved = $s['reserved'];
      $this->was_reserved_set = true;
    } else {
      $this->reserved = false;
      $this->was_reserved_set = false;
    }
    if (Shapes::keyExists($s, 'repeated')) {
      $this->repeated = $s['repeated'];
      $this->was_repeated_set = true;
    } else {
      $this->repeated = false;
      $this->was_repeated_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getNumber(): int {
    return $this->number;
  }

  public function setNumber(int $v): void {
    $this->number = $v;
    $this->was_number_set = true;
  }

  public function hasNumber(): bool {
    return $this->was_number_set;
  }

  public function getFullName(): string {
    return $this->full_name;
  }

  public function setFullName(string $v): void {
    $this->full_name = $v;
    $this->was_full_name_set = true;
  }

  public function hasFullName(): bool {
    return $this->was_full_name_set;
  }

  public function getType(): string {
    return $this->type;
  }

  public function setType(string $v): void {
    $this->type = $v;
    $this->was_type_set = true;
  }

  public function hasType(): bool {
    return $this->was_type_set;
  }

  public function getReserved(): bool {
    return $this->reserved;
  }

  public function setReserved(bool $v): void {
    $this->reserved = $v;
    $this->was_reserved_set = true;
  }

  public function hasReserved(): bool {
    return $this->was_reserved_set;
  }

  public function getRepeated(): bool {
    return $this->repeated;
  }

  public function setRepeated(bool $v): void {
    $this->repeated = $v;
    $this->was_repeated_set = true;
  }

  public function hasRepeated(): bool {
    return $this->was_repeated_set;
  }

  public function MessageName(): string {
    return "google.protobuf.ExtensionRangeOptions.Declaration";
  }

  public static function ParseFrom(string $input): ?ExtensionRangeOptions_Declaration {
    $msg = new ExtensionRangeOptions_Declaration();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->number = $d->readVarint32Signed();
          $this->was_number_set = true;
          break;
        case 2:
          $this->full_name = $d->readString();
          $this->was_full_name_set = true;
          break;
        case 3:
          $this->type = $d->readString();
          $this->was_type_set = true;
          break;
        case 5:
          $this->reserved = $d->readBool();
          $this->was_reserved_set = true;
          break;
        case 6:
          $this->repeated = $d->readBool();
          $this->was_repeated_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_number_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->number);
    }
    if ($this->was_full_name_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->full_name);
    }
    if ($this->was_type_set) {
      $e->writeTag(3, 2);
      $e->writeString($this->type);
    }
    if ($this->was_reserved_set) {
      $e->writeTag(5, 0);
      $e->writeBool($this->reserved);
    }
    if ($this->was_repeated_set) {
      $e->writeTag(6, 0);
      $e->writeBool($this->repeated);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasNumber()) {
      $e->writeInt32('number', 'number', $this->number, false);
    }
    if ($this->hasFullName()) {
      $e->writeString('full_name', 'fullName', $this->full_name, false);
    }
    if ($this->hasType()) {
      $e->writeString('type', 'type', $this->type, false);
    }
    if ($this->hasReserved()) {
      $e->writeBool('reserved', 'reserved', $this->reserved, false);
    }
    if ($this->hasRepeated()) {
      $e->writeBool('repeated', 'repeated', $this->repeated, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_number_set = true;
          break;
        case 'full_name': case 'fullName':
          $this->full_name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_full_name_set = true;
          break;
        case 'type':
          $this->type = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_type_set = true;
          break;
        case 'reserved':
          $this->reserved = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_reserved_set = true;
          break;
        case 'repeated':
          $this->repeated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_repeated_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ExtensionRangeOptions_Declaration)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasNumber()) {
      $this->setNumber($o->getNumber());
    }
    if ($o->hasFullName()) {
      $this->setFullName($o->getFullName());
    }
    if ($o->hasType()) {
      $this->setType($o->getType());
    }
    if ($o->hasReserved()) {
      $this->setReserved($o->getReserved());
    }
    if ($o->hasRepeated()) {
      $this->setRepeated($o->getRepeated());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ExtensionRangeOptions implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  public vec<\google\protobuf\ExtensionRangeOptions_Declaration> $declaration;
  private ?\google\protobuf\FeatureSet $features;
  private bool $was_features_set;
  private \google\protobuf\ExtensionRangeOptions_VerificationState_enum_t $verification;
  private bool $was_verification_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
    ?'declaration' => vec<\google\protobuf\ExtensionRangeOptions_Declaration>,
    ?'features' => ?\google\protobuf\FeatureSet,
    ?'verification' => \google\protobuf\ExtensionRangeOptions_VerificationState_enum_t,
  ) $s = shape()) {
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->declaration = $s['declaration'] ?? vec[];
    if (Shapes::keyExists($s, 'features')) {
      $this->features = $s['features'];
      $this->was_features_set = true;
    } else {
      $this->features = null;
      $this->was_features_set = false;
    }
    if (Shapes::keyExists($s, 'verification')) {
      $this->verification = $s['verification'];
      $this->was_verification_set = true;
    } else {
      $this->verification = \google\protobuf\ExtensionRangeOptions_VerificationState::UNVERIFIED;
      $this->was_verification_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getFeatures(): ?\google\protobuf\FeatureSet {
    return $this->features;
  }

  public function setFeatures(?\google\protobuf\FeatureSet $v): void {
    $this->features = $v;
    $this->was_features_set = true;
  }

  public function hasFeatures(): bool {
    return $this->was_features_set;
  }

  public function getVerification(): \google\protobuf\ExtensionRangeOptions_VerificationState_enum_t {
    return $this->verification;
  }

  public function setVerification(\google\protobuf\ExtensionRangeOptions_VerificationState_enum_t $v): void {
    $this->verification = $v;
    $this->was_verification_set = true;
  }

  public function hasVerification(): bool {
    return $this->was_verification_set;
  }

  public function MessageName(): string {
    return "google.protobuf.ExtensionRangeOptions";
  }

  public static function ParseFrom(string $input): ?ExtensionRangeOptions {
    $msg = new ExtensionRangeOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $obj = new \google\protobuf\ExtensionRangeOptions_Declaration();
          $obj->MergeFrom($d->readDecoder());
          $this->declaration []= $obj;
          break;
        case 3:
          $this->verification = \google\protobuf\ExtensionRangeOptions_VerificationState::FromInt($d->readVarint());
          $this->was_verification_set = true;
          break;
        case 50:
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeFrom($d->readDecoder());
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->declaration as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    if ($this->was_verification_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->verification);
    }
    $msg = $this->features;
    if ($msg != null) {
      if ($this->was_features_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 50);
      }
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('declaration', 'declaration', $this->declaration);
    if ($this->hasVerification()) {
      $e->writeEnum('verification', 'verification', \google\protobuf\ExtensionRangeOptions_VerificationState::ToStringDict(), $this->verification, false);
    }
    if ($this->hasFeatures()) {
      $e->writeMessage('features', 'features', $this->features, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'declaration':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\ExtensionRangeOptions_Declaration();
            $obj->MergeJsonFrom($vv);
            $this->declaration []= $obj;
          }
          break;
        case 'verification':
          $this->verification = \google\protobuf\ExtensionRangeOptions_VerificationState::FromMixed($v);
          $this->was_verification_set = true;
          break;
        case 'features':
          if ($v is null) break;
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeJsonFrom($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ExtensionRangeOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->declaration as $v) {
      $nv = new \google\protobuf\ExtensionRangeOptions_Declaration();
      $nv->CopyFrom($v);
      $this->declaration []= $nv;
    }
    if ($o->hasVerification()) {
      $this->setVerification($o->getVerification());
    }
    $tmp = $o->features;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FeatureSet();
      $nv->CopyFrom($tmp);
      $this->setFeatures($nv);
    } else if ($o->hasFeatures()) {
      $this->setFeatures(null);
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FieldDescriptorProto_Type_enum_t as int = int;
abstract class FieldDescriptorProto_Type {
  const FieldDescriptorProto_Type_enum_t TYPE_DOUBLE = 1;
  const FieldDescriptorProto_Type_enum_t TYPE_FLOAT = 2;
  const FieldDescriptorProto_Type_enum_t TYPE_INT64 = 3;
  const FieldDescriptorProto_Type_enum_t TYPE_UINT64 = 4;
  const FieldDescriptorProto_Type_enum_t TYPE_INT32 = 5;
  const FieldDescriptorProto_Type_enum_t TYPE_FIXED64 = 6;
  const FieldDescriptorProto_Type_enum_t TYPE_FIXED32 = 7;
  const FieldDescriptorProto_Type_enum_t TYPE_BOOL = 8;
  const FieldDescriptorProto_Type_enum_t TYPE_STRING = 9;
  const FieldDescriptorProto_Type_enum_t TYPE_GROUP = 10;
  const FieldDescriptorProto_Type_enum_t TYPE_MESSAGE = 11;
  const FieldDescriptorProto_Type_enum_t TYPE_BYTES = 12;
  const FieldDescriptorProto_Type_enum_t TYPE_UINT32 = 13;
  const FieldDescriptorProto_Type_enum_t TYPE_ENUM = 14;
  const FieldDescriptorProto_Type_enum_t TYPE_SFIXED32 = 15;
  const FieldDescriptorProto_Type_enum_t TYPE_SFIXED64 = 16;
  const FieldDescriptorProto_Type_enum_t TYPE_SINT32 = 17;
  const FieldDescriptorProto_Type_enum_t TYPE_SINT64 = 18;
  private static dict<int, string> $itos = dict[
    1 => 'TYPE_DOUBLE',
    2 => 'TYPE_FLOAT',
    3 => 'TYPE_INT64',
    4 => 'TYPE_UINT64',
    5 => 'TYPE_INT32',
    6 => 'TYPE_FIXED64',
    7 => 'TYPE_FIXED32',
    8 => 'TYPE_BOOL',
    9 => 'TYPE_STRING',
    10 => 'TYPE_GROUP',
    11 => 'TYPE_MESSAGE',
    12 => 'TYPE_BYTES',
    13 => 'TYPE_UINT32',
    14 => 'TYPE_ENUM',
    15 => 'TYPE_SFIXED32',
    16 => 'TYPE_SFIXED64',
    17 => 'TYPE_SINT32',
    18 => 'TYPE_SINT64',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'TYPE_DOUBLE' => 1,
    'TYPE_FLOAT' => 2,
    'TYPE_INT64' => 3,
    'TYPE_UINT64' => 4,
    'TYPE_INT32' => 5,
    'TYPE_FIXED64' => 6,
    'TYPE_FIXED32' => 7,
    'TYPE_BOOL' => 8,
    'TYPE_STRING' => 9,
    'TYPE_GROUP' => 10,
    'TYPE_MESSAGE' => 11,
    'TYPE_BYTES' => 12,
    'TYPE_UINT32' => 13,
    'TYPE_ENUM' => 14,
    'TYPE_SFIXED32' => 15,
    'TYPE_SFIXED64' => 16,
    'TYPE_SINT32' => 17,
    'TYPE_SINT64' => 18,
  ];
  public static function FromMixed(mixed $m): FieldDescriptorProto_Type_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldDescriptorProto_Type_enum_t {
    return $i;
  }
}

newtype FieldDescriptorProto_Label_enum_t as int = int;
abstract class FieldDescriptorProto_Label {
  const FieldDescriptorProto_Label_enum_t LABEL_OPTIONAL = 1;
  const FieldDescriptorProto_Label_enum_t LABEL_REPEATED = 3;
  const FieldDescriptorProto_Label_enum_t LABEL_REQUIRED = 2;
  private static dict<int, string> $itos = dict[
    1 => 'LABEL_OPTIONAL',
    3 => 'LABEL_REPEATED',
    2 => 'LABEL_REQUIRED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'LABEL_OPTIONAL' => 1,
    'LABEL_REPEATED' => 3,
    'LABEL_REQUIRED' => 2,
  ];
  public static function FromMixed(mixed $m): FieldDescriptorProto_Label_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldDescriptorProto_Label_enum_t {
    return $i;
  }
}

class FieldDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private int $number;
  private bool $was_number_set;
  private \google\protobuf\FieldDescriptorProto_Label_enum_t $label;
  private bool $was_label_set;
  private \google\protobuf\FieldDescriptorProto_Type_enum_t $type;
  private bool $was_type_set;
  private string $type_name;
  private bool $was_type_name_set;
  private string $extendee;
  private bool $was_extendee_set;
  private string $default_value;
  private bool $was_default_value_set;
  private int $oneof_index;
  private bool $was_oneof_index_set;
  private string $json_name;
  private bool $was_json_name_set;
  private ?\google\protobuf\FieldOptions $options;
  private bool $was_options_set;
  private bool $proto3_optional;
  private bool $was_proto3_optional_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'number' => int,
    ?'label' => \google\protobuf\FieldDescriptorProto_Label_enum_t,
    ?'type' => \google\protobuf\FieldDescriptorProto_Type_enum_t,
    ?'type_name' => string,
    ?'extendee' => string,
    ?'default_value' => string,
    ?'oneof_index' => int,
    ?'json_name' => string,
    ?'options' => ?\google\protobuf\FieldOptions,
    ?'proto3_optional' => bool,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'number')) {
      $this->number = $s['number'];
      $this->was_number_set = true;
    } else {
      $this->number = 0;
      $this->was_number_set = false;
    }
    if (Shapes::keyExists($s, 'label')) {
      $this->label = $s['label'];
      $this->was_label_set = true;
    } else {
      $this->label = \google\protobuf\FieldDescriptorProto_Label::LABEL_OPTIONAL;
      $this->was_label_set = false;
    }
    if (Shapes::keyExists($s, 'type')) {
      $this->type = $s['type'];
      $this->was_type_set = true;
    } else {
      $this->type = \google\protobuf\FieldDescriptorProto_Type::TYPE_DOUBLE;
      $this->was_type_set = false;
    }
    if (Shapes::keyExists($s, 'type_name')) {
      $this->type_name = $s['type_name'];
      $this->was_type_name_set = true;
    } else {
      $this->type_name = '';
      $this->was_type_name_set = false;
    }
    if (Shapes::keyExists($s, 'extendee')) {
      $this->extendee = $s['extendee'];
      $this->was_extendee_set = true;
    } else {
      $this->extendee = '';
      $this->was_extendee_set = false;
    }
    if (Shapes::keyExists($s, 'default_value')) {
      $this->default_value = $s['default_value'];
      $this->was_default_value_set = true;
    } else {
      $this->default_value = '';
      $this->was_default_value_set = false;
    }
    if (Shapes::keyExists($s, 'oneof_index')) {
      $this->oneof_index = $s['oneof_index'];
      $this->was_oneof_index_set = true;
    } else {
      $this->oneof_index = 0;
      $this->was_oneof_index_set = false;
    }
    if (Shapes::keyExists($s, 'json_name')) {
      $this->json_name = $s['json_name'];
      $this->was_json_name_set = true;
    } else {
      $this->json_name = '';
      $this->was_json_name_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    if (Shapes::keyExists($s, 'proto3_optional')) {
      $this->proto3_optional = $s['proto3_optional'];
      $this->was_proto3_optional_set = true;
    } else {
      $this->proto3_optional = false;
      $this->was_proto3_optional_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getNumber(): int {
    return $this->number;
  }

  public function setNumber(int $v): void {
    $this->number = $v;
    $this->was_number_set = true;
  }

  public function hasNumber(): bool {
    return $this->was_number_set;
  }

  public function getLabel(): \google\protobuf\FieldDescriptorProto_Label_enum_t {
    return $this->label;
  }

  public function setLabel(\google\protobuf\FieldDescriptorProto_Label_enum_t $v): void {
    $this->label = $v;
    $this->was_label_set = true;
  }

  public function hasLabel(): bool {
    return $this->was_label_set;
  }

  public function getType(): \google\protobuf\FieldDescriptorProto_Type_enum_t {
    return $this->type;
  }

  public function setType(\google\protobuf\FieldDescriptorProto_Type_enum_t $v): void {
    $this->type = $v;
    $this->was_type_set = true;
  }

  public function hasType(): bool {
    return $this->was_type_set;
  }

  public function getTypeName(): string {
    return $this->type_name;
  }

  public function setTypeName(string $v): void {
    $this->type_name = $v;
    $this->was_type_name_set = true;
  }

  public function hasTypeName(): bool {
    return $this->was_type_name_set;
  }

  public function getExtendee(): string {
    return $this->extendee;
  }

  public function setExtendee(string $v): void {
    $this->extendee = $v;
    $this->was_extendee_set = true;
  }

  public function hasExtendee(): bool {
    return $this->was_extendee_set;
  }

  public function getDefaultValue(): string {
    return $this->default_value;
  }

  public function setDefaultValue(string $v): void {
    $this->default_value = $v;
    $this->was_default_value_set = true;
  }

  public function hasDefaultValue(): bool {
    return $this->was_default_value_set;
  }

  public function getOneofIndex(): int {
    return $this->oneof_index;
  }

  public function setOneofIndex(int $v): void {
    $this->oneof_index = $v;
    $this->was_oneof_index_set = true;
  }

  public function hasOneofIndex(): bool {
    return $this->was_oneof_index_set;
  }

  public function getJsonName(): string {
    return $this->json_name;
  }

  public function setJsonName(string $v): void {
    $this->json_name = $v;
    $this->was_json_name_set = true;
  }

  public function hasJsonName(): bool {
    return $this->was_json_name_set;
  }

  public function getOptions(): ?\google\protobuf\FieldOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\FieldOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function getProto3Optional(): bool {
    return $this->proto3_optional;
  }

  public function setProto3Optional(bool $v): void {
    $this->proto3_optional = $v;
    $this->was_proto3_optional_set = true;
  }

  public function hasProto3Optional(): bool {
    return $this->was_proto3_optional_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FieldDescriptorProto";
  }

  public static function ParseFrom(string $input): ?FieldDescriptorProto {
    $msg = new FieldDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->extendee = $d->readString();
          $this->was_extendee_set = true;
          break;
        case 3:
          $this->number = $d->readVarint32Signed();
          $this->was_number_set = true;
          break;
        case 4:
          $this->label = \google\protobuf\FieldDescriptorProto_Label::FromInt($d->readVarint());
          $this->was_label_set = true;
          break;
        case 5:
          $this->type = \google\protobuf\FieldDescriptorProto_Type::FromInt($d->readVarint());
          $this->was_type_set = true;
          break;
        case 6:
          $this->type_name = $d->readString();
          $this->was_type_name_set = true;
          break;
        case 7:
          $this->default_value = $d->readString();
          $this->was_default_value_set = true;
          break;
        case 8:
          if ($this->options is null) {
            $this->options = new \google\protobuf\FieldOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          $this->oneof_index = $d->readVarint32Signed();
          $this->was_oneof_index_set = true;
          break;
        case 10:
          $this->json_name = $d->readString();
          $this->was_json_name_set = true;
          break;
        case 17:
          $this->proto3_optional = $d->readBool();
          $this->was_proto3_optional_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_extendee_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->extendee);
    }
    if ($this->was_number_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->number);
    }
    if ($this->was_label_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->label);
    }
    if ($this->was_type_set) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->type);
    }
    if ($this->was_type_name_set) {
      $e->writeTag(6, 2);
      $e->writeString($this->type_name);
    }
    if ($this->was_default_value_set) {
      $e->writeTag(7, 2);
      $e->writeString($this->default_value);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 8);
      }
    }
    if ($this->was_oneof_index_set) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->oneof_index);
    }
    if ($this->was_json_name_set) {
      $e->writeTag(10, 2);
      $e->writeString($this->json_name);
    }
    if ($this->was_proto3_optional_set) {
      $e->writeTag(17, 0);
      $e->writeBool($this->proto3_optional);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasExtendee()) {
      $e->writeString('extendee', 'extendee', $this->extendee, false);
    }
    if ($this->hasNumber()) {
      $e->writeInt32('number', 'number', $this->number, false);
    }
    if ($this->hasLabel()) {
      $e->writeEnum('label', 'label', \google\protobuf\FieldDescriptorProto_Label::ToStringDict(), $this->label, false);
    }
    if ($this->hasType()) {
      $e->writeEnum('type', 'type', \google\protobuf\FieldDescriptorProto_Type::ToStringDict(), $this->type, false);
    }
    if ($this->hasTypeName()) {
      $e->writeString('type_name', 'typeName', $this->type_name, false);
    }
    if ($this->hasDefaultValue()) {
      $e->writeString('default_value', 'defaultValue', $this->default_value, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    if ($this->hasOneofIndex()) {
      $e->writeInt32('oneof_index', 'oneofIndex', $this->oneof_index, false);
    }
    if ($this->hasJsonName()) {
      $e->writeString('json_name', 'jsonName', $this->json_name, false);
    }
    if ($this->hasProto3Optional()) {
      $e->writeBool('proto3_optional', 'proto3Optional', $this->proto3_optional, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'extendee':
          $this->extendee = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_extendee_set = true;
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_number_set = true;
          break;
        case 'label':
          $this->label = \google\protobuf\FieldDescriptorProto_Label::FromMixed($v);
          $this->was_label_set = true;
          break;
        case 'type':
          $this->type = \google\protobuf\FieldDescriptorProto_Type::FromMixed($v);
          $this->was_type_set = true;
          break;
        case 'type_name': case 'typeName':
          $this->type_name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_type_name_set = true;
          break;
        case 'default_value': case 'defaultValue':
          $this->default_value = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_default_value_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\FieldOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_index': case 'oneofIndex':
          $this->oneof_index = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_oneof_index_set = true;
          break;
        case 'json_name': case 'jsonName':
          $this->json_name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_json_name_set = true;
          break;
        case 'proto3_optional': case 'proto3Optional':
          $this->proto3_optional = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_proto3_optional_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FieldDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasExtendee()) {
      $this->setExtendee($o->getExtendee());
    }
    if ($o->hasNumber()) {
      $this->setNumber($o->getNumber());
    }
    if ($o->hasLabel()) {
      $this->setLabel($o->getLabel());
    }
    if ($o->hasType()) {
      $this->setType($o->getType());
    }
    if ($o->hasTypeName()) {
      $this->setTypeName($o->getTypeName());
    }
    if ($o->hasDefaultValue()) {
      $this->setDefaultValue($o->getDefaultValue());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FieldOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    if ($o->hasOneofIndex()) {
      $this->setOneofIndex($o->getOneofIndex());
    }
    if ($o->hasJsonName()) {
      $this->setJsonName($o->getJsonName());
    }
    if ($o->hasProto3Optional()) {
      $this->setProto3Optional($o->getProto3Optional());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class OneofDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private ?\google\protobuf\OneofOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'options' => ?\google\protobuf\OneofOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\OneofOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\OneofOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.OneofDescriptorProto";
  }

  public static function ParseFrom(string $input): ?OneofDescriptorProto {
    $msg = new OneofDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          if ($this->options is null) {
            $this->options = new \google\protobuf\OneofOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 2);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\OneofOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is OneofDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\OneofOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumDescriptorProto_EnumReservedRange implements \Protobuf\Message {
  private int $start;
  private bool $was_start_set;
  private int $end;
  private bool $was_end_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'start')) {
      $this->start = $s['start'];
      $this->was_start_set = true;
    } else {
      $this->start = 0;
      $this->was_start_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getStart(): int {
    return $this->start;
  }

  public function setStart(int $v): void {
    $this->start = $v;
    $this->was_start_set = true;
  }

  public function hasStart(): bool {
    return $this->was_start_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumDescriptorProto.EnumReservedRange";
  }

  public static function ParseFrom(string $input): ?EnumDescriptorProto_EnumReservedRange {
    $msg = new EnumDescriptorProto_EnumReservedRange();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          $this->was_start_set = true;
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_start_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->was_end_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasStart()) {
      $e->writeInt32('start', 'start', $this->start, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_start_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumDescriptorProto_EnumReservedRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasStart()) {
      $this->setStart($o->getStart());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  public vec<\google\protobuf\EnumValueDescriptorProto> $value;
  private ?\google\protobuf\EnumOptions $options;
  private bool $was_options_set;
  public vec<\google\protobuf\EnumDescriptorProto_EnumReservedRange> $reserved_range;
  public vec<string> $reserved_name;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'value' => vec<\google\protobuf\EnumValueDescriptorProto>,
    ?'options' => ?\google\protobuf\EnumOptions,
    ?'reserved_range' => vec<\google\protobuf\EnumDescriptorProto_EnumReservedRange>,
    ?'reserved_name' => vec<string>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    $this->value = $s['value'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->reserved_range = $s['reserved_range'] ?? vec[];
    $this->reserved_name = $s['reserved_name'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\EnumOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\EnumOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumDescriptorProto";
  }

  public static function ParseFrom(string $input): ?EnumDescriptorProto {
    $msg = new EnumDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $obj = new \google\protobuf\EnumValueDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->value []= $obj;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 5:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->value as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(5, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    $e->writeMessageList('value', 'value', $this->value);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'value':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumValueDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->value []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    foreach ($o->value as $v) {
      $nv = new \google\protobuf\EnumValueDescriptorProto();
      $nv->CopyFrom($v);
      $this->value []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\EnumOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    foreach ($o->reserved_range as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
      $nv->CopyFrom($v);
      $this->reserved_range []= $nv;
    }
    $this->reserved_name = $o->reserved_name;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumValueDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private int $number;
  private bool $was_number_set;
  private ?\google\protobuf\EnumValueOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'number' => int,
    ?'options' => ?\google\protobuf\EnumValueOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'number')) {
      $this->number = $s['number'];
      $this->was_number_set = true;
    } else {
      $this->number = 0;
      $this->was_number_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getNumber(): int {
    return $this->number;
  }

  public function setNumber(int $v): void {
    $this->number = $v;
    $this->was_number_set = true;
  }

  public function hasNumber(): bool {
    return $this->was_number_set;
  }

  public function getOptions(): ?\google\protobuf\EnumValueOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\EnumValueOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumValueDescriptorProto";
  }

  public static function ParseFrom(string $input): ?EnumValueDescriptorProto {
    $msg = new EnumValueDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->number = $d->readVarint32Signed();
          $this->was_number_set = true;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumValueOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_number_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->number);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasNumber()) {
      $e->writeInt32('number', 'number', $this->number, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_number_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumValueOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumValueDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasNumber()) {
      $this->setNumber($o->getNumber());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\EnumValueOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ServiceDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  public vec<\google\protobuf\MethodDescriptorProto> $method;
  private ?\google\protobuf\ServiceOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'method' => vec<\google\protobuf\MethodDescriptorProto>,
    ?'options' => ?\google\protobuf\ServiceOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    $this->method = $s['method'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\ServiceOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\ServiceOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.ServiceDescriptorProto";
  }

  public static function ParseFrom(string $input): ?ServiceDescriptorProto {
    $msg = new ServiceDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $obj = new \google\protobuf\MethodDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->method []= $obj;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\ServiceOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->method as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    $e->writeMessageList('method', 'method', $this->method);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'method':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\MethodDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->method []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\ServiceOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ServiceDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    foreach ($o->method as $v) {
      $nv = new \google\protobuf\MethodDescriptorProto();
      $nv->CopyFrom($v);
      $this->method []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\ServiceOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class MethodDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private string $input_type;
  private bool $was_input_type_set;
  private string $output_type;
  private bool $was_output_type_set;
  private ?\google\protobuf\MethodOptions $options;
  private bool $was_options_set;
  private bool $client_streaming;
  private bool $was_client_streaming_set;
  private bool $server_streaming;
  private bool $was_server_streaming_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'input_type' => string,
    ?'output_type' => string,
    ?'options' => ?\google\protobuf\MethodOptions,
    ?'client_streaming' => bool,
    ?'server_streaming' => bool,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'input_type')) {
      $this->input_type = $s['input_type'];
      $this->was_input_type_set = true;
    } else {
      $this->input_type = '';
      $this->was_input_type_set = false;
    }
    if (Shapes::keyExists($s, 'output_type')) {
      $this->output_type = $s['output_type'];
      $this->was_output_type_set = true;
    } else {
      $this->output_type = '';
      $this->was_output_type_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    if (Shapes::keyExists($s, 'client_streaming')) {
      $this->client_streaming = $s['client_streaming'];
      $this->was_client_streaming_set = true;
    } else {
      $this->client_streaming = false;
      $this->was_client_streaming_set = false;
    }
    if (Shapes::keyExists($s, 'server_streaming')) {
      $this->server_streaming = $s['server_streaming'];
      $this->was_server_streaming_set = true;
    } else {
      $this->server_streaming = false;
      $this->was_server_streaming_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getInputType(): string {
    return $this->input_type;
  }

  public function setInputType(string $v): void {
    $this->input_type = $v;
    $this->was_input_type_set = true;
  }

  public function hasInputType(): bool {
    return $this->was_input_type_set;
  }

  public function getOutputType(): string {
    return $this->output_type;
  }

  public function setOutputType(string $v): void {
    $this->output_type = $v;
    $this->was_output_type_set = true;
  }

  public function hasOutputType(): bool {
    return $this->was_output_type_set;
  }

  public function getOptions(): ?\google\protobuf\MethodOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\MethodOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function getClientStreaming(): bool {
    return $this->client_streaming;
  }

  public function setClientStreaming(bool $v): void {
    $this->client_streaming = $v;
    $this->was_client_streaming_set = true;
  }

  public function hasClientStreaming(): bool {
    return $this->was_client_streaming_set;
  }

  public function getServerStreaming(): bool {
    return $this->server_streaming;
  }

  public function setServerStreaming(bool $v): void {
    $this->server_streaming = $v;
    $this->was_server_streaming_set = true;
  }

  public function hasServerStreaming(): bool {
    return $this->was_server_streaming_set;
  }

  public function MessageName(): string {
    return "google.protobuf.MethodDescriptorProto";
  }

  public static function ParseFrom(string $input): ?MethodDescriptorProto {
    $msg = new MethodDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->input_type = $d->readString();
          $this->was_input_type_set = true;
          break;
        case 3:
          $this->output_type = $d->readString();
          $this->was_output_type_set = true;
          break;
        case 4:
          if ($this->options is null) {
            $this->options = new \google\protobuf\MethodOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 5:
          $this->client_streaming = $d->readBool();
          $this->was_client_streaming_set = true;
          break;
        case 6:
          $this->server_streaming = $d->readBool();
          $this->was_server_streaming_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_input_type_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->input_type);
    }
    if ($this->was_output_type_set) {
      $e->writeTag(3, 2);
      $e->writeString($this->output_type);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 4);
      }
    }
    if ($this->was_client_streaming_set) {
      $e->writeTag(5, 0);
      $e->writeBool($this->client_streaming);
    }
    if ($this->was_server_streaming_set) {
      $e->writeTag(6, 0);
      $e->writeBool($this->server_streaming);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasInputType()) {
      $e->writeString('input_type', 'inputType', $this->input_type, false);
    }
    if ($this->hasOutputType()) {
      $e->writeString('output_type', 'outputType', $this->output_type, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    if ($this->hasClientStreaming()) {
      $e->writeBool('client_streaming', 'clientStreaming', $this->client_streaming, false);
    }
    if ($this->hasServerStreaming()) {
      $e->writeBool('server_streaming', 'serverStreaming', $this->server_streaming, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'input_type': case 'inputType':
          $this->input_type = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_input_type_set = true;
          break;
        case 'output_type': case 'outputType':
          $this->output_type = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_output_type_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\MethodOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'client_streaming': case 'clientStreaming':
          $this->client_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_client_streaming_set = true;
          break;
        case 'server_streaming': case 'serverStreaming':
          $this->server_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_server_streaming_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MethodDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasInputType()) {
      $this->setInputType($o->getInputType());
    }
    if ($o->hasOutputType()) {
      $this->setOutputType($o->getOutputType());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\MethodOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    if ($o->hasClientStreaming()) {
      $this->setClientStreaming($o->getClientStreaming());
    }
    if ($o->hasServerStreaming()) {
      $this->setServerStreaming($o->getServerStreaming());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FileOptions_OptimizeMode_enum_t as int = int;
abstract class FileOptions_OptimizeMode {
  const FileOptions_OptimizeMode_enum_t SPEED = 1;
  const FileOptions_OptimizeMode_enum_t CODE_SIZE = 2;
  const FileOptions_OptimizeMode_enum_t LITE_RUNTIME = 3;
  private static dict<int, string> $itos = dict[
    1 => 'SPEED',
    2 => 'CODE_SIZE',
    3 => 'LITE_RUNTIME',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'SPEED' => 1,
    'CODE_SIZE' => 2,
    'LITE_RUNTIME' => 3,
  ];
  public static function FromMixed(mixed $m): FileOptions_OptimizeMode_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FileOptions_OptimizeMode_enum_t {
    return $i;
  }
}

class FileOptions implements \Protobuf\Message {
  private string $java_package;
  private bool $was_java_package_set;
  private string $java_outer_classname;
  private bool $was_java_outer_classname_set;
  private bool $java_multiple_files;
  private bool $was_java_multiple_files_set;
  private bool $java_generate_equals_and_hash;
  private bool $was_java_generate_equals_and_hash_set;
  private bool $java_string_check_utf8;
  private bool $was_java_string_check_utf8_set;
  private \google\protobuf\FileOptions_OptimizeMode_enum_t $optimize_for;
  private bool $was_optimize_for_set;
  private string $go_package;
  private bool $was_go_package_set;
  private bool $cc_generic_services;
  private bool $was_cc_generic_services_set;
  private bool $java_generic_services;
  private bool $was_java_generic_services_set;
  private bool $py_generic_services;
  private bool $was_py_generic_services_set;
  private bool $php_generic_services;
  private bool $was_php_generic_services_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  private bool $cc_enable_arenas;
  private bool $was_cc_enable_arenas_set;
  private string $objc_class_prefix;
  private bool $was_objc_class_prefix_set;
  private string $csharp_namespace;
  private bool $was_csharp_namespace_set;
  private string $swift_prefix;
  private bool $was_swift_prefix_set;
  private string $php_class_prefix;
  private bool $was_php_class_prefix_set;
  private string $php_namespace;
  private bool $was_php_namespace_set;
  private string $php_metadata_namespace;
  private bool $was_php_metadata_namespace_set;
  private string $ruby_package;
  private bool $was_ruby_package_set;
  private ?\google\protobuf\FeatureSet $features;
  private bool $was_features_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'java_package' => string,
    ?'java_outer_classname' => string,
    ?'java_multiple_files' => bool,
    ?'java_generate_equals_and_hash' => bool,
    ?'java_string_check_utf8' => bool,
    ?'optimize_for' => \google\protobuf\FileOptions_OptimizeMode_enum_t,
    ?'go_package' => string,
    ?'cc_generic_services' => bool,
    ?'java_generic_services' => bool,
    ?'py_generic_services' => bool,
    ?'php_generic_services' => bool,
    ?'deprecated' => bool,
    ?'cc_enable_arenas' => bool,
    ?'objc_class_prefix' => string,
    ?'csharp_namespace' => string,
    ?'swift_prefix' => string,
    ?'php_class_prefix' => string,
    ?'php_namespace' => string,
    ?'php_metadata_namespace' => string,
    ?'ruby_package' => string,
    ?'features' => ?\google\protobuf\FeatureSet,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'java_package')) {
      $this->java_package = $s['java_package'];
      $this->was_java_package_set = true;
    } else {
      $this->java_package = '';
      $this->was_java_package_set = false;
    }
    if (Shapes::keyExists($s, 'java_outer_classname')) {
      $this->java_outer_classname = $s['java_outer_classname'];
      $this->was_java_outer_classname_set = true;
    } else {
      $this->java_outer_classname = '';
      $this->was_java_outer_classname_set = false;
    }
    if (Shapes::keyExists($s, 'java_multiple_files')) {
      $this->java_multiple_files = $s['java_multiple_files'];
      $this->was_java_multiple_files_set = true;
    } else {
      $this->java_multiple_files = false;
      $this->was_java_multiple_files_set = false;
    }
    if (Shapes::keyExists($s, 'java_generate_equals_and_hash')) {
      $this->java_generate_equals_and_hash = $s['java_generate_equals_and_hash'];
      $this->was_java_generate_equals_and_hash_set = true;
    } else {
      $this->java_generate_equals_and_hash = false;
      $this->was_java_generate_equals_and_hash_set = false;
    }
    if (Shapes::keyExists($s, 'java_string_check_utf8')) {
      $this->java_string_check_utf8 = $s['java_string_check_utf8'];
      $this->was_java_string_check_utf8_set = true;
    } else {
      $this->java_string_check_utf8 = false;
      $this->was_java_string_check_utf8_set = false;
    }
    if (Shapes::keyExists($s, 'optimize_for')) {
      $this->optimize_for = $s['optimize_for'];
      $this->was_optimize_for_set = true;
    } else {
      $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::SPEED;
      $this->was_optimize_for_set = false;
    }
    if (Shapes::keyExists($s, 'go_package')) {
      $this->go_package = $s['go_package'];
      $this->was_go_package_set = true;
    } else {
      $this->go_package = '';
      $this->was_go_package_set = false;
    }
    if (Shapes::keyExists($s, 'cc_generic_services')) {
      $this->cc_generic_services = $s['cc_generic_services'];
      $this->was_cc_generic_services_set = true;
    } else {
      $this->cc_generic_services = false;
      $this->was_cc_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'java_generic_services')) {
      $this->java_generic_services = $s['java_generic_services'];
      $this->was_java_generic_services_set = true;
    } else {
      $this->java_generic_services = false;
      $this->was_java_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'py_generic_services')) {
      $this->py_generic_services = $s['py_generic_services'];
      $this->was_py_generic_services_set = true;
    } else {
      $this->py_generic_services = false;
      $this->was_py_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'php_generic_services')) {
      $this->php_generic_services = $s['php_generic_services'];
      $this->was_php_generic_services_set = true;
    } else {
      $this->php_generic_services = false;
      $this->was_php_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'cc_enable_arenas')) {
      $this->cc_enable_arenas = $s['cc_enable_arenas'];
      $this->was_cc_enable_arenas_set = true;
    } else {
      $this->cc_enable_arenas = true;
      $this->was_cc_enable_arenas_set = false;
    }
    if (Shapes::keyExists($s, 'objc_class_prefix')) {
      $this->objc_class_prefix = $s['objc_class_prefix'];
      $this->was_objc_class_prefix_set = true;
    } else {
      $this->objc_class_prefix = '';
      $this->was_objc_class_prefix_set = false;
    }
    if (Shapes::keyExists($s, 'csharp_namespace')) {
      $this->csharp_namespace = $s['csharp_namespace'];
      $this->was_csharp_namespace_set = true;
    } else {
      $this->csharp_namespace = '';
      $this->was_csharp_namespace_set = false;
    }
    if (Shapes::keyExists($s, 'swift_prefix')) {
      $this->swift_prefix = $s['swift_prefix'];
      $this->was_swift_prefix_set = true;
    } else {
      $this->swift_prefix = '';
      $this->was_swift_prefix_set = false;
    }
    if (Shapes::keyExists($s, 'php_class_prefix')) {
      $this->php_class_prefix = $s['php_class_prefix'];
      $this->was_php_class_prefix_set = true;
    } else {
      $this->php_class_prefix = '';
      $this->was_php_class_prefix_set = false;
    }
    if (Shapes::keyExists($s, 'php_namespace')) {
      $this->php_namespace = $s['php_namespace'];
      $this->was_php_namespace_set = true;
    } else {
      $this->php_namespace = '';
      $this->was_php_namespace_set = false;
    }
    if (Shapes::keyExists($s, 'php_metadata_namespace')) {
      $this->php_metadata_namespace = $s['php_metadata_namespace'];
      $this->was_php_metadata_namespace_set = true;
    } else {
      $this->php_metadata_namespace = '';
      $this->was_php_metadata_namespace_set = false;
    }
    if (Shapes::keyExists($s, 'ruby_package')) {
      $this->ruby_package = $s['ruby_package'];
      $this->was_ruby_package_set = true;
    } else {
      $this->ruby_package = '';
      $this->was_ruby_package_set = false;
    }
    if (Shapes::keyExists($s, 'features')) {
      $this->features = $s['features'];
      $this->was_features_set = true;
    } else {
      $this->features = null;
      $this->was_features_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getJavaPackage(): string {
    return $this->java_package;
  }

  public function setJavaPackage(string $v): void {
    $this->java_package = $v;
    $this->was_java_package_set = true;
  }

  public function hasJavaPackage(): bool {
    return $this->was_java_package_set;
  }

  public function getJavaOuterClassname(): string {
    return $this->java_outer_classname;
  }

  public function setJavaOuterClassname(string $v): void {
    $this->java_outer_classname = $v;
    $this->was_java_outer_classname_set = true;
  }

  public function hasJavaOuterClassname(): bool {
    return $this->was_java_outer_classname_set;
  }

  public function getJavaMultipleFiles(): bool {
    return $this->java_multiple_files;
  }

  public function setJavaMultipleFiles(bool $v): void {
    $this->java_multiple_files = $v;
    $this->was_java_multiple_files_set = true;
  }

  public function hasJavaMultipleFiles(): bool {
    return $this->was_java_multiple_files_set;
  }

  public function getJavaGenerateEqualsAndHash(): bool {
    return $this->java_generate_equals_and_hash;
  }

  public function setJavaGenerateEqualsAndHash(bool $v): void {
    $this->java_generate_equals_and_hash = $v;
    $this->was_java_generate_equals_and_hash_set = true;
  }

  public function hasJavaGenerateEqualsAndHash(): bool {
    return $this->was_java_generate_equals_and_hash_set;
  }

  public function getJavaStringCheckUtf8(): bool {
    return $this->java_string_check_utf8;
  }

  public function setJavaStringCheckUtf8(bool $v): void {
    $this->java_string_check_utf8 = $v;
    $this->was_java_string_check_utf8_set = true;
  }

  public function hasJavaStringCheckUtf8(): bool {
    return $this->was_java_string_check_utf8_set;
  }

  public function getOptimizeFor(): \google\protobuf\FileOptions_OptimizeMode_enum_t {
    return $this->optimize_for;
  }

  public function setOptimizeFor(\google\protobuf\FileOptions_OptimizeMode_enum_t $v): void {
    $this->optimize_for = $v;
    $this->was_optimize_for_set = true;
  }

  public function hasOptimizeFor(): bool {
    return $this->was_optimize_for_set;
  }

  public function getGoPackage(): string {
    return $this->go_package;
  }

  public function setGoPackage(string $v): void {
    $this->go_package = $v;
    $this->was_go_package_set = true;
  }

  public function hasGoPackage(): bool {
    return $this->was_go_package_set;
  }

  public function getCcGenericServices(): bool {
    return $this->cc_generic_services;
  }

  public function setCcGenericServices(bool $v): void {
    $this->cc_generic_services = $v;
    $this->was_cc_generic_services_set = true;
  }

  public function hasCcGenericServices(): bool {
    return $this->was_cc_generic_services_set;
  }

  public function getJavaGenericServices(): bool {
    return $this->java_generic_services;
  }

  public function setJavaGenericServices(bool $v): void {
    $this->java_generic_services = $v;
    $this->was_java_generic_services_set = true;
  }

  public function hasJavaGenericServices(): bool {
    return $this->was_java_generic_services_set;
  }

  public function getPyGenericServices(): bool {
    return $this->py_generic_services;
  }

  public function setPyGenericServices(bool $v): void {
    $this->py_generic_services = $v;
    $this->was_py_generic_services_set = true;
  }

  public function hasPyGenericServices(): bool {
    return $this->was_py_generic_services_set;
  }

  public function getPhpGenericServices(): bool {
    return $this->php_generic_services;
  }

  public function setPhpGenericServices(bool $v): void {
    $this->php_generic_services = $v;
    $this->was_php_generic_services_set = true;
  }

  public function hasPhpGenericServices(): bool {
    return $this->was_php_generic_services_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getCcEnableArenas(): bool {
    return $this->cc_enable_arenas;
  }

  public function setCcEnableArenas(bool $v): void {
    $this->cc_enable_arenas = $v;
    $this->was_cc_enable_arenas_set = true;
  }

  public function hasCcEnableArenas(): bool {
    return $this->was_cc_enable_arenas_set;
  }

  public function getObjcClassPrefix(): string {
    return $this->objc_class_prefix;
  }

  public function setObjcClassPrefix(string $v): void {
    $this->objc_class_prefix = $v;
    $this->was_objc_class_prefix_set = true;
  }

  public function hasObjcClassPrefix(): bool {
    return $this->was_objc_class_prefix_set;
  }

  public function getCsharpNamespace(): string {
    return $this->csharp_namespace;
  }

  public function setCsharpNamespace(string $v): void {
    $this->csharp_namespace = $v;
    $this->was_csharp_namespace_set = true;
  }

  public function hasCsharpNamespace(): bool {
    return $this->was_csharp_namespace_set;
  }

  public function getSwiftPrefix(): string {
    return $this->swift_prefix;
  }

  public function setSwiftPrefix(string $v): void {
    $this->swift_prefix = $v;
    $this->was_swift_prefix_set = true;
  }

  public function hasSwiftPrefix(): bool {
    return $this->was_swift_prefix_set;
  }

  public function getPhpClassPrefix(): string {
    return $this->php_class_prefix;
  }

  public function setPhpClassPrefix(string $v): void {
    $this->php_class_prefix = $v;
    $this->was_php_class_prefix_set = true;
  }

  public function hasPhpClassPrefix(): bool {
    return $this->was_php_class_prefix_set;
  }

  public function getPhpNamespace(): string {
    return $this->php_namespace;
  }

  public function setPhpNamespace(string $v): void {
    $this->php_namespace = $v;
    $this->was_php_namespace_set = true;
  }

  public function hasPhpNamespace(): bool {
    return $this->was_php_namespace_set;
  }

  public function getPhpMetadataNamespace(): string {
    return $this->php_metadata_namespace;
  }

  public function setPhpMetadataNamespace(string $v): void {
    $this->php_metadata_namespace = $v;
    $this->was_php_metadata_namespace_set = true;
  }

  public function hasPhpMetadataNamespace(): bool {
    return $this->was_php_metadata_namespace_set;
  }

  public function getRubyPackage(): string {
    return $this->ruby_package;
  }

  public function setRubyPackage(string $v): void {
    $this->ruby_package = $v;
    $this->was_ruby_package_set = true;
  }

  public function hasRubyPackage(): bool {
    return $this->was_ruby_package_set;
  }

  public function getFeatures(): ?\google\protobuf\FeatureSet {
    return $this->features;
  }

  public function setFeatures(?\google\protobuf\FeatureSet $v): void {
    $this->features = $v;
    $this->was_features_set = true;
  }

  public function hasFeatures(): bool {
    return $this->was_features_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FileOptions";
  }

  public static function ParseFrom(string $input): ?FileOptions {
    $msg = new FileOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->java_package = $d->readString();
          $this->was_java_package_set = true;
          break;
        case 8:
          $this->java_outer_classname = $d->readString();
          $this->was_java_outer_classname_set = true;
          break;
        case 9:
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::FromInt($d->readVarint());
          $this->was_optimize_for_set = true;
          break;
        case 10:
          $this->java_multiple_files = $d->readBool();
          $this->was_java_multiple_files_set = true;
          break;
        case 11:
          $this->go_package = $d->readString();
          $this->was_go_package_set = true;
          break;
        case 16:
          $this->cc_generic_services = $d->readBool();
          $this->was_cc_generic_services_set = true;
          break;
        case 17:
          $this->java_generic_services = $d->readBool();
          $this->was_java_generic_services_set = true;
          break;
        case 18:
          $this->py_generic_services = $d->readBool();
          $this->was_py_generic_services_set = true;
          break;
        case 20:
          $this->java_generate_equals_and_hash = $d->readBool();
          $this->was_java_generate_equals_and_hash_set = true;
          break;
        case 23:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 27:
          $this->java_string_check_utf8 = $d->readBool();
          $this->was_java_string_check_utf8_set = true;
          break;
        case 31:
          $this->cc_enable_arenas = $d->readBool();
          $this->was_cc_enable_arenas_set = true;
          break;
        case 36:
          $this->objc_class_prefix = $d->readString();
          $this->was_objc_class_prefix_set = true;
          break;
        case 37:
          $this->csharp_namespace = $d->readString();
          $this->was_csharp_namespace_set = true;
          break;
        case 39:
          $this->swift_prefix = $d->readString();
          $this->was_swift_prefix_set = true;
          break;
        case 40:
          $this->php_class_prefix = $d->readString();
          $this->was_php_class_prefix_set = true;
          break;
        case 41:
          $this->php_namespace = $d->readString();
          $this->was_php_namespace_set = true;
          break;
        case 42:
          $this->php_generic_services = $d->readBool();
          $this->was_php_generic_services_set = true;
          break;
        case 44:
          $this->php_metadata_namespace = $d->readString();
          $this->was_php_metadata_namespace_set = true;
          break;
        case 45:
          $this->ruby_package = $d->readString();
          $this->was_ruby_package_set = true;
          break;
        case 50:
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeFrom($d->readDecoder());
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_java_package_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->java_package);
    }
    if ($this->was_java_outer_classname_set) {
      $e->writeTag(8, 2);
      $e->writeString($this->java_outer_classname);
    }
    if ($this->was_optimize_for_set) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->optimize_for);
    }
    if ($this->was_java_multiple_files_set) {
      $e->writeTag(10, 0);
      $e->writeBool($this->java_multiple_files);
    }
    if ($this->was_go_package_set) {
      $e->writeTag(11, 2);
      $e->writeString($this->go_package);
    }
    if ($this->was_cc_generic_services_set) {
      $e->writeTag(16, 0);
      $e->writeBool($this->cc_generic_services);
    }
    if ($this->was_java_generic_services_set) {
      $e->writeTag(17, 0);
      $e->writeBool($this->java_generic_services);
    }
    if ($this->was_py_generic_services_set) {
      $e->writeTag(18, 0);
      $e->writeBool($this->py_generic_services);
    }
    if ($this->was_java_generate_equals_and_hash_set) {
      $e->writeTag(20, 0);
      $e->writeBool($this->java_generate_equals_and_hash);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(23, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_java_string_check_utf8_set) {
      $e->writeTag(27, 0);
      $e->writeBool($this->java_string_check_utf8);
    }
    if ($this->was_cc_enable_arenas_set) {
      $e->writeTag(31, 0);
      $e->writeBool($this->cc_enable_arenas);
    }
    if ($this->was_objc_class_prefix_set) {
      $e->writeTag(36, 2);
      $e->writeString($this->objc_class_prefix);
    }
    if ($this->was_csharp_namespace_set) {
      $e->writeTag(37, 2);
      $e->writeString($this->csharp_namespace);
    }
    if ($this->was_swift_prefix_set) {
      $e->writeTag(39, 2);
      $e->writeString($this->swift_prefix);
    }
    if ($this->was_php_class_prefix_set) {
      $e->writeTag(40, 2);
      $e->writeString($this->php_class_prefix);
    }
    if ($this->was_php_namespace_set) {
      $e->writeTag(41, 2);
      $e->writeString($this->php_namespace);
    }
    if ($this->was_php_generic_services_set) {
      $e->writeTag(42, 0);
      $e->writeBool($this->php_generic_services);
    }
    if ($this->was_php_metadata_namespace_set) {
      $e->writeTag(44, 2);
      $e->writeString($this->php_metadata_namespace);
    }
    if ($this->was_ruby_package_set) {
      $e->writeTag(45, 2);
      $e->writeString($this->ruby_package);
    }
    $msg = $this->features;
    if ($msg != null) {
      if ($this->was_features_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 50);
      }
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasJavaPackage()) {
      $e->writeString('java_package', 'javaPackage', $this->java_package, false);
    }
    if ($this->hasJavaOuterClassname()) {
      $e->writeString('java_outer_classname', 'javaOuterClassname', $this->java_outer_classname, false);
    }
    if ($this->hasOptimizeFor()) {
      $e->writeEnum('optimize_for', 'optimizeFor', \google\protobuf\FileOptions_OptimizeMode::ToStringDict(), $this->optimize_for, false);
    }
    if ($this->hasJavaMultipleFiles()) {
      $e->writeBool('java_multiple_files', 'javaMultipleFiles', $this->java_multiple_files, false);
    }
    if ($this->hasGoPackage()) {
      $e->writeString('go_package', 'goPackage', $this->go_package, false);
    }
    if ($this->hasCcGenericServices()) {
      $e->writeBool('cc_generic_services', 'ccGenericServices', $this->cc_generic_services, false);
    }
    if ($this->hasJavaGenericServices()) {
      $e->writeBool('java_generic_services', 'javaGenericServices', $this->java_generic_services, false);
    }
    if ($this->hasPyGenericServices()) {
      $e->writeBool('py_generic_services', 'pyGenericServices', $this->py_generic_services, false);
    }
    if ($this->hasJavaGenerateEqualsAndHash()) {
      $e->writeBool('java_generate_equals_and_hash', 'javaGenerateEqualsAndHash', $this->java_generate_equals_and_hash, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasJavaStringCheckUtf8()) {
      $e->writeBool('java_string_check_utf8', 'javaStringCheckUtf8', $this->java_string_check_utf8, false);
    }
    if ($this->hasCcEnableArenas()) {
      $e->writeBool('cc_enable_arenas', 'ccEnableArenas', $this->cc_enable_arenas, false);
    }
    if ($this->hasObjcClassPrefix()) {
      $e->writeString('objc_class_prefix', 'objcClassPrefix', $this->objc_class_prefix, false);
    }
    if ($this->hasCsharpNamespace()) {
      $e->writeString('csharp_namespace', 'csharpNamespace', $this->csharp_namespace, false);
    }
    if ($this->hasSwiftPrefix()) {
      $e->writeString('swift_prefix', 'swiftPrefix', $this->swift_prefix, false);
    }
    if ($this->hasPhpClassPrefix()) {
      $e->writeString('php_class_prefix', 'phpClassPrefix', $this->php_class_prefix, false);
    }
    if ($this->hasPhpNamespace()) {
      $e->writeString('php_namespace', 'phpNamespace', $this->php_namespace, false);
    }
    if ($this->hasPhpGenericServices()) {
      $e->writeBool('php_generic_services', 'phpGenericServices', $this->php_generic_services, false);
    }
    if ($this->hasPhpMetadataNamespace()) {
      $e->writeString('php_metadata_namespace', 'phpMetadataNamespace', $this->php_metadata_namespace, false);
    }
    if ($this->hasRubyPackage()) {
      $e->writeString('ruby_package', 'rubyPackage', $this->ruby_package, false);
    }
    if ($this->hasFeatures()) {
      $e->writeMessage('features', 'features', $this->features, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'java_package': case 'javaPackage':
          $this->java_package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_java_package_set = true;
          break;
        case 'java_outer_classname': case 'javaOuterClassname':
          $this->java_outer_classname = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_java_outer_classname_set = true;
          break;
        case 'optimize_for': case 'optimizeFor':
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::FromMixed($v);
          $this->was_optimize_for_set = true;
          break;
        case 'java_multiple_files': case 'javaMultipleFiles':
          $this->java_multiple_files = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_multiple_files_set = true;
          break;
        case 'go_package': case 'goPackage':
          $this->go_package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_go_package_set = true;
          break;
        case 'cc_generic_services': case 'ccGenericServices':
          $this->cc_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_cc_generic_services_set = true;
          break;
        case 'java_generic_services': case 'javaGenericServices':
          $this->java_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_generic_services_set = true;
          break;
        case 'py_generic_services': case 'pyGenericServices':
          $this->py_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_py_generic_services_set = true;
          break;
        case 'java_generate_equals_and_hash': case 'javaGenerateEqualsAndHash':
          $this->java_generate_equals_and_hash = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_generate_equals_and_hash_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'java_string_check_utf8': case 'javaStringCheckUtf8':
          $this->java_string_check_utf8 = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_string_check_utf8_set = true;
          break;
        case 'cc_enable_arenas': case 'ccEnableArenas':
          $this->cc_enable_arenas = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_cc_enable_arenas_set = true;
          break;
        case 'objc_class_prefix': case 'objcClassPrefix':
          $this->objc_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_objc_class_prefix_set = true;
          break;
        case 'csharp_namespace': case 'csharpNamespace':
          $this->csharp_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_csharp_namespace_set = true;
          break;
        case 'swift_prefix': case 'swiftPrefix':
          $this->swift_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_swift_prefix_set = true;
          break;
        case 'php_class_prefix': case 'phpClassPrefix':
          $this->php_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_php_class_prefix_set = true;
          break;
        case 'php_namespace': case 'phpNamespace':
          $this->php_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_php_namespace_set = true;
          break;
        case 'php_generic_services': case 'phpGenericServices':
          $this->php_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_php_generic_services_set = true;
          break;
        case 'php_metadata_namespace': case 'phpMetadataNamespace':
          $this->php_metadata_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_php_metadata_namespace_set = true;
          break;
        case 'ruby_package': case 'rubyPackage':
          $this->ruby_package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_ruby_package_set = true;
          break;
        case 'features':
          if ($v is null) break;
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeJsonFrom($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasJavaPackage()) {
      $this->setJavaPackage($o->getJavaPackage());
    }
    if ($o->hasJavaOuterClassname()) {
      $this->setJavaOuterClassname($o->getJavaOuterClassname());
    }
    if ($o->hasOptimizeFor()) {
      $this->setOptimizeFor($o->getOptimizeFor());
    }
    if ($o->hasJavaMultipleFiles()) {
      $this->setJavaMultipleFiles($o->getJavaMultipleFiles());
    }
    if ($o->hasGoPackage()) {
      $this->setGoPackage($o->getGoPackage());
    }
    if ($o->hasCcGenericServices()) {
      $this->setCcGenericServices($o->getCcGenericServices());
    }
    if ($o->hasJavaGenericServices()) {
      $this->setJavaGenericServices($o->getJavaGenericServices());
    }
    if ($o->hasPyGenericServices()) {
      $this->setPyGenericServices($o->getPyGenericServices());
    }
    if ($o->hasJavaGenerateEqualsAndHash()) {
      $this->setJavaGenerateEqualsAndHash($o->getJavaGenerateEqualsAndHash());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasJavaStringCheckUtf8()) {
      $this->setJavaStringCheckUtf8($o->getJavaStringCheckUtf8());
    }
    if ($o->hasCcEnableArenas()) {
      $this->setCcEnableArenas($o->getCcEnableArenas());
    }
    if ($o->hasObjcClassPrefix()) {
      $this->setObjcClassPrefix($o->getObjcClassPrefix());
    }
    if ($o->hasCsharpNamespace()) {
      $this->setCsharpNamespace($o->getCsharpNamespace());
    }
    if ($o->hasSwiftPrefix()) {
      $this->setSwiftPrefix($o->getSwiftPrefix());
    }
    if ($o->hasPhpClassPrefix()) {
      $this->setPhpClassPrefix($o->getPhpClassPrefix());
    }
    if ($o->hasPhpNamespace()) {
      $this->setPhpNamespace($o->getPhpNamespace());
    }
    if ($o->hasPhpGenericServices()) {
      $this->setPhpGenericServices($o->getPhpGenericServices());
    }
    if ($o->hasPhpMetadataNamespace()) {
      $this->setPhpMetadataNamespace($o->getPhpMetadataNamespace());
    }
    if ($o->hasRubyPackage()) {
      $this->setRubyPackage($o->getRubyPackage());
    }
    $tmp = $o->features;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FeatureSet();
      $nv->CopyFrom($tmp);
      $this->setFeatures($nv);
    } else if ($o->hasFeatures()) {
      $this->setFeatures(null);
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class MessageOptions implements \Protobuf\Message {
  private bool $message_set_wire_format;
  private bool $was_message_set_wire_format_set;
  private bool $no_standard_descriptor_accessor;
  private bool $was_no_standard_descriptor_accessor_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  private bool $map_entry;
  private bool $was_map_entry_set;
  private bool $deprecated_legacy_json_field_conflicts;
  private bool $was_deprecated_legacy_json_field_conflicts_set;
  private ?\google\protobuf\FeatureSet $features;
  private bool $was_features_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'message_set_wire_format' => bool,
    ?'no_standard_descriptor_accessor' => bool,
    ?'deprecated' => bool,
    ?'map_entry' => bool,
    ?'deprecated_legacy_json_field_conflicts' => bool,
    ?'features' => ?\google\protobuf\FeatureSet,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'message_set_wire_format')) {
      $this->message_set_wire_format = $s['message_set_wire_format'];
      $this->was_message_set_wire_format_set = true;
    } else {
      $this->message_set_wire_format = false;
      $this->was_message_set_wire_format_set = false;
    }
    if (Shapes::keyExists($s, 'no_standard_descriptor_accessor')) {
      $this->no_standard_descriptor_accessor = $s['no_standard_descriptor_accessor'];
      $this->was_no_standard_descriptor_accessor_set = true;
    } else {
      $this->no_standard_descriptor_accessor = false;
      $this->was_no_standard_descriptor_accessor_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'map_entry')) {
      $this->map_entry = $s['map_entry'];
      $this->was_map_entry_set = true;
    } else {
      $this->map_entry = false;
      $this->was_map_entry_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated_legacy_json_field_conflicts')) {
      $this->deprecated_legacy_json_field_conflicts = $s['deprecated_legacy_json_field_conflicts'];
      $this->was_deprecated_legacy_json_field_conflicts_set = true;
    } else {
      $this->deprecated_legacy_json_field_conflicts = false;
      $this->was_deprecated_legacy_json_field_conflicts_set = false;
    }
    if (Shapes::keyExists($s, 'features')) {
      $this->features = $s['features'];
      $this->was_features_set = true;
    } else {
      $this->features = null;
      $this->was_features_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getMessageSetWireFormat(): bool {
    return $this->message_set_wire_format;
  }

  public function setMessageSetWireFormat(bool $v): void {
    $this->message_set_wire_format = $v;
    $this->was_message_set_wire_format_set = true;
  }

  public function hasMessageSetWireFormat(): bool {
    return $this->was_message_set_wire_format_set;
  }

  public function getNoStandardDescriptorAccessor(): bool {
    return $this->no_standard_descriptor_accessor;
  }

  public function setNoStandardDescriptorAccessor(bool $v): void {
    $this->no_standard_descriptor_accessor = $v;
    $this->was_no_standard_descriptor_accessor_set = true;
  }

  public function hasNoStandardDescriptorAccessor(): bool {
    return $this->was_no_standard_descriptor_accessor_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getMapEntry(): bool {
    return $this->map_entry;
  }

  public function setMapEntry(bool $v): void {
    $this->map_entry = $v;
    $this->was_map_entry_set = true;
  }

  public function hasMapEntry(): bool {
    return $this->was_map_entry_set;
  }

  public function getDeprecatedLegacyJsonFieldConflicts(): bool {
    return $this->deprecated_legacy_json_field_conflicts;
  }

  public function setDeprecatedLegacyJsonFieldConflicts(bool $v): void {
    $this->deprecated_legacy_json_field_conflicts = $v;
    $this->was_deprecated_legacy_json_field_conflicts_set = true;
  }

  public function hasDeprecatedLegacyJsonFieldConflicts(): bool {
    return $this->was_deprecated_legacy_json_field_conflicts_set;
  }

  public function getFeatures(): ?\google\protobuf\FeatureSet {
    return $this->features;
  }

  public function setFeatures(?\google\protobuf\FeatureSet $v): void {
    $this->features = $v;
    $this->was_features_set = true;
  }

  public function hasFeatures(): bool {
    return $this->was_features_set;
  }

  public function MessageName(): string {
    return "google.protobuf.MessageOptions";
  }

  public static function ParseFrom(string $input): ?MessageOptions {
    $msg = new MessageOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->message_set_wire_format = $d->readBool();
          $this->was_message_set_wire_format_set = true;
          break;
        case 2:
          $this->no_standard_descriptor_accessor = $d->readBool();
          $this->was_no_standard_descriptor_accessor_set = true;
          break;
        case 3:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 7:
          $this->map_entry = $d->readBool();
          $this->was_map_entry_set = true;
          break;
        case 11:
          $this->deprecated_legacy_json_field_conflicts = $d->readBool();
          $this->was_deprecated_legacy_json_field_conflicts_set = true;
          break;
        case 12:
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeFrom($d->readDecoder());
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_message_set_wire_format_set) {
      $e->writeTag(1, 0);
      $e->writeBool($this->message_set_wire_format);
    }
    if ($this->was_no_standard_descriptor_accessor_set) {
      $e->writeTag(2, 0);
      $e->writeBool($this->no_standard_descriptor_accessor);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_map_entry_set) {
      $e->writeTag(7, 0);
      $e->writeBool($this->map_entry);
    }
    if ($this->was_deprecated_legacy_json_field_conflicts_set) {
      $e->writeTag(11, 0);
      $e->writeBool($this->deprecated_legacy_json_field_conflicts);
    }
    $msg = $this->features;
    if ($msg != null) {
      if ($this->was_features_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 12);
      }
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasMessageSetWireFormat()) {
      $e->writeBool('message_set_wire_format', 'messageSetWireFormat', $this->message_set_wire_format, false);
    }
    if ($this->hasNoStandardDescriptorAccessor()) {
      $e->writeBool('no_standard_descriptor_accessor', 'noStandardDescriptorAccessor', $this->no_standard_descriptor_accessor, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasMapEntry()) {
      $e->writeBool('map_entry', 'mapEntry', $this->map_entry, false);
    }
    if ($this->hasDeprecatedLegacyJsonFieldConflicts()) {
      $e->writeBool('deprecated_legacy_json_field_conflicts', 'deprecatedLegacyJsonFieldConflicts', $this->deprecated_legacy_json_field_conflicts, false);
    }
    if ($this->hasFeatures()) {
      $e->writeMessage('features', 'features', $this->features, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'message_set_wire_format': case 'messageSetWireFormat':
          $this->message_set_wire_format = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_message_set_wire_format_set = true;
          break;
        case 'no_standard_descriptor_accessor': case 'noStandardDescriptorAccessor':
          $this->no_standard_descriptor_accessor = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_no_standard_descriptor_accessor_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'map_entry': case 'mapEntry':
          $this->map_entry = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_map_entry_set = true;
          break;
        case 'deprecated_legacy_json_field_conflicts': case 'deprecatedLegacyJsonFieldConflicts':
          $this->deprecated_legacy_json_field_conflicts = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_legacy_json_field_conflicts_set = true;
          break;
        case 'features':
          if ($v is null) break;
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeJsonFrom($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MessageOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasMessageSetWireFormat()) {
      $this->setMessageSetWireFormat($o->getMessageSetWireFormat());
    }
    if ($o->hasNoStandardDescriptorAccessor()) {
      $this->setNoStandardDescriptorAccessor($o->getNoStandardDescriptorAccessor());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasMapEntry()) {
      $this->setMapEntry($o->getMapEntry());
    }
    if ($o->hasDeprecatedLegacyJsonFieldConflicts()) {
      $this->setDeprecatedLegacyJsonFieldConflicts($o->getDeprecatedLegacyJsonFieldConflicts());
    }
    $tmp = $o->features;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FeatureSet();
      $nv->CopyFrom($tmp);
      $this->setFeatures($nv);
    } else if ($o->hasFeatures()) {
      $this->setFeatures(null);
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FieldOptions_CType_enum_t as int = int;
abstract class FieldOptions_CType {
  const FieldOptions_CType_enum_t STRING = 0;
  const FieldOptions_CType_enum_t CORD = 1;
  const FieldOptions_CType_enum_t STRING_PIECE = 2;
  private static dict<int, string> $itos = dict[
    0 => 'STRING',
    1 => 'CORD',
    2 => 'STRING_PIECE',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'STRING' => 0,
    'CORD' => 1,
    'STRING_PIECE' => 2,
  ];
  public static function FromMixed(mixed $m): FieldOptions_CType_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_CType_enum_t {
    return $i;
  }
}

newtype FieldOptions_JSType_enum_t as int = int;
abstract class FieldOptions_JSType {
  const FieldOptions_JSType_enum_t JS_NORMAL = 0;
  const FieldOptions_JSType_enum_t JS_STRING = 1;
  const FieldOptions_JSType_enum_t JS_NUMBER = 2;
  private static dict<int, string> $itos = dict[
    0 => 'JS_NORMAL',
    1 => 'JS_STRING',
    2 => 'JS_NUMBER',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'JS_NORMAL' => 0,
    'JS_STRING' => 1,
    'JS_NUMBER' => 2,
  ];
  public static function FromMixed(mixed $m): FieldOptions_JSType_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_JSType_enum_t {
    return $i;
  }
}

newtype FieldOptions_OptionRetention_enum_t as int = int;
abstract class FieldOptions_OptionRetention {
  const FieldOptions_OptionRetention_enum_t RETENTION_UNKNOWN = 0;
  const FieldOptions_OptionRetention_enum_t RETENTION_RUNTIME = 1;
  const FieldOptions_OptionRetention_enum_t RETENTION_SOURCE = 2;
  private static dict<int, string> $itos = dict[
    0 => 'RETENTION_UNKNOWN',
    1 => 'RETENTION_RUNTIME',
    2 => 'RETENTION_SOURCE',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'RETENTION_UNKNOWN' => 0,
    'RETENTION_RUNTIME' => 1,
    'RETENTION_SOURCE' => 2,
  ];
  public static function FromMixed(mixed $m): FieldOptions_OptionRetention_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_OptionRetention_enum_t {
    return $i;
  }
}

newtype FieldOptions_OptionTargetType_enum_t as int = int;
abstract class FieldOptions_OptionTargetType {
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_UNKNOWN = 0;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_FILE = 1;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_EXTENSION_RANGE = 2;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_MESSAGE = 3;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_FIELD = 4;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_ONEOF = 5;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_ENUM = 6;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_ENUM_ENTRY = 7;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_SERVICE = 8;
  const FieldOptions_OptionTargetType_enum_t TARGET_TYPE_METHOD = 9;
  private static dict<int, string> $itos = dict[
    0 => 'TARGET_TYPE_UNKNOWN',
    1 => 'TARGET_TYPE_FILE',
    2 => 'TARGET_TYPE_EXTENSION_RANGE',
    3 => 'TARGET_TYPE_MESSAGE',
    4 => 'TARGET_TYPE_FIELD',
    5 => 'TARGET_TYPE_ONEOF',
    6 => 'TARGET_TYPE_ENUM',
    7 => 'TARGET_TYPE_ENUM_ENTRY',
    8 => 'TARGET_TYPE_SERVICE',
    9 => 'TARGET_TYPE_METHOD',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'TARGET_TYPE_UNKNOWN' => 0,
    'TARGET_TYPE_FILE' => 1,
    'TARGET_TYPE_EXTENSION_RANGE' => 2,
    'TARGET_TYPE_MESSAGE' => 3,
    'TARGET_TYPE_FIELD' => 4,
    'TARGET_TYPE_ONEOF' => 5,
    'TARGET_TYPE_ENUM' => 6,
    'TARGET_TYPE_ENUM_ENTRY' => 7,
    'TARGET_TYPE_SERVICE' => 8,
    'TARGET_TYPE_METHOD' => 9,
  ];
  public static function FromMixed(mixed $m): FieldOptions_OptionTargetType_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_OptionTargetType_enum_t {
    return $i;
  }
}

class FieldOptions_EditionDefault implements \Protobuf\Message {
  private \google\protobuf\Edition_enum_t $edition;
  private bool $was_edition_set;
  private string $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'edition' => \google\protobuf\Edition_enum_t,
    ?'value' => string,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'edition')) {
      $this->edition = $s['edition'];
      $this->was_edition_set = true;
    } else {
      $this->edition = \google\protobuf\Edition::EDITION_UNKNOWN;
      $this->was_edition_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = '';
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getEdition(): \google\protobuf\Edition_enum_t {
    return $this->edition;
  }

  public function setEdition(\google\protobuf\Edition_enum_t $v): void {
    $this->edition = $v;
    $this->was_edition_set = true;
  }

  public function hasEdition(): bool {
    return $this->was_edition_set;
  }

  public function getValue(): string {
    return $this->value;
  }

  public function setValue(string $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FieldOptions.EditionDefault";
  }

  public static function ParseFrom(string $input): ?FieldOptions_EditionDefault {
    $msg = new FieldOptions_EditionDefault();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $this->value = $d->readString();
          $this->was_value_set = true;
          break;
        case 3:
          $this->edition = \google\protobuf\Edition::FromInt($d->readVarint());
          $this->was_edition_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_value_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->value);
    }
    if ($this->was_edition_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->edition);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasValue()) {
      $e->writeString('value', 'value', $this->value, false);
    }
    if ($this->hasEdition()) {
      $e->writeEnum('edition', 'edition', \google\protobuf\Edition::ToStringDict(), $this->edition, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_value_set = true;
          break;
        case 'edition':
          $this->edition = \google\protobuf\Edition::FromMixed($v);
          $this->was_edition_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FieldOptions_EditionDefault)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    if ($o->hasEdition()) {
      $this->setEdition($o->getEdition());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class FieldOptions implements \Protobuf\Message {
  private \google\protobuf\FieldOptions_CType_enum_t $ctype;
  private bool $was_ctype_set;
  private bool $packed;
  private bool $was_packed_set;
  private \google\protobuf\FieldOptions_JSType_enum_t $jstype;
  private bool $was_jstype_set;
  private bool $lazy;
  private bool $was_lazy_set;
  private bool $unverified_lazy;
  private bool $was_unverified_lazy_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  private bool $weak;
  private bool $was_weak_set;
  private bool $debug_redact;
  private bool $was_debug_redact_set;
  private \google\protobuf\FieldOptions_OptionRetention_enum_t $retention;
  private bool $was_retention_set;
  public vec<\google\protobuf\FieldOptions_OptionTargetType_enum_t> $targets;
  public vec<\google\protobuf\FieldOptions_EditionDefault> $edition_defaults;
  private ?\google\protobuf\FeatureSet $features;
  private bool $was_features_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'ctype' => \google\protobuf\FieldOptions_CType_enum_t,
    ?'packed' => bool,
    ?'jstype' => \google\protobuf\FieldOptions_JSType_enum_t,
    ?'lazy' => bool,
    ?'unverified_lazy' => bool,
    ?'deprecated' => bool,
    ?'weak' => bool,
    ?'debug_redact' => bool,
    ?'retention' => \google\protobuf\FieldOptions_OptionRetention_enum_t,
    ?'targets' => vec<\google\protobuf\FieldOptions_OptionTargetType_enum_t>,
    ?'edition_defaults' => vec<\google\protobuf\FieldOptions_EditionDefault>,
    ?'features' => ?\google\protobuf\FeatureSet,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'ctype')) {
      $this->ctype = $s['ctype'];
      $this->was_ctype_set = true;
    } else {
      $this->ctype = \google\protobuf\FieldOptions_CType::STRING;
      $this->was_ctype_set = false;
    }
    if (Shapes::keyExists($s, 'packed')) {
      $this->packed = $s['packed'];
      $this->was_packed_set = true;
    } else {
      $this->packed = false;
      $this->was_packed_set = false;
    }
    if (Shapes::keyExists($s, 'jstype')) {
      $this->jstype = $s['jstype'];
      $this->was_jstype_set = true;
    } else {
      $this->jstype = \google\protobuf\FieldOptions_JSType::JS_NORMAL;
      $this->was_jstype_set = false;
    }
    if (Shapes::keyExists($s, 'lazy')) {
      $this->lazy = $s['lazy'];
      $this->was_lazy_set = true;
    } else {
      $this->lazy = false;
      $this->was_lazy_set = false;
    }
    if (Shapes::keyExists($s, 'unverified_lazy')) {
      $this->unverified_lazy = $s['unverified_lazy'];
      $this->was_unverified_lazy_set = true;
    } else {
      $this->unverified_lazy = false;
      $this->was_unverified_lazy_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'weak')) {
      $this->weak = $s['weak'];
      $this->was_weak_set = true;
    } else {
      $this->weak = false;
      $this->was_weak_set = false;
    }
    if (Shapes::keyExists($s, 'debug_redact')) {
      $this->debug_redact = $s['debug_redact'];
      $this->was_debug_redact_set = true;
    } else {
      $this->debug_redact = false;
      $this->was_debug_redact_set = false;
    }
    if (Shapes::keyExists($s, 'retention')) {
      $this->retention = $s['retention'];
      $this->was_retention_set = true;
    } else {
      $this->retention = \google\protobuf\FieldOptions_OptionRetention::RETENTION_UNKNOWN;
      $this->was_retention_set = false;
    }
    $this->targets = $s['targets'] ?? vec[];
    $this->edition_defaults = $s['edition_defaults'] ?? vec[];
    if (Shapes::keyExists($s, 'features')) {
      $this->features = $s['features'];
      $this->was_features_set = true;
    } else {
      $this->features = null;
      $this->was_features_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getCtype(): \google\protobuf\FieldOptions_CType_enum_t {
    return $this->ctype;
  }

  public function setCtype(\google\protobuf\FieldOptions_CType_enum_t $v): void {
    $this->ctype = $v;
    $this->was_ctype_set = true;
  }

  public function hasCtype(): bool {
    return $this->was_ctype_set;
  }

  public function getPacked(): bool {
    return $this->packed;
  }

  public function setPacked(bool $v): void {
    $this->packed = $v;
    $this->was_packed_set = true;
  }

  public function hasPacked(): bool {
    return $this->was_packed_set;
  }

  public function getJstype(): \google\protobuf\FieldOptions_JSType_enum_t {
    return $this->jstype;
  }

  public function setJstype(\google\protobuf\FieldOptions_JSType_enum_t $v): void {
    $this->jstype = $v;
    $this->was_jstype_set = true;
  }

  public function hasJstype(): bool {
    return $this->was_jstype_set;
  }

  public function getLazy(): bool {
    return $this->lazy;
  }

  public function setLazy(bool $v): void {
    $this->lazy = $v;
    $this->was_lazy_set = true;
  }

  public function hasLazy(): bool {
    return $this->was_lazy_set;
  }

  public function getUnverifiedLazy(): bool {
    return $this->unverified_lazy;
  }

  public function setUnverifiedLazy(bool $v): void {
    $this->unverified_lazy = $v;
    $this->was_unverified_lazy_set = true;
  }

  public function hasUnverifiedLazy(): bool {
    return $this->was_unverified_lazy_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getWeak(): bool {
    return $this->weak;
  }

  public function setWeak(bool $v): void {
    $this->weak = $v;
    $this->was_weak_set = true;
  }

  public function hasWeak(): bool {
    return $this->was_weak_set;
  }

  public function getDebugRedact(): bool {
    return $this->debug_redact;
  }

  public function setDebugRedact(bool $v): void {
    $this->debug_redact = $v;
    $this->was_debug_redact_set = true;
  }

  public function hasDebugRedact(): bool {
    return $this->was_debug_redact_set;
  }

  public function getRetention(): \google\protobuf\FieldOptions_OptionRetention_enum_t {
    return $this->retention;
  }

  public function setRetention(\google\protobuf\FieldOptions_OptionRetention_enum_t $v): void {
    $this->retention = $v;
    $this->was_retention_set = true;
  }

  public function hasRetention(): bool {
    return $this->was_retention_set;
  }

  public function getFeatures(): ?\google\protobuf\FeatureSet {
    return $this->features;
  }

  public function setFeatures(?\google\protobuf\FeatureSet $v): void {
    $this->features = $v;
    $this->was_features_set = true;
  }

  public function hasFeatures(): bool {
    return $this->was_features_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FieldOptions";
  }

  public static function ParseFrom(string $input): ?FieldOptions {
    $msg = new FieldOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->ctype = \google\protobuf\FieldOptions_CType::FromInt($d->readVarint());
          $this->was_ctype_set = true;
          break;
        case 2:
          $this->packed = $d->readBool();
          $this->was_packed_set = true;
          break;
        case 3:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 5:
          $this->lazy = $d->readBool();
          $this->was_lazy_set = true;
          break;
        case 6:
          $this->jstype = \google\protobuf\FieldOptions_JSType::FromInt($d->readVarint());
          $this->was_jstype_set = true;
          break;
        case 10:
          $this->weak = $d->readBool();
          $this->was_weak_set = true;
          break;
        case 15:
          $this->unverified_lazy = $d->readBool();
          $this->was_unverified_lazy_set = true;
          break;
        case 16:
          $this->debug_redact = $d->readBool();
          $this->was_debug_redact_set = true;
          break;
        case 17:
          $this->retention = \google\protobuf\FieldOptions_OptionRetention::FromInt($d->readVarint());
          $this->was_retention_set = true;
          break;
        case 19:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->targets []= \google\protobuf\FieldOptions_OptionTargetType::FromInt($packed->readVarint());
            }
          } else {
            $this->targets []= \google\protobuf\FieldOptions_OptionTargetType::FromInt($d->readVarint());
          }
          break;
        case 20:
          $obj = new \google\protobuf\FieldOptions_EditionDefault();
          $obj->MergeFrom($d->readDecoder());
          $this->edition_defaults []= $obj;
          break;
        case 21:
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeFrom($d->readDecoder());
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_ctype_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->ctype);
    }
    if ($this->was_packed_set) {
      $e->writeTag(2, 0);
      $e->writeBool($this->packed);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_lazy_set) {
      $e->writeTag(5, 0);
      $e->writeBool($this->lazy);
    }
    if ($this->was_jstype_set) {
      $e->writeTag(6, 0);
      $e->writeVarint($this->jstype);
    }
    if ($this->was_weak_set) {
      $e->writeTag(10, 0);
      $e->writeBool($this->weak);
    }
    if ($this->was_unverified_lazy_set) {
      $e->writeTag(15, 0);
      $e->writeBool($this->unverified_lazy);
    }
    if ($this->was_debug_redact_set) {
      $e->writeTag(16, 0);
      $e->writeBool($this->debug_redact);
    }
    if ($this->was_retention_set) {
      $e->writeTag(17, 0);
      $e->writeVarint($this->retention);
    }
    foreach ($this->targets as $elem) {
      $e->writeTag(19, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->edition_defaults as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 20);
    }
    $msg = $this->features;
    if ($msg != null) {
      if ($this->was_features_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 21);
      }
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasCtype()) {
      $e->writeEnum('ctype', 'ctype', \google\protobuf\FieldOptions_CType::ToStringDict(), $this->ctype, false);
    }
    if ($this->hasPacked()) {
      $e->writeBool('packed', 'packed', $this->packed, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasLazy()) {
      $e->writeBool('lazy', 'lazy', $this->lazy, false);
    }
    if ($this->hasJstype()) {
      $e->writeEnum('jstype', 'jstype', \google\protobuf\FieldOptions_JSType::ToStringDict(), $this->jstype, false);
    }
    if ($this->hasWeak()) {
      $e->writeBool('weak', 'weak', $this->weak, false);
    }
    if ($this->hasUnverifiedLazy()) {
      $e->writeBool('unverified_lazy', 'unverifiedLazy', $this->unverified_lazy, false);
    }
    if ($this->hasDebugRedact()) {
      $e->writeBool('debug_redact', 'debugRedact', $this->debug_redact, false);
    }
    if ($this->hasRetention()) {
      $e->writeEnum('retention', 'retention', \google\protobuf\FieldOptions_OptionRetention::ToStringDict(), $this->retention, false);
    }
    $e->writeEnumList('targets', 'targets', \google\protobuf\FieldOptions_OptionTargetType::ToStringDict(), $this->targets);
    $e->writeMessageList('edition_defaults', 'editionDefaults', $this->edition_defaults);
    if ($this->hasFeatures()) {
      $e->writeMessage('features', 'features', $this->features, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'ctype':
          $this->ctype = \google\protobuf\FieldOptions_CType::FromMixed($v);
          $this->was_ctype_set = true;
          break;
        case 'packed':
          $this->packed = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_packed_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'lazy':
          $this->lazy = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_lazy_set = true;
          break;
        case 'jstype':
          $this->jstype = \google\protobuf\FieldOptions_JSType::FromMixed($v);
          $this->was_jstype_set = true;
          break;
        case 'weak':
          $this->weak = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_weak_set = true;
          break;
        case 'unverified_lazy': case 'unverifiedLazy':
          $this->unverified_lazy = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_unverified_lazy_set = true;
          break;
        case 'debug_redact': case 'debugRedact':
          $this->debug_redact = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_debug_redact_set = true;
          break;
        case 'retention':
          $this->retention = \google\protobuf\FieldOptions_OptionRetention::FromMixed($v);
          $this->was_retention_set = true;
          break;
        case 'targets':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->targets []= \google\protobuf\FieldOptions_OptionTargetType::FromMixed($vv);
          }
          break;
        case 'edition_defaults': case 'editionDefaults':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldOptions_EditionDefault();
            $obj->MergeJsonFrom($vv);
            $this->edition_defaults []= $obj;
          }
          break;
        case 'features':
          if ($v is null) break;
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeJsonFrom($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FieldOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasCtype()) {
      $this->setCtype($o->getCtype());
    }
    if ($o->hasPacked()) {
      $this->setPacked($o->getPacked());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasLazy()) {
      $this->setLazy($o->getLazy());
    }
    if ($o->hasJstype()) {
      $this->setJstype($o->getJstype());
    }
    if ($o->hasWeak()) {
      $this->setWeak($o->getWeak());
    }
    if ($o->hasUnverifiedLazy()) {
      $this->setUnverifiedLazy($o->getUnverifiedLazy());
    }
    if ($o->hasDebugRedact()) {
      $this->setDebugRedact($o->getDebugRedact());
    }
    if ($o->hasRetention()) {
      $this->setRetention($o->getRetention());
    }
    $this->targets = $o->targets;
    foreach ($o->edition_defaults as $v) {
      $nv = new \google\protobuf\FieldOptions_EditionDefault();
      $nv->CopyFrom($v);
      $this->edition_defaults []= $nv;
    }
    $tmp = $o->features;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FeatureSet();
      $nv->CopyFrom($tmp);
      $this->setFeatures($nv);
    } else if ($o->hasFeatures()) {
      $this->setFeatures(null);
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class OneofOptions implements \Protobuf\Message {
  private ?\google\protobuf\FeatureSet $features;
  private bool $was_features_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'features' => ?\google\protobuf\FeatureSet,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'features')) {
      $this->features = $s['features'];
      $this->was_features_set = true;
    } else {
      $this->features = null;
      $this->was_features_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getFeatures(): ?\google\protobuf\FeatureSet {
    return $this->features;
  }

  public function setFeatures(?\google\protobuf\FeatureSet $v): void {
    $this->features = $v;
    $this->was_features_set = true;
  }

  public function hasFeatures(): bool {
    return $this->was_features_set;
  }

  public function MessageName(): string {
    return "google.protobuf.OneofOptions";
  }

  public static function ParseFrom(string $input): ?OneofOptions {
    $msg = new OneofOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeFrom($d->readDecoder());
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $msg = $this->features;
    if ($msg != null) {
      if ($this->was_features_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 1);
      }
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasFeatures()) {
      $e->writeMessage('features', 'features', $this->features, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'features':
          if ($v is null) break;
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeJsonFrom($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is OneofOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $tmp = $o->features;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FeatureSet();
      $nv->CopyFrom($tmp);
      $this->setFeatures($nv);
    } else if ($o->hasFeatures()) {
      $this->setFeatures(null);
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumOptions implements \Protobuf\Message {
  private bool $allow_alias;
  private bool $was_allow_alias_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  private bool $deprecated_legacy_json_field_conflicts;
  private bool $was_deprecated_legacy_json_field_conflicts_set;
  private ?\google\protobuf\FeatureSet $features;
  private bool $was_features_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'allow_alias' => bool,
    ?'deprecated' => bool,
    ?'deprecated_legacy_json_field_conflicts' => bool,
    ?'features' => ?\google\protobuf\FeatureSet,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'allow_alias')) {
      $this->allow_alias = $s['allow_alias'];
      $this->was_allow_alias_set = true;
    } else {
      $this->allow_alias = false;
      $this->was_allow_alias_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated_legacy_json_field_conflicts')) {
      $this->deprecated_legacy_json_field_conflicts = $s['deprecated_legacy_json_field_conflicts'];
      $this->was_deprecated_legacy_json_field_conflicts_set = true;
    } else {
      $this->deprecated_legacy_json_field_conflicts = false;
      $this->was_deprecated_legacy_json_field_conflicts_set = false;
    }
    if (Shapes::keyExists($s, 'features')) {
      $this->features = $s['features'];
      $this->was_features_set = true;
    } else {
      $this->features = null;
      $this->was_features_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getAllowAlias(): bool {
    return $this->allow_alias;
  }

  public function setAllowAlias(bool $v): void {
    $this->allow_alias = $v;
    $this->was_allow_alias_set = true;
  }

  public function hasAllowAlias(): bool {
    return $this->was_allow_alias_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getDeprecatedLegacyJsonFieldConflicts(): bool {
    return $this->deprecated_legacy_json_field_conflicts;
  }

  public function setDeprecatedLegacyJsonFieldConflicts(bool $v): void {
    $this->deprecated_legacy_json_field_conflicts = $v;
    $this->was_deprecated_legacy_json_field_conflicts_set = true;
  }

  public function hasDeprecatedLegacyJsonFieldConflicts(): bool {
    return $this->was_deprecated_legacy_json_field_conflicts_set;
  }

  public function getFeatures(): ?\google\protobuf\FeatureSet {
    return $this->features;
  }

  public function setFeatures(?\google\protobuf\FeatureSet $v): void {
    $this->features = $v;
    $this->was_features_set = true;
  }

  public function hasFeatures(): bool {
    return $this->was_features_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumOptions";
  }

  public static function ParseFrom(string $input): ?EnumOptions {
    $msg = new EnumOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $this->allow_alias = $d->readBool();
          $this->was_allow_alias_set = true;
          break;
        case 3:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 6:
          $this->deprecated_legacy_json_field_conflicts = $d->readBool();
          $this->was_deprecated_legacy_json_field_conflicts_set = true;
          break;
        case 7:
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeFrom($d->readDecoder());
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_allow_alias_set) {
      $e->writeTag(2, 0);
      $e->writeBool($this->allow_alias);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_deprecated_legacy_json_field_conflicts_set) {
      $e->writeTag(6, 0);
      $e->writeBool($this->deprecated_legacy_json_field_conflicts);
    }
    $msg = $this->features;
    if ($msg != null) {
      if ($this->was_features_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 7);
      }
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasAllowAlias()) {
      $e->writeBool('allow_alias', 'allowAlias', $this->allow_alias, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasDeprecatedLegacyJsonFieldConflicts()) {
      $e->writeBool('deprecated_legacy_json_field_conflicts', 'deprecatedLegacyJsonFieldConflicts', $this->deprecated_legacy_json_field_conflicts, false);
    }
    if ($this->hasFeatures()) {
      $e->writeMessage('features', 'features', $this->features, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'allow_alias': case 'allowAlias':
          $this->allow_alias = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_allow_alias_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'deprecated_legacy_json_field_conflicts': case 'deprecatedLegacyJsonFieldConflicts':
          $this->deprecated_legacy_json_field_conflicts = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_legacy_json_field_conflicts_set = true;
          break;
        case 'features':
          if ($v is null) break;
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeJsonFrom($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasAllowAlias()) {
      $this->setAllowAlias($o->getAllowAlias());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasDeprecatedLegacyJsonFieldConflicts()) {
      $this->setDeprecatedLegacyJsonFieldConflicts($o->getDeprecatedLegacyJsonFieldConflicts());
    }
    $tmp = $o->features;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FeatureSet();
      $nv->CopyFrom($tmp);
      $this->setFeatures($nv);
    } else if ($o->hasFeatures()) {
      $this->setFeatures(null);
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumValueOptions implements \Protobuf\Message {
  private bool $deprecated;
  private bool $was_deprecated_set;
  private ?\google\protobuf\FeatureSet $features;
  private bool $was_features_set;
  private bool $debug_redact;
  private bool $was_debug_redact_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'deprecated' => bool,
    ?'features' => ?\google\protobuf\FeatureSet,
    ?'debug_redact' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'features')) {
      $this->features = $s['features'];
      $this->was_features_set = true;
    } else {
      $this->features = null;
      $this->was_features_set = false;
    }
    if (Shapes::keyExists($s, 'debug_redact')) {
      $this->debug_redact = $s['debug_redact'];
      $this->was_debug_redact_set = true;
    } else {
      $this->debug_redact = false;
      $this->was_debug_redact_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getFeatures(): ?\google\protobuf\FeatureSet {
    return $this->features;
  }

  public function setFeatures(?\google\protobuf\FeatureSet $v): void {
    $this->features = $v;
    $this->was_features_set = true;
  }

  public function hasFeatures(): bool {
    return $this->was_features_set;
  }

  public function getDebugRedact(): bool {
    return $this->debug_redact;
  }

  public function setDebugRedact(bool $v): void {
    $this->debug_redact = $v;
    $this->was_debug_redact_set = true;
  }

  public function hasDebugRedact(): bool {
    return $this->was_debug_redact_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumValueOptions";
  }

  public static function ParseFrom(string $input): ?EnumValueOptions {
    $msg = new EnumValueOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 2:
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeFrom($d->readDecoder());
          break;
        case 3:
          $this->debug_redact = $d->readBool();
          $this->was_debug_redact_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_deprecated_set) {
      $e->writeTag(1, 0);
      $e->writeBool($this->deprecated);
    }
    $msg = $this->features;
    if ($msg != null) {
      if ($this->was_features_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 2);
      }
    }
    if ($this->was_debug_redact_set) {
      $e->writeTag(3, 0);
      $e->writeBool($this->debug_redact);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasFeatures()) {
      $e->writeMessage('features', 'features', $this->features, false);
    }
    if ($this->hasDebugRedact()) {
      $e->writeBool('debug_redact', 'debugRedact', $this->debug_redact, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'features':
          if ($v is null) break;
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeJsonFrom($v);
          break;
        case 'debug_redact': case 'debugRedact':
          $this->debug_redact = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_debug_redact_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumValueOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    $tmp = $o->features;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FeatureSet();
      $nv->CopyFrom($tmp);
      $this->setFeatures($nv);
    } else if ($o->hasFeatures()) {
      $this->setFeatures(null);
    }
    if ($o->hasDebugRedact()) {
      $this->setDebugRedact($o->getDebugRedact());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ServiceOptions implements \Protobuf\Message {
  private ?\google\protobuf\FeatureSet $features;
  private bool $was_features_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'features' => ?\google\protobuf\FeatureSet,
    ?'deprecated' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'features')) {
      $this->features = $s['features'];
      $this->was_features_set = true;
    } else {
      $this->features = null;
      $this->was_features_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getFeatures(): ?\google\protobuf\FeatureSet {
    return $this->features;
  }

  public function setFeatures(?\google\protobuf\FeatureSet $v): void {
    $this->features = $v;
    $this->was_features_set = true;
  }

  public function hasFeatures(): bool {
    return $this->was_features_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function MessageName(): string {
    return "google.protobuf.ServiceOptions";
  }

  public static function ParseFrom(string $input): ?ServiceOptions {
    $msg = new ServiceOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 34:
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeFrom($d->readDecoder());
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_deprecated_set) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    $msg = $this->features;
    if ($msg != null) {
      if ($this->was_features_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 34);
      }
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasFeatures()) {
      $e->writeMessage('features', 'features', $this->features, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'features':
          if ($v is null) break;
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeJsonFrom($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ServiceOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    $tmp = $o->features;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FeatureSet();
      $nv->CopyFrom($tmp);
      $this->setFeatures($nv);
    } else if ($o->hasFeatures()) {
      $this->setFeatures(null);
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype MethodOptions_IdempotencyLevel_enum_t as int = int;
abstract class MethodOptions_IdempotencyLevel {
  const MethodOptions_IdempotencyLevel_enum_t IDEMPOTENCY_UNKNOWN = 0;
  const MethodOptions_IdempotencyLevel_enum_t NO_SIDE_EFFECTS = 1;
  const MethodOptions_IdempotencyLevel_enum_t IDEMPOTENT = 2;
  private static dict<int, string> $itos = dict[
    0 => 'IDEMPOTENCY_UNKNOWN',
    1 => 'NO_SIDE_EFFECTS',
    2 => 'IDEMPOTENT',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'IDEMPOTENCY_UNKNOWN' => 0,
    'NO_SIDE_EFFECTS' => 1,
    'IDEMPOTENT' => 2,
  ];
  public static function FromMixed(mixed $m): MethodOptions_IdempotencyLevel_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): MethodOptions_IdempotencyLevel_enum_t {
    return $i;
  }
}

class MethodOptions implements \Protobuf\Message {
  private bool $deprecated;
  private bool $was_deprecated_set;
  private \google\protobuf\MethodOptions_IdempotencyLevel_enum_t $idempotency_level;
  private bool $was_idempotency_level_set;
  private ?\google\protobuf\FeatureSet $features;
  private bool $was_features_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'deprecated' => bool,
    ?'idempotency_level' => \google\protobuf\MethodOptions_IdempotencyLevel_enum_t,
    ?'features' => ?\google\protobuf\FeatureSet,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'idempotency_level')) {
      $this->idempotency_level = $s['idempotency_level'];
      $this->was_idempotency_level_set = true;
    } else {
      $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::IDEMPOTENCY_UNKNOWN;
      $this->was_idempotency_level_set = false;
    }
    if (Shapes::keyExists($s, 'features')) {
      $this->features = $s['features'];
      $this->was_features_set = true;
    } else {
      $this->features = null;
      $this->was_features_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getIdempotencyLevel(): \google\protobuf\MethodOptions_IdempotencyLevel_enum_t {
    return $this->idempotency_level;
  }

  public function setIdempotencyLevel(\google\protobuf\MethodOptions_IdempotencyLevel_enum_t $v): void {
    $this->idempotency_level = $v;
    $this->was_idempotency_level_set = true;
  }

  public function hasIdempotencyLevel(): bool {
    return $this->was_idempotency_level_set;
  }

  public function getFeatures(): ?\google\protobuf\FeatureSet {
    return $this->features;
  }

  public function setFeatures(?\google\protobuf\FeatureSet $v): void {
    $this->features = $v;
    $this->was_features_set = true;
  }

  public function hasFeatures(): bool {
    return $this->was_features_set;
  }

  public function MessageName(): string {
    return "google.protobuf.MethodOptions";
  }

  public static function ParseFrom(string $input): ?MethodOptions {
    $msg = new MethodOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 34:
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::FromInt($d->readVarint());
          $this->was_idempotency_level_set = true;
          break;
        case 35:
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeFrom($d->readDecoder());
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_deprecated_set) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_idempotency_level_set) {
      $e->writeTag(34, 0);
      $e->writeVarint($this->idempotency_level);
    }
    $msg = $this->features;
    if ($msg != null) {
      if ($this->was_features_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 35);
      }
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasIdempotencyLevel()) {
      $e->writeEnum('idempotency_level', 'idempotencyLevel', \google\protobuf\MethodOptions_IdempotencyLevel::ToStringDict(), $this->idempotency_level, false);
    }
    if ($this->hasFeatures()) {
      $e->writeMessage('features', 'features', $this->features, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'idempotency_level': case 'idempotencyLevel':
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::FromMixed($v);
          $this->was_idempotency_level_set = true;
          break;
        case 'features':
          if ($v is null) break;
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeJsonFrom($v);
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MethodOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasIdempotencyLevel()) {
      $this->setIdempotencyLevel($o->getIdempotencyLevel());
    }
    $tmp = $o->features;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FeatureSet();
      $nv->CopyFrom($tmp);
      $this->setFeatures($nv);
    } else if ($o->hasFeatures()) {
      $this->setFeatures(null);
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UninterpretedOption_NamePart implements \Protobuf\Message {
  public string $name_part;
  public bool $is_extension;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name_part' => string,
    ?'is_extension' => bool,
  ) $s = shape()) {
    $this->name_part = $s['name_part'] ?? '';
    $this->is_extension = $s['is_extension'] ?? false;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.UninterpretedOption.NamePart";
  }

  public static function ParseFrom(string $input): ?UninterpretedOption_NamePart {
    $msg = new UninterpretedOption_NamePart();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name_part = $d->readString();
          break;
        case 2:
          $this->is_extension = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name_part !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name_part);
    }
    if ($this->is_extension !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->is_extension);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name_part', 'namePart', $this->name_part, false);
    $e->writeBool('is_extension', 'isExtension', $this->is_extension, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name_part': case 'namePart':
          $this->name_part = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'is_extension': case 'isExtension':
          $this->is_extension = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UninterpretedOption_NamePart)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name_part = $o->name_part;
    $this->is_extension = $o->is_extension;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UninterpretedOption implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption_NamePart> $name;
  private string $identifier_value;
  private bool $was_identifier_value_set;
  private int $positive_int_value;
  private bool $was_positive_int_value_set;
  private int $negative_int_value;
  private bool $was_negative_int_value_set;
  private float $double_value;
  private bool $was_double_value_set;
  private string $string_value;
  private bool $was_string_value_set;
  private string $aggregate_value;
  private bool $was_aggregate_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => vec<\google\protobuf\UninterpretedOption_NamePart>,
    ?'identifier_value' => string,
    ?'positive_int_value' => int,
    ?'negative_int_value' => int,
    ?'double_value' => float,
    ?'string_value' => string,
    ?'aggregate_value' => string,
  ) $s = shape()) {
    $this->name = $s['name'] ?? vec[];
    if (Shapes::keyExists($s, 'identifier_value')) {
      $this->identifier_value = $s['identifier_value'];
      $this->was_identifier_value_set = true;
    } else {
      $this->identifier_value = '';
      $this->was_identifier_value_set = false;
    }
    if (Shapes::keyExists($s, 'positive_int_value')) {
      $this->positive_int_value = $s['positive_int_value'];
      $this->was_positive_int_value_set = true;
    } else {
      $this->positive_int_value = 0;
      $this->was_positive_int_value_set = false;
    }
    if (Shapes::keyExists($s, 'negative_int_value')) {
      $this->negative_int_value = $s['negative_int_value'];
      $this->was_negative_int_value_set = true;
    } else {
      $this->negative_int_value = 0;
      $this->was_negative_int_value_set = false;
    }
    if (Shapes::keyExists($s, 'double_value')) {
      $this->double_value = $s['double_value'];
      $this->was_double_value_set = true;
    } else {
      $this->double_value = 0.0;
      $this->was_double_value_set = false;
    }
    if (Shapes::keyExists($s, 'string_value')) {
      $this->string_value = $s['string_value'];
      $this->was_string_value_set = true;
    } else {
      $this->string_value = '';
      $this->was_string_value_set = false;
    }
    if (Shapes::keyExists($s, 'aggregate_value')) {
      $this->aggregate_value = $s['aggregate_value'];
      $this->was_aggregate_value_set = true;
    } else {
      $this->aggregate_value = '';
      $this->was_aggregate_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getIdentifierValue(): string {
    return $this->identifier_value;
  }

  public function setIdentifierValue(string $v): void {
    $this->identifier_value = $v;
    $this->was_identifier_value_set = true;
  }

  public function hasIdentifierValue(): bool {
    return $this->was_identifier_value_set;
  }

  public function getPositiveIntValue(): int {
    return $this->positive_int_value;
  }

  public function setPositiveIntValue(int $v): void {
    $this->positive_int_value = $v;
    $this->was_positive_int_value_set = true;
  }

  public function hasPositiveIntValue(): bool {
    return $this->was_positive_int_value_set;
  }

  public function getNegativeIntValue(): int {
    return $this->negative_int_value;
  }

  public function setNegativeIntValue(int $v): void {
    $this->negative_int_value = $v;
    $this->was_negative_int_value_set = true;
  }

  public function hasNegativeIntValue(): bool {
    return $this->was_negative_int_value_set;
  }

  public function getDoubleValue(): float {
    return $this->double_value;
  }

  public function setDoubleValue(float $v): void {
    $this->double_value = $v;
    $this->was_double_value_set = true;
  }

  public function hasDoubleValue(): bool {
    return $this->was_double_value_set;
  }

  public function getStringValue(): string {
    return $this->string_value;
  }

  public function setStringValue(string $v): void {
    $this->string_value = $v;
    $this->was_string_value_set = true;
  }

  public function hasStringValue(): bool {
    return $this->was_string_value_set;
  }

  public function getAggregateValue(): string {
    return $this->aggregate_value;
  }

  public function setAggregateValue(string $v): void {
    $this->aggregate_value = $v;
    $this->was_aggregate_value_set = true;
  }

  public function hasAggregateValue(): bool {
    return $this->was_aggregate_value_set;
  }

  public function MessageName(): string {
    return "google.protobuf.UninterpretedOption";
  }

  public static function ParseFrom(string $input): ?UninterpretedOption {
    $msg = new UninterpretedOption();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $obj = new \google\protobuf\UninterpretedOption_NamePart();
          $obj->MergeFrom($d->readDecoder());
          $this->name []= $obj;
          break;
        case 3:
          $this->identifier_value = $d->readString();
          $this->was_identifier_value_set = true;
          break;
        case 4:
          $this->positive_int_value = $d->readVarint();
          $this->was_positive_int_value_set = true;
          break;
        case 5:
          $this->negative_int_value = $d->readVarint();
          $this->was_negative_int_value_set = true;
          break;
        case 6:
          $this->double_value = $d->readDouble();
          $this->was_double_value_set = true;
          break;
        case 7:
          $this->string_value = $d->readString();
          $this->was_string_value_set = true;
          break;
        case 8:
          $this->aggregate_value = $d->readString();
          $this->was_aggregate_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->name as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    if ($this->was_identifier_value_set) {
      $e->writeTag(3, 2);
      $e->writeString($this->identifier_value);
    }
    if ($this->was_positive_int_value_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->positive_int_value);
    }
    if ($this->was_negative_int_value_set) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->negative_int_value);
    }
    if ($this->was_double_value_set) {
      $e->writeTag(6, 1);
      $e->writeDouble($this->double_value);
    }
    if ($this->was_string_value_set) {
      $e->writeTag(7, 2);
      $e->writeString($this->string_value);
    }
    if ($this->was_aggregate_value_set) {
      $e->writeTag(8, 2);
      $e->writeString($this->aggregate_value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('name', 'name', $this->name);
    if ($this->hasIdentifierValue()) {
      $e->writeString('identifier_value', 'identifierValue', $this->identifier_value, false);
    }
    if ($this->hasPositiveIntValue()) {
      $e->writeInt64Unsigned('positive_int_value', 'positiveIntValue', $this->positive_int_value, false);
    }
    if ($this->hasNegativeIntValue()) {
      $e->writeInt64Signed('negative_int_value', 'negativeIntValue', $this->negative_int_value, false);
    }
    if ($this->hasDoubleValue()) {
      $e->writeFloat('double_value', 'doubleValue', $this->double_value, false);
    }
    if ($this->hasStringValue()) {
      $e->writeBytes('string_value', 'stringValue', $this->string_value, false);
    }
    if ($this->hasAggregateValue()) {
      $e->writeString('aggregate_value', 'aggregateValue', $this->aggregate_value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption_NamePart();
            $obj->MergeJsonFrom($vv);
            $this->name []= $obj;
          }
          break;
        case 'identifier_value': case 'identifierValue':
          $this->identifier_value = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_identifier_value_set = true;
          break;
        case 'positive_int_value': case 'positiveIntValue':
          $this->positive_int_value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          $this->was_positive_int_value_set = true;
          break;
        case 'negative_int_value': case 'negativeIntValue':
          $this->negative_int_value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_negative_int_value_set = true;
          break;
        case 'double_value': case 'doubleValue':
          $this->double_value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          $this->was_double_value_set = true;
          break;
        case 'string_value': case 'stringValue':
          $this->string_value = \Protobuf\Internal\JsonDecoder::readBytes($v);
          $this->was_string_value_set = true;
          break;
        case 'aggregate_value': case 'aggregateValue':
          $this->aggregate_value = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_aggregate_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UninterpretedOption)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->name as $v) {
      $nv = new \google\protobuf\UninterpretedOption_NamePart();
      $nv->CopyFrom($v);
      $this->name []= $nv;
    }
    if ($o->hasIdentifierValue()) {
      $this->setIdentifierValue($o->getIdentifierValue());
    }
    if ($o->hasPositiveIntValue()) {
      $this->setPositiveIntValue($o->getPositiveIntValue());
    }
    if ($o->hasNegativeIntValue()) {
      $this->setNegativeIntValue($o->getNegativeIntValue());
    }
    if ($o->hasDoubleValue()) {
      $this->setDoubleValue($o->getDoubleValue());
    }
    if ($o->hasStringValue()) {
      $this->setStringValue($o->getStringValue());
    }
    if ($o->hasAggregateValue()) {
      $this->setAggregateValue($o->getAggregateValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FeatureSet_FieldPresence_enum_t as int = int;
abstract class FeatureSet_FieldPresence {
  const FeatureSet_FieldPresence_enum_t FIELD_PRESENCE_UNKNOWN = 0;
  const FeatureSet_FieldPresence_enum_t EXPLICIT = 1;
  const FeatureSet_FieldPresence_enum_t IMPLICIT = 2;
  const FeatureSet_FieldPresence_enum_t LEGACY_REQUIRED = 3;
  private static dict<int, string> $itos = dict[
    0 => 'FIELD_PRESENCE_UNKNOWN',
    1 => 'EXPLICIT',
    2 => 'IMPLICIT',
    3 => 'LEGACY_REQUIRED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FIELD_PRESENCE_UNKNOWN' => 0,
    'EXPLICIT' => 1,
    'IMPLICIT' => 2,
    'LEGACY_REQUIRED' => 3,
  ];
  public static function FromMixed(mixed $m): FeatureSet_FieldPresence_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FeatureSet_FieldPresence_enum_t {
    return $i;
  }
}

newtype FeatureSet_EnumType_enum_t as int = int;
abstract class FeatureSet_EnumType {
  const FeatureSet_EnumType_enum_t ENUM_TYPE_UNKNOWN = 0;
  const FeatureSet_EnumType_enum_t OPEN = 1;
  const FeatureSet_EnumType_enum_t CLOSED = 2;
  private static dict<int, string> $itos = dict[
    0 => 'ENUM_TYPE_UNKNOWN',
    1 => 'OPEN',
    2 => 'CLOSED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'ENUM_TYPE_UNKNOWN' => 0,
    'OPEN' => 1,
    'CLOSED' => 2,
  ];
  public static function FromMixed(mixed $m): FeatureSet_EnumType_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FeatureSet_EnumType_enum_t {
    return $i;
  }
}

newtype FeatureSet_RepeatedFieldEncoding_enum_t as int = int;
abstract class FeatureSet_RepeatedFieldEncoding {
  const FeatureSet_RepeatedFieldEncoding_enum_t REPEATED_FIELD_ENCODING_UNKNOWN = 0;
  const FeatureSet_RepeatedFieldEncoding_enum_t PACKED = 1;
  const FeatureSet_RepeatedFieldEncoding_enum_t EXPANDED = 2;
  private static dict<int, string> $itos = dict[
    0 => 'REPEATED_FIELD_ENCODING_UNKNOWN',
    1 => 'PACKED',
    2 => 'EXPANDED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'REPEATED_FIELD_ENCODING_UNKNOWN' => 0,
    'PACKED' => 1,
    'EXPANDED' => 2,
  ];
  public static function FromMixed(mixed $m): FeatureSet_RepeatedFieldEncoding_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FeatureSet_RepeatedFieldEncoding_enum_t {
    return $i;
  }
}

newtype FeatureSet_Utf8Validation_enum_t as int = int;
abstract class FeatureSet_Utf8Validation {
  const FeatureSet_Utf8Validation_enum_t UTF8_VALIDATION_UNKNOWN = 0;
  const FeatureSet_Utf8Validation_enum_t NONE = 1;
  const FeatureSet_Utf8Validation_enum_t VERIFY = 2;
  private static dict<int, string> $itos = dict[
    0 => 'UTF8_VALIDATION_UNKNOWN',
    1 => 'NONE',
    2 => 'VERIFY',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'UTF8_VALIDATION_UNKNOWN' => 0,
    'NONE' => 1,
    'VERIFY' => 2,
  ];
  public static function FromMixed(mixed $m): FeatureSet_Utf8Validation_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FeatureSet_Utf8Validation_enum_t {
    return $i;
  }
}

newtype FeatureSet_MessageEncoding_enum_t as int = int;
abstract class FeatureSet_MessageEncoding {
  const FeatureSet_MessageEncoding_enum_t MESSAGE_ENCODING_UNKNOWN = 0;
  const FeatureSet_MessageEncoding_enum_t LENGTH_PREFIXED = 1;
  const FeatureSet_MessageEncoding_enum_t DELIMITED = 2;
  private static dict<int, string> $itos = dict[
    0 => 'MESSAGE_ENCODING_UNKNOWN',
    1 => 'LENGTH_PREFIXED',
    2 => 'DELIMITED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'MESSAGE_ENCODING_UNKNOWN' => 0,
    'LENGTH_PREFIXED' => 1,
    'DELIMITED' => 2,
  ];
  public static function FromMixed(mixed $m): FeatureSet_MessageEncoding_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FeatureSet_MessageEncoding_enum_t {
    return $i;
  }
}

newtype FeatureSet_JsonFormat_enum_t as int = int;
abstract class FeatureSet_JsonFormat {
  const FeatureSet_JsonFormat_enum_t JSON_FORMAT_UNKNOWN = 0;
  const FeatureSet_JsonFormat_enum_t ALLOW = 1;
  const FeatureSet_JsonFormat_enum_t LEGACY_BEST_EFFORT = 2;
  private static dict<int, string> $itos = dict[
    0 => 'JSON_FORMAT_UNKNOWN',
    1 => 'ALLOW',
    2 => 'LEGACY_BEST_EFFORT',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'JSON_FORMAT_UNKNOWN' => 0,
    'ALLOW' => 1,
    'LEGACY_BEST_EFFORT' => 2,
  ];
  public static function FromMixed(mixed $m): FeatureSet_JsonFormat_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FeatureSet_JsonFormat_enum_t {
    return $i;
  }
}

class FeatureSet implements \Protobuf\Message {
  private \google\protobuf\FeatureSet_FieldPresence_enum_t $field_presence;
  private bool $was_field_presence_set;
  private \google\protobuf\FeatureSet_EnumType_enum_t $enum_type;
  private bool $was_enum_type_set;
  private \google\protobuf\FeatureSet_RepeatedFieldEncoding_enum_t $repeated_field_encoding;
  private bool $was_repeated_field_encoding_set;
  private \google\protobuf\FeatureSet_Utf8Validation_enum_t $utf8_validation;
  private bool $was_utf8_validation_set;
  private \google\protobuf\FeatureSet_MessageEncoding_enum_t $message_encoding;
  private bool $was_message_encoding_set;
  private \google\protobuf\FeatureSet_JsonFormat_enum_t $json_format;
  private bool $was_json_format_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'field_presence' => \google\protobuf\FeatureSet_FieldPresence_enum_t,
    ?'enum_type' => \google\protobuf\FeatureSet_EnumType_enum_t,
    ?'repeated_field_encoding' => \google\protobuf\FeatureSet_RepeatedFieldEncoding_enum_t,
    ?'utf8_validation' => \google\protobuf\FeatureSet_Utf8Validation_enum_t,
    ?'message_encoding' => \google\protobuf\FeatureSet_MessageEncoding_enum_t,
    ?'json_format' => \google\protobuf\FeatureSet_JsonFormat_enum_t,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'field_presence')) {
      $this->field_presence = $s['field_presence'];
      $this->was_field_presence_set = true;
    } else {
      $this->field_presence = \google\protobuf\FeatureSet_FieldPresence::FIELD_PRESENCE_UNKNOWN;
      $this->was_field_presence_set = false;
    }
    if (Shapes::keyExists($s, 'enum_type')) {
      $this->enum_type = $s['enum_type'];
      $this->was_enum_type_set = true;
    } else {
      $this->enum_type = \google\protobuf\FeatureSet_EnumType::ENUM_TYPE_UNKNOWN;
      $this->was_enum_type_set = false;
    }
    if (Shapes::keyExists($s, 'repeated_field_encoding')) {
      $this->repeated_field_encoding = $s['repeated_field_encoding'];
      $this->was_repeated_field_encoding_set = true;
    } else {
      $this->repeated_field_encoding = \google\protobuf\FeatureSet_RepeatedFieldEncoding::REPEATED_FIELD_ENCODING_UNKNOWN;
      $this->was_repeated_field_encoding_set = false;
    }
    if (Shapes::keyExists($s, 'utf8_validation')) {
      $this->utf8_validation = $s['utf8_validation'];
      $this->was_utf8_validation_set = true;
    } else {
      $this->utf8_validation = \google\protobuf\FeatureSet_Utf8Validation::UTF8_VALIDATION_UNKNOWN;
      $this->was_utf8_validation_set = false;
    }
    if (Shapes::keyExists($s, 'message_encoding')) {
      $this->message_encoding = $s['message_encoding'];
      $this->was_message_encoding_set = true;
    } else {
      $this->message_encoding = \google\protobuf\FeatureSet_MessageEncoding::MESSAGE_ENCODING_UNKNOWN;
      $this->was_message_encoding_set = false;
    }
    if (Shapes::keyExists($s, 'json_format')) {
      $this->json_format = $s['json_format'];
      $this->was_json_format_set = true;
    } else {
      $this->json_format = \google\protobuf\FeatureSet_JsonFormat::JSON_FORMAT_UNKNOWN;
      $this->was_json_format_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getFieldPresence(): \google\protobuf\FeatureSet_FieldPresence_enum_t {
    return $this->field_presence;
  }

  public function setFieldPresence(\google\protobuf\FeatureSet_FieldPresence_enum_t $v): void {
    $this->field_presence = $v;
    $this->was_field_presence_set = true;
  }

  public function hasFieldPresence(): bool {
    return $this->was_field_presence_set;
  }

  public function getEnumType(): \google\protobuf\FeatureSet_EnumType_enum_t {
    return $this->enum_type;
  }

  public function setEnumType(\google\protobuf\FeatureSet_EnumType_enum_t $v): void {
    $this->enum_type = $v;
    $this->was_enum_type_set = true;
  }

  public function hasEnumType(): bool {
    return $this->was_enum_type_set;
  }

  public function getRepeatedFieldEncoding(): \google\protobuf\FeatureSet_RepeatedFieldEncoding_enum_t {
    return $this->repeated_field_encoding;
  }

  public function setRepeatedFieldEncoding(\google\protobuf\FeatureSet_RepeatedFieldEncoding_enum_t $v): void {
    $this->repeated_field_encoding = $v;
    $this->was_repeated_field_encoding_set = true;
  }

  public function hasRepeatedFieldEncoding(): bool {
    return $this->was_repeated_field_encoding_set;
  }

  public function getUtf8Validation(): \google\protobuf\FeatureSet_Utf8Validation_enum_t {
    return $this->utf8_validation;
  }

  public function setUtf8Validation(\google\protobuf\FeatureSet_Utf8Validation_enum_t $v): void {
    $this->utf8_validation = $v;
    $this->was_utf8_validation_set = true;
  }

  public function hasUtf8Validation(): bool {
    return $this->was_utf8_validation_set;
  }

  public function getMessageEncoding(): \google\protobuf\FeatureSet_MessageEncoding_enum_t {
    return $this->message_encoding;
  }

  public function setMessageEncoding(\google\protobuf\FeatureSet_MessageEncoding_enum_t $v): void {
    $this->message_encoding = $v;
    $this->was_message_encoding_set = true;
  }

  public function hasMessageEncoding(): bool {
    return $this->was_message_encoding_set;
  }

  public function getJsonFormat(): \google\protobuf\FeatureSet_JsonFormat_enum_t {
    return $this->json_format;
  }

  public function setJsonFormat(\google\protobuf\FeatureSet_JsonFormat_enum_t $v): void {
    $this->json_format = $v;
    $this->was_json_format_set = true;
  }

  public function hasJsonFormat(): bool {
    return $this->was_json_format_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FeatureSet";
  }

  public static function ParseFrom(string $input): ?FeatureSet {
    $msg = new FeatureSet();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->field_presence = \google\protobuf\FeatureSet_FieldPresence::FromInt($d->readVarint());
          $this->was_field_presence_set = true;
          break;
        case 2:
          $this->enum_type = \google\protobuf\FeatureSet_EnumType::FromInt($d->readVarint());
          $this->was_enum_type_set = true;
          break;
        case 3:
          $this->repeated_field_encoding = \google\protobuf\FeatureSet_RepeatedFieldEncoding::FromInt($d->readVarint());
          $this->was_repeated_field_encoding_set = true;
          break;
        case 4:
          $this->utf8_validation = \google\protobuf\FeatureSet_Utf8Validation::FromInt($d->readVarint());
          $this->was_utf8_validation_set = true;
          break;
        case 5:
          $this->message_encoding = \google\protobuf\FeatureSet_MessageEncoding::FromInt($d->readVarint());
          $this->was_message_encoding_set = true;
          break;
        case 6:
          $this->json_format = \google\protobuf\FeatureSet_JsonFormat::FromInt($d->readVarint());
          $this->was_json_format_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_field_presence_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->field_presence);
    }
    if ($this->was_enum_type_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->enum_type);
    }
    if ($this->was_repeated_field_encoding_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->repeated_field_encoding);
    }
    if ($this->was_utf8_validation_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->utf8_validation);
    }
    if ($this->was_message_encoding_set) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->message_encoding);
    }
    if ($this->was_json_format_set) {
      $e->writeTag(6, 0);
      $e->writeVarint($this->json_format);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasFieldPresence()) {
      $e->writeEnum('field_presence', 'fieldPresence', \google\protobuf\FeatureSet_FieldPresence::ToStringDict(), $this->field_presence, false);
    }
    if ($this->hasEnumType()) {
      $e->writeEnum('enum_type', 'enumType', \google\protobuf\FeatureSet_EnumType::ToStringDict(), $this->enum_type, false);
    }
    if ($this->hasRepeatedFieldEncoding()) {
      $e->writeEnum('repeated_field_encoding', 'repeatedFieldEncoding', \google\protobuf\FeatureSet_RepeatedFieldEncoding::ToStringDict(), $this->repeated_field_encoding, false);
    }
    if ($this->hasUtf8Validation()) {
      $e->writeEnum('utf8_validation', 'utf8Validation', \google\protobuf\FeatureSet_Utf8Validation::ToStringDict(), $this->utf8_validation, false);
    }
    if ($this->hasMessageEncoding()) {
      $e->writeEnum('message_encoding', 'messageEncoding', \google\protobuf\FeatureSet_MessageEncoding::ToStringDict(), $this->message_encoding, false);
    }
    if ($this->hasJsonFormat()) {
      $e->writeEnum('json_format', 'jsonFormat', \google\protobuf\FeatureSet_JsonFormat::ToStringDict(), $this->json_format, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'field_presence': case 'fieldPresence':
          $this->field_presence = \google\protobuf\FeatureSet_FieldPresence::FromMixed($v);
          $this->was_field_presence_set = true;
          break;
        case 'enum_type': case 'enumType':
          $this->enum_type = \google\protobuf\FeatureSet_EnumType::FromMixed($v);
          $this->was_enum_type_set = true;
          break;
        case 'repeated_field_encoding': case 'repeatedFieldEncoding':
          $this->repeated_field_encoding = \google\protobuf\FeatureSet_RepeatedFieldEncoding::FromMixed($v);
          $this->was_repeated_field_encoding_set = true;
          break;
        case 'utf8_validation': case 'utf8Validation':
          $this->utf8_validation = \google\protobuf\FeatureSet_Utf8Validation::FromMixed($v);
          $this->was_utf8_validation_set = true;
          break;
        case 'message_encoding': case 'messageEncoding':
          $this->message_encoding = \google\protobuf\FeatureSet_MessageEncoding::FromMixed($v);
          $this->was_message_encoding_set = true;
          break;
        case 'json_format': case 'jsonFormat':
          $this->json_format = \google\protobuf\FeatureSet_JsonFormat::FromMixed($v);
          $this->was_json_format_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FeatureSet)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasFieldPresence()) {
      $this->setFieldPresence($o->getFieldPresence());
    }
    if ($o->hasEnumType()) {
      $this->setEnumType($o->getEnumType());
    }
    if ($o->hasRepeatedFieldEncoding()) {
      $this->setRepeatedFieldEncoding($o->getRepeatedFieldEncoding());
    }
    if ($o->hasUtf8Validation()) {
      $this->setUtf8Validation($o->getUtf8Validation());
    }
    if ($o->hasMessageEncoding()) {
      $this->setMessageEncoding($o->getMessageEncoding());
    }
    if ($o->hasJsonFormat()) {
      $this->setJsonFormat($o->getJsonFormat());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class FeatureSetDefaults_FeatureSetEditionDefault implements \Protobuf\Message {
  private \google\protobuf\Edition_enum_t $edition;
  private bool $was_edition_set;
  private ?\google\protobuf\FeatureSet $features;
  private bool $was_features_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'edition' => \google\protobuf\Edition_enum_t,
    ?'features' => ?\google\protobuf\FeatureSet,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'edition')) {
      $this->edition = $s['edition'];
      $this->was_edition_set = true;
    } else {
      $this->edition = \google\protobuf\Edition::EDITION_UNKNOWN;
      $this->was_edition_set = false;
    }
    if (Shapes::keyExists($s, 'features')) {
      $this->features = $s['features'];
      $this->was_features_set = true;
    } else {
      $this->features = null;
      $this->was_features_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getEdition(): \google\protobuf\Edition_enum_t {
    return $this->edition;
  }

  public function setEdition(\google\protobuf\Edition_enum_t $v): void {
    $this->edition = $v;
    $this->was_edition_set = true;
  }

  public function hasEdition(): bool {
    return $this->was_edition_set;
  }

  public function getFeatures(): ?\google\protobuf\FeatureSet {
    return $this->features;
  }

  public function setFeatures(?\google\protobuf\FeatureSet $v): void {
    $this->features = $v;
    $this->was_features_set = true;
  }

  public function hasFeatures(): bool {
    return $this->was_features_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault";
  }

  public static function ParseFrom(string $input): ?FeatureSetDefaults_FeatureSetEditionDefault {
    $msg = new FeatureSetDefaults_FeatureSetEditionDefault();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeFrom($d->readDecoder());
          break;
        case 3:
          $this->edition = \google\protobuf\Edition::FromInt($d->readVarint());
          $this->was_edition_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $msg = $this->features;
    if ($msg != null) {
      if ($this->was_features_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 2);
      }
    }
    if ($this->was_edition_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->edition);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasFeatures()) {
      $e->writeMessage('features', 'features', $this->features, false);
    }
    if ($this->hasEdition()) {
      $e->writeEnum('edition', 'edition', \google\protobuf\Edition::ToStringDict(), $this->edition, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'features':
          if ($v is null) break;
          if ($this->features is null) {
            $this->features = new \google\protobuf\FeatureSet();
            $this->was_features_set = true;
          }
          $this->features->MergeJsonFrom($v);
          break;
        case 'edition':
          $this->edition = \google\protobuf\Edition::FromMixed($v);
          $this->was_edition_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FeatureSetDefaults_FeatureSetEditionDefault)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $tmp = $o->features;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FeatureSet();
      $nv->CopyFrom($tmp);
      $this->setFeatures($nv);
    } else if ($o->hasFeatures()) {
      $this->setFeatures(null);
    }
    if ($o->hasEdition()) {
      $this->setEdition($o->getEdition());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class FeatureSetDefaults implements \Protobuf\Message {
  public vec<\google\protobuf\FeatureSetDefaults_FeatureSetEditionDefault> $defaults;
  private \google\protobuf\Edition_enum_t $minimum_edition;
  private bool $was_minimum_edition_set;
  private \google\protobuf\Edition_enum_t $maximum_edition;
  private bool $was_maximum_edition_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'defaults' => vec<\google\protobuf\FeatureSetDefaults_FeatureSetEditionDefault>,
    ?'minimum_edition' => \google\protobuf\Edition_enum_t,
    ?'maximum_edition' => \google\protobuf\Edition_enum_t,
  ) $s = shape()) {
    $this->defaults = $s['defaults'] ?? vec[];
    if (Shapes::keyExists($s, 'minimum_edition')) {
      $this->minimum_edition = $s['minimum_edition'];
      $this->was_minimum_edition_set = true;
    } else {
      $this->minimum_edition = \google\protobuf\Edition::EDITION_UNKNOWN;
      $this->was_minimum_edition_set = false;
    }
    if (Shapes::keyExists($s, 'maximum_edition')) {
      $this->maximum_edition = $s['maximum_edition'];
      $this->was_maximum_edition_set = true;
    } else {
      $this->maximum_edition = \google\protobuf\Edition::EDITION_UNKNOWN;
      $this->was_maximum_edition_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getMinimumEdition(): \google\protobuf\Edition_enum_t {
    return $this->minimum_edition;
  }

  public function setMinimumEdition(\google\protobuf\Edition_enum_t $v): void {
    $this->minimum_edition = $v;
    $this->was_minimum_edition_set = true;
  }

  public function hasMinimumEdition(): bool {
    return $this->was_minimum_edition_set;
  }

  public function getMaximumEdition(): \google\protobuf\Edition_enum_t {
    return $this->maximum_edition;
  }

  public function setMaximumEdition(\google\protobuf\Edition_enum_t $v): void {
    $this->maximum_edition = $v;
    $this->was_maximum_edition_set = true;
  }

  public function hasMaximumEdition(): bool {
    return $this->was_maximum_edition_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FeatureSetDefaults";
  }

  public static function ParseFrom(string $input): ?FeatureSetDefaults {
    $msg = new FeatureSetDefaults();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\FeatureSetDefaults_FeatureSetEditionDefault();
          $obj->MergeFrom($d->readDecoder());
          $this->defaults []= $obj;
          break;
        case 4:
          $this->minimum_edition = \google\protobuf\Edition::FromInt($d->readVarint());
          $this->was_minimum_edition_set = true;
          break;
        case 5:
          $this->maximum_edition = \google\protobuf\Edition::FromInt($d->readVarint());
          $this->was_maximum_edition_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->defaults as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    if ($this->was_minimum_edition_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->minimum_edition);
    }
    if ($this->was_maximum_edition_set) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->maximum_edition);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('defaults', 'defaults', $this->defaults);
    if ($this->hasMinimumEdition()) {
      $e->writeEnum('minimum_edition', 'minimumEdition', \google\protobuf\Edition::ToStringDict(), $this->minimum_edition, false);
    }
    if ($this->hasMaximumEdition()) {
      $e->writeEnum('maximum_edition', 'maximumEdition', \google\protobuf\Edition::ToStringDict(), $this->maximum_edition, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'defaults':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FeatureSetDefaults_FeatureSetEditionDefault();
            $obj->MergeJsonFrom($vv);
            $this->defaults []= $obj;
          }
          break;
        case 'minimum_edition': case 'minimumEdition':
          $this->minimum_edition = \google\protobuf\Edition::FromMixed($v);
          $this->was_minimum_edition_set = true;
          break;
        case 'maximum_edition': case 'maximumEdition':
          $this->maximum_edition = \google\protobuf\Edition::FromMixed($v);
          $this->was_maximum_edition_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FeatureSetDefaults)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->defaults as $v) {
      $nv = new \google\protobuf\FeatureSetDefaults_FeatureSetEditionDefault();
      $nv->CopyFrom($v);
      $this->defaults []= $nv;
    }
    if ($o->hasMinimumEdition()) {
      $this->setMinimumEdition($o->getMinimumEdition());
    }
    if ($o->hasMaximumEdition()) {
      $this->setMaximumEdition($o->getMaximumEdition());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class SourceCodeInfo_Location implements \Protobuf\Message {
  public vec<int> $path;
  public vec<int> $span;
  private string $leading_comments;
  private bool $was_leading_comments_set;
  private string $trailing_comments;
  private bool $was_trailing_comments_set;
  public vec<string> $leading_detached_comments;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'path' => vec<int>,
    ?'span' => vec<int>,
    ?'leading_comments' => string,
    ?'trailing_comments' => string,
    ?'leading_detached_comments' => vec<string>,
  ) $s = shape()) {
    $this->path = $s['path'] ?? vec[];
    $this->span = $s['span'] ?? vec[];
    if (Shapes::keyExists($s, 'leading_comments')) {
      $this->leading_comments = $s['leading_comments'];
      $this->was_leading_comments_set = true;
    } else {
      $this->leading_comments = '';
      $this->was_leading_comments_set = false;
    }
    if (Shapes::keyExists($s, 'trailing_comments')) {
      $this->trailing_comments = $s['trailing_comments'];
      $this->was_trailing_comments_set = true;
    } else {
      $this->trailing_comments = '';
      $this->was_trailing_comments_set = false;
    }
    $this->leading_detached_comments = $s['leading_detached_comments'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getLeadingComments(): string {
    return $this->leading_comments;
  }

  public function setLeadingComments(string $v): void {
    $this->leading_comments = $v;
    $this->was_leading_comments_set = true;
  }

  public function hasLeadingComments(): bool {
    return $this->was_leading_comments_set;
  }

  public function getTrailingComments(): string {
    return $this->trailing_comments;
  }

  public function setTrailingComments(string $v): void {
    $this->trailing_comments = $v;
    $this->was_trailing_comments_set = true;
  }

  public function hasTrailingComments(): bool {
    return $this->was_trailing_comments_set;
  }

  public function MessageName(): string {
    return "google.protobuf.SourceCodeInfo.Location";
  }

  public static function ParseFrom(string $input): ?SourceCodeInfo_Location {
    $msg = new SourceCodeInfo_Location();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->span []= $packed->readVarint32Signed();
            }
          } else {
            $this->span []= $d->readVarint32Signed();
          }
          break;
        case 3:
          $this->leading_comments = $d->readString();
          $this->was_leading_comments_set = true;
          break;
        case 4:
          $this->trailing_comments = $d->readString();
          $this->was_trailing_comments_set = true;
          break;
        case 6:
          $this->leading_detached_comments []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if (\count($this->path) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->path as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 1);
    }
    if (\count($this->span) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->span as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 2);
    }
    if ($this->was_leading_comments_set) {
      $e->writeTag(3, 2);
      $e->writeString($this->leading_comments);
    }
    if ($this->was_trailing_comments_set) {
      $e->writeTag(4, 2);
      $e->writeString($this->trailing_comments);
    }
    foreach ($this->leading_detached_comments as $elem) {
      $e->writeTag(6, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    $e->writePrimitiveList('span', 'span', $this->span);
    if ($this->hasLeadingComments()) {
      $e->writeString('leading_comments', 'leadingComments', $this->leading_comments, false);
    }
    if ($this->hasTrailingComments()) {
      $e->writeString('trailing_comments', 'trailingComments', $this->trailing_comments, false);
    }
    $e->writePrimitiveList('leading_detached_comments', 'leadingDetachedComments', $this->leading_detached_comments);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'span':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->span []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'leading_comments': case 'leadingComments':
          $this->leading_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_leading_comments_set = true;
          break;
        case 'trailing_comments': case 'trailingComments':
          $this->trailing_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_trailing_comments_set = true;
          break;
        case 'leading_detached_comments': case 'leadingDetachedComments':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->leading_detached_comments []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is SourceCodeInfo_Location)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->path = $o->path;
    $this->span = $o->span;
    if ($o->hasLeadingComments()) {
      $this->setLeadingComments($o->getLeadingComments());
    }
    if ($o->hasTrailingComments()) {
      $this->setTrailingComments($o->getTrailingComments());
    }
    $this->leading_detached_comments = $o->leading_detached_comments;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class SourceCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\SourceCodeInfo_Location> $location;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'location' => vec<\google\protobuf\SourceCodeInfo_Location>,
  ) $s = shape()) {
    $this->location = $s['location'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.SourceCodeInfo";
  }

  public static function ParseFrom(string $input): ?SourceCodeInfo {
    $msg = new SourceCodeInfo();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\SourceCodeInfo_Location();
          $obj->MergeFrom($d->readDecoder());
          $this->location []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->location as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('location', 'location', $this->location);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'location':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\SourceCodeInfo_Location();
            $obj->MergeJsonFrom($vv);
            $this->location []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is SourceCodeInfo)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->location as $v) {
      $nv = new \google\protobuf\SourceCodeInfo_Location();
      $nv->CopyFrom($v);
      $this->location []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype GeneratedCodeInfo_Annotation_Semantic_enum_t as int = int;
abstract class GeneratedCodeInfo_Annotation_Semantic {
  const GeneratedCodeInfo_Annotation_Semantic_enum_t NONE = 0;
  const GeneratedCodeInfo_Annotation_Semantic_enum_t SET = 1;
  const GeneratedCodeInfo_Annotation_Semantic_enum_t ALIAS = 2;
  private static dict<int, string> $itos = dict[
    0 => 'NONE',
    1 => 'SET',
    2 => 'ALIAS',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'NONE' => 0,
    'SET' => 1,
    'ALIAS' => 2,
  ];
  public static function FromMixed(mixed $m): GeneratedCodeInfo_Annotation_Semantic_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): GeneratedCodeInfo_Annotation_Semantic_enum_t {
    return $i;
  }
}

class GeneratedCodeInfo_Annotation implements \Protobuf\Message {
  public vec<int> $path;
  private string $source_file;
  private bool $was_source_file_set;
  private int $begin;
  private bool $was_begin_set;
  private int $end;
  private bool $was_end_set;
  private \google\protobuf\GeneratedCodeInfo_Annotation_Semantic_enum_t $semantic;
  private bool $was_semantic_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'path' => vec<int>,
    ?'source_file' => string,
    ?'begin' => int,
    ?'end' => int,
    ?'semantic' => \google\protobuf\GeneratedCodeInfo_Annotation_Semantic_enum_t,
  ) $s = shape()) {
    $this->path = $s['path'] ?? vec[];
    if (Shapes::keyExists($s, 'source_file')) {
      $this->source_file = $s['source_file'];
      $this->was_source_file_set = true;
    } else {
      $this->source_file = '';
      $this->was_source_file_set = false;
    }
    if (Shapes::keyExists($s, 'begin')) {
      $this->begin = $s['begin'];
      $this->was_begin_set = true;
    } else {
      $this->begin = 0;
      $this->was_begin_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    if (Shapes::keyExists($s, 'semantic')) {
      $this->semantic = $s['semantic'];
      $this->was_semantic_set = true;
    } else {
      $this->semantic = \google\protobuf\GeneratedCodeInfo_Annotation_Semantic::NONE;
      $this->was_semantic_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getSourceFile(): string {
    return $this->source_file;
  }

  public function setSourceFile(string $v): void {
    $this->source_file = $v;
    $this->was_source_file_set = true;
  }

  public function hasSourceFile(): bool {
    return $this->was_source_file_set;
  }

  public function getBegin(): int {
    return $this->begin;
  }

  public function setBegin(int $v): void {
    $this->begin = $v;
    $this->was_begin_set = true;
  }

  public function hasBegin(): bool {
    return $this->was_begin_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function getSemantic(): \google\protobuf\GeneratedCodeInfo_Annotation_Semantic_enum_t {
    return $this->semantic;
  }

  public function setSemantic(\google\protobuf\GeneratedCodeInfo_Annotation_Semantic_enum_t $v): void {
    $this->semantic = $v;
    $this->was_semantic_set = true;
  }

  public function hasSemantic(): bool {
    return $this->was_semantic_set;
  }

  public function MessageName(): string {
    return "google.protobuf.GeneratedCodeInfo.Annotation";
  }

  public static function ParseFrom(string $input): ?GeneratedCodeInfo_Annotation {
    $msg = new GeneratedCodeInfo_Annotation();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          $this->source_file = $d->readString();
          $this->was_source_file_set = true;
          break;
        case 3:
          $this->begin = $d->readVarint32Signed();
          $this->was_begin_set = true;
          break;
        case 4:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        case 5:
          $this->semantic = \google\protobuf\GeneratedCodeInfo_Annotation_Semantic::FromInt($d->readVarint());
          $this->was_semantic_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if (\count($this->path) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->path as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 1);
    }
    if ($this->was_source_file_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->source_file);
    }
    if ($this->was_begin_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->begin);
    }
    if ($this->was_end_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->end);
    }
    if ($this->was_semantic_set) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->semantic);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    if ($this->hasSourceFile()) {
      $e->writeString('source_file', 'sourceFile', $this->source_file, false);
    }
    if ($this->hasBegin()) {
      $e->writeInt32('begin', 'begin', $this->begin, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
    if ($this->hasSemantic()) {
      $e->writeEnum('semantic', 'semantic', \google\protobuf\GeneratedCodeInfo_Annotation_Semantic::ToStringDict(), $this->semantic, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'source_file': case 'sourceFile':
          $this->source_file = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_source_file_set = true;
          break;
        case 'begin':
          $this->begin = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_begin_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        case 'semantic':
          $this->semantic = \google\protobuf\GeneratedCodeInfo_Annotation_Semantic::FromMixed($v);
          $this->was_semantic_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is GeneratedCodeInfo_Annotation)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->path = $o->path;
    if ($o->hasSourceFile()) {
      $this->setSourceFile($o->getSourceFile());
    }
    if ($o->hasBegin()) {
      $this->setBegin($o->getBegin());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    if ($o->hasSemantic()) {
      $this->setSemantic($o->getSemantic());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class GeneratedCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\GeneratedCodeInfo_Annotation> $annotation;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'annotation' => vec<\google\protobuf\GeneratedCodeInfo_Annotation>,
  ) $s = shape()) {
    $this->annotation = $s['annotation'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.GeneratedCodeInfo";
  }

  public static function ParseFrom(string $input): ?GeneratedCodeInfo {
    $msg = new GeneratedCodeInfo();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
          $obj->MergeFrom($d->readDecoder());
          $this->annotation []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->annotation as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('annotation', 'annotation', $this->annotation);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'annotation':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
            $obj->MergeJsonFrom($vv);
            $this->annotation []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is GeneratedCodeInfo)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->annotation as $v) {
      $nv = new \google\protobuf\GeneratedCodeInfo_Annotation();
      $nv->CopyFrom($v);
      $this->annotation []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_descriptor__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/descriptor.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 15422 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\xcc\x5a\xcd\x8f\x1b\x47\x76\x57\x37\xbf\x9a\x8f\x1c\xb2\xa6\x66\x24\xd1\x23\x7b\x35\xa2\x6c\x69\x24\xdb\xb4\x77\x24\xeb\xcb\x8b\x4d\x38\x64\xcf\x88\x63\xe\xc9\x34\x39\xb2\x64\x24\x68\xf4\x34\x8b\x9c\x96\xc9\x6e\x6e\x77\x53\xd2\x18\x41\xe0\x20\x87\x6c\xb0\x59\x20\x8\x72\x70\x2\x24\x1\xf6\xb2\x40\x90\x5c\x3\xe4\x98\x53\x80\x1c\x82\xe4\x90\xbf\x20\x80\xe5\xdd\x5c\x73\xc8\x21\x8\x82\xaa\xea\x6e\x76\x37\x49\x69\x24\x20\x86\x4e\x33\xf5\xbe\xea\xd5\xab\x5f\xbf\x7a\xaf\x8a\xb0\x39\xb4\xac\xe1\x88\x7c\x34\xb1\x2d\xd7\x3a\x9a\xe\x3e\xea\x13\x47\xb7\x8d\x89\x6b\xd9\x15\x46\xc3\x45\x2e\x51\xf1\x25\xca\x7\xb0\xba\x6b\x8c\x48\x3d\x10\xec\x12\x17\xdf\x81\xe4\xc0\x18\x91\x92\xb0\x99\xd8\xca\x6d\xbf\x5b\x89\x29\x55\xa2\x1a\x1d\x4a\x56\x98\x46\xf9\x9b\x14\xac\x2d\xe0\x62\xc\x49\x53\x1b\x53\x8b\xc2\x56\x56\x61\xff\xe3\x12\x64\x26\x9a\xfe\xa5\x36\x24\x25\x91\x91\xfd\x21\xfe\x1\x40\x9f\x4c\x88\xd9\x27\xa6\x7e\x52\x4a\x6c\x26\xb6\xb2\x4a\x88\x82\xdf\x87\xd5\xc9\xf4\x68\x64\xe8\x6a\x48\xc\x36\x13\x5b\x29\x5\x71\x46\x7d\x26\x7c\x15\x8a\x4f\x89\xf6\x65\x58\x34\xc7\x44\xb\x94\x1c\x12\xac\x41\x7e\x4c\x1c\x47\x1b\x12\xd5\x3d\x99\x90\x52\x92\xad\x7e\x73\x6e\xf5\xf1\x95\xe7\x3c\xad\xde\xc9\x84\xe0\x2a\x64\x89\x39\x1d\x73\xb\xa9\x25\xf1\x93\xcd\xe9\x38\x6e\x45\xa2\x6a\x9e\x89\x8c\x43\xec\x27\x86\x4e\x4a\x69\x66\xe0\xea\x9c\x81\x2e\xe7\xc7\x6d\xf8\x7a\xb8\x6\x59\xf2\xcc\x25\xa6\x63\x58\x66\x29\xc3\x8c\xbc\xb7\x60\x17\xc9\xa8\x1f\x37\x31\xd3\xc3\xb7\x20\x63\x4d\x5c\xc3\x32\x9d\x92\xb4\x29\x6c\xe5\xb6\xdf\x5e\x8\x84\x36\x97\x51\x7c\x61\xdc\x0\xe4\x58\x53\x5b\x27\xaa\x6e\xf5\x89\x6a\x98\x3\xab\x94\x65\x6\x2e\xce\x2f\x84\x9\xd6\xac\x3e\x69\x98\x3\x4b\x29\x38\x91\x31\x3e\x7\x69\xe7\xc4\x74\xb5\x67\xa5\x3c\x43\x88\x37\xc2\xdb\x90\x21\x7d\x83\x4e\x57\x2a\x6c\xa\x5b\x85\xed\xd2\x7c\x8c\x39\x5f\xf1\x5\xcb\xff\x90\x86\xe2\x69\x60\xf9\x29\xa4\x6\x34\x32\x25\xf1\x55\xe2\xc6\x75\xa2\x81\x4f\xbf\x66\xe0\xab\x90\x33\x89\xe3\x92\x3e\x47\x51\xe2\x94\x38\x4\xae\x34\xf\xc3\xe4\x6b\xc1\xf0\x21\x14\x3\x97\x54\x5b\x33\x87\x3e\x9e\x3f\x7a\x99\x27\x15\xd9\xd7\x53\xa8\x9a\x52\x20\x91\x31\xae\x3\x58\x26\xb1\x6\x6a\x9f\xe8\xa3\x92\xb4\x24\x4a\x6d\x2a\x32\x17\x25\x8b\x53\xf5\x11\xbe\x3b\x83\x67\x66\x9\xba\xe\xf8\x87\x39\x87\xd0\x43\x28\xd8\x84\x7e\x2b\xa4\xef\xad\x2c\xcb\x9c\xa8\xbc\x74\x65\x8a\xa7\xc6\x17\xb6\x62\x87\x87\xf8\x32\x4\x4\x95\xc1\xa\x58\xe6\xca\xfb\xc4\x96\x36\x26\x1b\x5f\x41\x21\x1a\x1e\xbc\xe\x29\xc7\xd5\x6c\x97\xa1\x30\xa5\xf0\x1\x46\x90\x20\x66\x9f\x65\xc6\x94\x42\xff\xc5\xbf\x39\x5b\x70\x82\x2d\xf8\xca\xfc\x8e\x46\x2c\xc7\xd7\xbd\x71\x1b\x56\x22\xb\x38\xed\xd4\xe5\x7f\x4a\xc2\xd9\x85\xb6\xf1\x43\x58\x9f\x9a\x86\xe9\x12\x7b\x62\x13\xa\x59\x3e\x57\xe9\x79\x66\x9\xe8\xe\xc3\xd2\xdc\x8a\xb2\x36\x9d\x27\xe2\x47\x90\xa3\xf8\xd0\x6c\x8d\x19\xe4\x5f\xe3\xf6\xe9\x96\x5c\xa9\xcf\x34\x77\x12\x3f\x15\x44\x25\x6c\xb\xdf\x6\x69\x40\x34\x77\x6a\x13\xa7\xb4\xcd\x42\x79\x61\xfe\x23\xe5\x2\x5d\xe2\x2a\x81\x30\x3e\x86\xfc\x13\x62\x1b\x3\x43\xe7\x4e\x25\x58\xf2\xb9\x73\x4a\xa7\x1e\x84\x54\xbb\xae\xe6\x92\x7b\x70\xd8\x7a\x20\x2b\x8d\xdd\x86\x5c\x57\x22\x96\x37\xfe\x4c\x80\x5c\x68\x11\x34\x13\x9a\xd3\xf1\x11\xb1\xbd\xad\xf2\x46\xf8\x2\x64\x7\xd3\xd1\x88\xe3\x8d\x1f\xa3\x12\x25\x50\xac\xd1\xf4\xe6\x65\x10\x96\xde\xe8\xff\x78\x3\x24\x1f\x8f\xa5\xd4\xa6\xb0\x25\x29\xc1\x98\xf3\x26\x44\x73\x49\xbf\x94\xf6\x79\x7c\xbc\x9f\x94\x92\x28\x55\xbe\x9\xab\x73\xab\xc0\x45\xc8\xd5\xe5\x5a\xb3\xaa\x54\x7b\x8d\x76\xb\x9d\xc1\x5\x8\x2d\xc\x9\xd7\xb3\xd2\x77\x19\xf4\xf5\xd7\x5f\x7f\x2d\x96\xff\x31\xd\xeb\x8b\xf2\xdf\xc2\x54\x3c\x5b\x74\x22\xb2\xe8\x2a\xa4\x46\xda\x11\x19\x95\x92\x2c\xfe\xef\x9f\x2a\xc3\x56\x9a\x54\x45\xe1\x9a\xf8\xc7\x5e\x68\x52\xcc\xc2\xf5\xd3\x59\xa0\x79\xd1\xb\xe3\x5\xc8\xd2\xbf\x3c\xee\x69\x1e\x77\x4a\x60\x71\xdf\x0\x89\xa5\xbc\x3e\x9\xf6\xc4\x1f\xd3\x24\xd1\x27\x3\x6d\x3a\x72\xd5\x27\xda\x68\x4a\x58\xf2\xca\x2a\x79\x8f\xf8\x80\xd2\xf0\x45\xc8\xf1\xc\x69\x98\x7d\xf2\x8c\x9d\x9e\x29\x85\x27\xcd\x6\xa5\xd0\xe9\x1f\x3b\x96\xe9\xa7\x19\x36\x5\x25\xb0\xe9\x6f\xc7\xf\xee\x77\x16\x2f\x6f\x2e\x2f\x5e\x85\x22\x93\xb8\xe1\x7d\xc5\xda\xa8\xb4\xca\x60\x50\xe0\xe4\xb6\x47\x2d\xff\xbd\x8\x49\x76\x48\x14\x21\xd7\x7b\xd4\x91\xd5\x7a\xfb\x70\xa7\x29\x23\x81\x6e\x3d\x23\xec\x36\xdb\xd5\x1e\x12\x83\x71\xa3\xd5\xbb\x75\x13\x25\x2\x85\x43\x4e\x48\x86\x5\x6e\x6c\xa3\x14\x46\x90\xe7\x6\x1a\xf\xe5\xfa\xad\x9b\x28\x1d\xa5\xdc\xd8\x46\x19\xbc\x2\x59\x46\xd9\x69\xb7\x9b\x48\xa\x6c\x76\x7b\x4a\xa3\xb5\x87\xb2\x81\xcd\x3d\xa5\x7d\xd8\x41\x10\x58\x38\x90\xbb\xdd\xea\x9e\x8c\x72\x81\xc4\xce\xa3\x9e\xdc\x45\xf9\x88\x5b\x37\xb6\xd1\x4a\x30\x85\xdc\x3a\x3c\x40\x5\xbc\xa\x2b\x7c\xa\xdf\x89\x62\x8c\x74\xeb\x26\x42\x33\x47\xb8\x95\xd5\x8\xe1\xd6\x4d\x84\xcb\x35\x48\x31\x18\x62\xc\x85\x66\x75\x47\x6e\xaa\xed\xe\xfd\x68\xaa\x4d\x24\xcc\x68\x8a\xdc\x91\xab\x3d\xb9\x8e\x12\x61\xda\x6f\x1d\x36\x14\xb9\x8e\xc4\xb2\xe\xeb\x8b\xe\xc7\x85\x9f\x50\x8\xb\xe2\x12\x2c\x30\x5b\x71\x2c\x94\xff\x43\x84\xb5\x5\x5\xc2\xc2\x49\x7e\x3\x52\x1c\xcb\x3c\x49\x5f\x5b\x58\x69\x30\x64\xcf\x95\x4d\x4c\x2f\x5c\x6a\x26\x96\x94\x9a\xd4\xc4\x1c\x60\x7f\x67\xee\x20\xe7\xb5\xce\xad\xd3\xd4\x3a\x8c\xf6\x6a\x7\x7a\x6a\xc1\x81\xfe\x29\xac\xce\x19\x3a\xf5\xc1\xfa\x7\x2\x94\x96\x5\xe7\x25\x29\x51\x8c\xa4\xc4\x4f\xe3\x11\xbc\xb4\x7c\x13\xe6\xf6\xfa\x97\x2\x9c\x5b\xdc\x52\x2c\xf4\xe1\xc7\x90\x1e\x13\xf7\xd8\xf2\x4b\xe4\x2b\xb\xa\x2f\xca\x8e\x6f\xb6\xa7\x15\xae\xdc\x12\xcb\xfa\x2\xee\xcd\x9c\xa7\x7f\x24\xc2\xd9\x85\xc6\x17\x3a\xfa\xe\x80\x61\x4e\xa6\x2e\x2f\x83\x79\x26\xce\x32\xa\x4b\x5e\x34\xcb\x4e\xdd\x80\xcf\x4f\x49\xe0\x24\x26\x70\x67\xe6\x68\x92\x39\xfa\x83\x25\x2b\x9d\x3\xe6\xc7\x80\xf4\x91\x41\x4c\x57\x75\x5c\x9b\x68\x63\xc3\x1c\xf2\xd3\xf6\x5e\x6a\xa0\x8d\x1c\xa2\x14\x39\xbb\xeb\x73\xa9\x6\x3\x90\x1d\xd2\x48\x47\x34\x38\x3b\xd0\x28\xff\x73\x16\x72\xa1\x6\xc\x5f\x82\xfc\x63\xed\x89\xa6\xfa\x4d\x35\x8f\x44\x8e\xd2\x3a\x5e\x63\xfd\x31\xac\x33\x11\x6b\xea\x12\x5b\xd5\x47\x9a\xe3\xb0\xa0\x49\x4c\x14\x53\x5e\x9b\xb2\x6a\x3e\x7\x7f\x2\x6b\x4c\x63\x3c\x1d\xb9\xc6\x64\x44\x54\xda\xe6\x3b\xec\xc8\x9\x3c\x5b\xa5\x12\x7\x9e\x0\xf5\xc8\xc1\x75\x78\x87\xa9\xd\x89\x49\x6c\xcd\x25\x2a\xf9\xc9\x54\x1b\x39\xaa\x66\xf6\xd5\x63\xcd\x39\x2e\xad\x53\x3\x3b\x62\x49\x50\xde\xa2\x82\x7b\x9e\x9c\xcc\xc4\xaa\x66\xff\xbe\xe6\x1c\xe3\x7b\x70\x8e\x59\x71\x5c\xdb\x30\x87\xaa\x7e\x4c\xf4\x2f\xd5\xa9\x3b\xb8\x53\xba\x10\x9e\x9f\x79\xd8\x65\x32\x35\x2a\x72\xe8\xe\xee\xe0\x2e\xe4\xe9\x66\x8c\x8d\xaf\x88\x3a\xb0\x6c\x76\x86\x16\x16\xa4\xa6\x50\x4\x2b\x6d\x4f\xe1\xc0\xea\x93\x7b\xa9\x6e\x47\x96\xeb\x4a\xce\xb7\xb2\x6b\xd9\x14\x50\x43\x2b\x8\x70\x8e\x3\x6a\x68\xf9\xe1\xfd\x4\xd6\x74\x9d\xaf\xd9\xd0\x55\xaf\x19\x77\x4a\x28\x12\x2c\x5d\xdf\xe3\x2\x1e\xc6\x1d\x7c\x17\xce\xce\x82\x15\x56\x5c\x9d\x5b\x65\x5c\xf5\x13\x58\x9b\x9c\xcc\x2b\xe2\xc8\x8c\x93\x93\xb8\xda\x6d\x58\x9f\x1c\x4f\xe6\xf5\xae\x87\xf5\xf0\xe4\x78\x12\x57\x7c\x8f\xdd\xcc\xd8\x44\x67\x35\xe2\xf9\xb0\x78\x88\x81\x2b\x80\x74\x5d\x25\xa6\x76\x34\x22\xaa\x66\x13\x53\x73\x4a\x17\x99\x70\xd2\xb5\xa7\x44\x29\xe8\xba\xcc\x98\x55\xc6\xc3\xd7\x61\xd5\x3a\x7a\xac\x73\x44\xaa\x13\x9b\xc\x8c\x67\xa5\x77\x59\x78\x8b\x94\xc1\xf0\xd8\x61\x64\x7c\xd\x90\xee\x1c\x6b\xf6\x84\xa5\x64\x67\xa2\xe9\xa4\xf4\x1e\x17\xe5\xf4\x96\x4f\xa6\x5f\x84\xf3\xd4\x18\xb8\xbe\xc5\xab\xfc\x8b\x60\x34\xcf\xda\x16\x20\x1a\x89\xc8\xc4\x5b\x4c\xac\x30\x39\x9e\x84\xe7\xbd\xc\x2b\x54\x72\x36\xe9\x35\x5e\xb8\x4d\x8e\x43\x33\xde\x84\x73\x54\x68\x4c\x5c\xad\xaf\xb9\x5a\x48\xfa\x3\x26\x4d\xc3\x7e\xe0\x31\x23\x7e\xda\xd3\xa3\x93\x0\x58\x1f\x72\x3f\x29\xcd\x87\xd6\x6b\xb7\x2c\xff\x6f\xd\x5a\xf9\x1e\xe4\xc3\x1f\xc\xce\x2\xff\x64\x90\x40\xab\xa7\x5a\xbb\x4e\xeb\x9e\x2f\x64\x24\xd2\xfa\xab\xd9\xe8\xc9\xaa\x72\xd8\xea\x35\xe\x64\x94\x8\x75\x4\xfb\x49\xe9\xa\xba\x5a\xfe\xaf\x4\x14\xa2\xed\x3a\xfe\x11\x9c\xf7\xef\xe3\x1c\xe2\xaa\x4f\xd\x9b\x7d\xc9\x63\x8d\x9f\xaa\x1\xf0\xd6\x3d\xa9\x2e\x71\x3f\x37\x6c\xfa\x9d\x8e\x35\x17\x37\xe1\xa2\x69\xa9\x8e\xab\x99\x7d\xcd\xee\xab\xb3\x9b\x50\x55\xd3\x75\xe2\x38\x16\x3f\x41\x3\x2b\x6f\x9b\x56\xd7\x13\x9e\x1d\x2d\x55\x4f\x34\x86\xfb\xc4\x32\xdc\x5f\x80\xec\x58\x9b\xa8\xc4\x74\xed\x13\x56\xd8\x4b\x8a\x34\xd6\x26\x32\x1d\xe3\x7\x70\x65\x26\xaa\x8e\xc8\x50\xd3\x4f\x54\x56\xc5\xb3\xbb\x23\x55\xb7\xcc\xc1\xc8\xd0\x5d\x87\x25\x16\x9e\x1c\xcb\x33\x8d\x26\x53\xd8\x77\x2c\x93\x15\xef\x35\x5f\x3a\x2\x8d\xfc\x1b\x1\x8d\xe8\xf6\x26\x51\x6a\x3f\x29\xa5\x50\x7a\x3f\x29\xa5\x51\x66\x3f\x29\x49\x28\xbb\x9f\x94\xb2\x8\xca\x7f\x7\x90\xf\xf7\x22\xb4\xb5\xd3\xd9\x69\x2c\xb0\x7c\x7d\xf9\x85\x9d\x4b\xa5\x46\x8f\xe9\x7b\x69\x5e\xf8\x2b\x5c\x93\x96\x48\xf4\x43\x22\xbc\xd0\x92\x14\x6f\x84\xf7\x20\xfd\xd8\x61\xb6\xd3\xcc\xf6\xbb\x2f\xb6\xbd\xdf\x65\xc6\xb3\xfb\x5d\xb5\xd5\x56\xe\xaa\x4d\xc5\x53\xc7\x6f\x41\x72\xa4\x7d\x75\x12\x3d\xd0\x19\x9\x57\xa0\x38\x35\x79\x23\x4f\xf7\x98\x4a\x15\xc3\x52\x85\x19\xb7\x49\xe5\x4f\x89\xab\xb7\x20\xf9\x94\x68\x5f\x46\x8f\x5d\x46\xc2\x5b\x90\xef\x93\xa3\xe9\x50\xb5\x49\x5f\xd3\xdd\xe8\x61\x93\x63\x2c\x85\x71\xf0\x67\x90\xa5\x7b\x64\xb2\x3d\x5e\x65\x21\xf8\xf0\xc5\x21\xf0\xb6\xd8\x57\x52\x66\xfa\xf8\x3e\x64\x5c\xcd\x1e\x12\xd7\x29\xad\x6d\x26\xb6\xa\xb\xee\xce\x16\x98\xea\x31\x15\xd6\x46\xfb\xea\xf8\x73\x40\xde\x15\xad\xea\xf5\xc0\x4e\x69\x9d\x1\xf0\x83\x17\x9b\xf4\x6e\x78\xeb\x5c\x49\x29\x92\xc8\x38\xfa\x5d\x9c\x7d\x23\xbe\x8b\x8d\x2f\xa0\x10\xf5\x3a\x7c\x93\x9d\x38\xe5\x4d\x36\x6d\x2e\xfc\x76\x8b\x9e\x13\x7c\x50\xfe\x8\x52\xec\x73\xc0\x0\xde\x7\x81\xce\x60\x9\x92\xb5\xb6\x42\x53\x32\x82\x3c\xa7\xaa\x9d\x86\x5c\x93\x91\x58\xfe\x4\xd2\x1c\xe3\x34\x5d\x7\x28\x47\x67\xbc\xa1\x67\x43\xf0\xb9\x87\x7\x3b\xb2\x82\xc4\xf2\x21\x14\x63\xb8\xc0\x67\x61\x55\x91\x7b\x72\x8b\x76\xb2\xea\x61\xeb\xb3\x56\xfb\xf3\x16\x3a\x13\x25\xfb\xb9\x5f\xc0\xeb\x80\x66\xe4\x6e\xfb\x50\x61\xde\xfc\xb1\x8\x28\xe\x12\x7c\x1e\xd6\x7a\x55\x65\x4f\xee\xa9\xbc\x3b\xf\x4c\xaf\x3\xa\x33\x76\x1b\xec\xf2\xe1\x22\x5c\x8\x53\xe5\x87\x3d\xb9\xd5\x65\x93\x57\x5b\x7b\xf4\x20\x8a\xd9\xf3\xef\x3\x12\xd4\xd5\xa8\x3d\xb9\x59\x47\xc9\x38\xb9\xdd\x92\xdb\xbb\x28\x15\x9f\x9d\xdd\x11\xa4\xf1\x6\x9c\x8b\x53\x55\xb9\xd5\x53\x1e\xa1\x4c\x7c\xe2\xae\xac\x3c\x68\xd4\x64\x24\xe1\x73\x80\xa3\x1e\xf5\xee\xb7\xeb\x28\xbb\x28\x83\x62\xb4\x56\xfe\x5b\x1\xf2\xe1\x7e\x3d\x2\x72\xe1\x4d\x4b\xfe\xe5\x7f\x13\x21\x17\x6a\xdc\x69\xc7\xa5\x8d\x46\xd6\x53\x55\x1b\x19\x9a\xe3\xe5\x67\x60\xa4\x2a\xa5\x9c\x36\x1f\x9e\xfe\x28\x4d\xbf\xf6\x51\x9a\x79\x3\x8f\xd2\x14\x4a\x97\x7f\x5f\x4\x14\x6f\xe5\x63\x71\x13\x96\xc5\x2d\xbc\x3e\xf1\x55\xd6\x17\x3f\x65\x12\x4b\x4f\x99\xef\x5\x57\xff\x2e\x40\x21\x7a\x45\x10\x59\x5a\xf9\x55\x96\x16\xd\xdd\xa5\x65\xa1\xfb\x5e\xd6\xf5\xe7\x9\x58\x89\xdc\x28\x9c\xd6\xbb\x9f\xc0\xaa\xd1\x27\xe3\x89\xe5\x12\x53\x3f\x51\x47\xe4\x9\x19\xb1\x30\x14\x16\x3c\xd7\x45\x66\xa8\x34\x66\x7a\x4d\xaa\x76\x6f\xad\x51\x97\xf\x3a\xed\x9e\xdc\xaa\x3d\xf2\x53\xae\x82\x8c\x98\x58\x24\xe0\x97\xdf\x8c\x8e\xa4\x3\x28\xbe\x1a\x9a\x79\x17\xac\x7\x9d\xc1\x6b\x50\x6c\xb5\xd5\x6e\xa3\x2e\xab\xf2\xee\xae\x5c\xeb\x75\xf9\xf5\x75\x20\xdd\x43\x62\x78\x6f\xfe\x22\x1\x6b\xb\x3c\xc1\x55\xef\xe2\x89\xdf\x85\x7d\x78\x1a\xef\x2b\xb4\xf5\xeb\x68\xb6\xeb\xdd\x53\x5d\x3\x1a\x5e\xd3\xa5\x75\xa1\xed\x3d\xb\xf0\xdb\xa8\xe2\x8c\xce\x5f\x6\x3e\x0\x3c\xb1\x1c\xc3\x35\x9e\x10\xd5\x30\xfd\x37\x84\xe4\xa6\xb0\x95\x54\x90\xcf\x69\x98\x6e\x20\x6d\x92\xa1\x16\x93\xa6\x75\x6b\x42\x41\x3e\x27\x90\xbe\x4\xf9\xbe\x35\xa5\x2d\x3b\x97\xa3\xb9\x53\x50\x72\x9c\x16\x88\x78\x97\x31\xb3\xc7\x8b\xbc\x92\xe3\x34\x2e\x72\x15\x8a\xda\x70\x68\x53\xe3\xbe\x21\x7e\xbd\x54\x8\xc8\x4c\x70\x63\x1f\x24\x3f\xe\xb4\x71\xa2\x91\x50\x27\xfc\xce\x54\xdc\xca\x2a\x92\xe9\x33\x2f\x41\xde\x70\xd4\xd9\xbb\xba\xb8\x29\x6e\x49\x4a\xce\x70\x82\x67\xb6\xf2\xff\x64\x1\x66\x60\xc3\x3f\x13\xa0\xc0\x4f\x82\x89\x4d\x1c\x62\xea\x7e\x3f\x71\xed\x5\x10\xe5\xd5\x65\xc7\x53\xd8\xb9\xfb\x53\x41\xf8\x46\x48\x7e\x23\x8\xbf\x10\x56\xb0\x24\x3f\xec\x34\x1b\xb5\x46\xaf\xf4\x6d\x86\x8d\x1b\x7\xde\xf8\x79\x26\xca\xff\x2e\xa3\xac\xc\xc2\x96\xf0\x20\xfc\x18\x2f\x2e\xeb\x3d\x66\x7e\xc8\xde\x13\xfc\xce\x65\xe6\x42\x9a\xb9\x90\xc3\xe9\x5a\xb3\xdd\x95\xeb\xcc\x81\x2c\x4e\xb6\x3b\x72\xab\xf4\x3c\x13\x7a\xb1\xff\x53\x1\xce\xfb\xef\x75\xde\x41\x48\x4c\xdd\xea\x1b\xe6\xd0\x2b\x2e\x7f\xf8\xa2\x69\x15\x4f\x95\x85\x41\xf6\x14\x77\xae\xce\x85\xa1\xda\xaa\x7b\x5e\xe4\x70\xba\x53\xad\x7d\x26\xd7\xa9\x1f\x67\xed\x45\xfa\xf8\x19\x14\xa7\xee\xe0\xe\x45\x82\xd1\xe7\xaf\xa6\xc9\x65\x6f\x6e\x33\x5f\xe\xdd\xc1\x9d\x7\x81\x86\x17\x8\xee\x44\x16\x27\x5b\xed\x96\xec\x3b\xc0\x9e\x19\x1f\x51\x7\xa\xd3\x88\x12\x7e\x6\xc8\xbf\x3f\x8\xc2\x90\x5a\xf6\x60\x38\x9b\xda\xbb\x85\x8\x2\xb0\x19\x9a\x7b\x1d\x17\x9b\x72\x6b\xaf\x77\x5f\xed\x28\x32\x7b\xf7\x29\x7d\x9b\x51\x8a\xe3\xa8\xa\xfe\x5d\xc8\xf1\x62\x84\xdf\x56\xf0\x76\xf3\xca\x8b\x26\x65\xb5\x8\x93\xde\xb9\xc1\xe6\x4b\xf8\xfb\x7e\x1e\xe3\xa6\xbc\x57\xad\x3d\x52\x77\xe4\x6e\x8f\xa6\xaa\xb6\xc2\x41\x8\x38\x55\x6d\x36\xdb\x9f\xd3\xb5\xc3\xe3\xc0\x40\xf9\xb7\x61\x25\x82\x64\x5a\x98\xb2\x82\x96\x3a\xdd\x95\x5b\xb5\x70\x21\x9d\x87\x0\xb9\x48\xa0\x23\x1f\xd7\x48\xa4\x19\xd2\x9b\x3a\x78\x7c\x4a\x94\x6f\x83\xe4\xe3\x93\x96\xc7\xac\xca\x8d\x15\xe7\x12\x30\x70\x22\x81\xb6\x22\x1c\xb4\x48\x2c\x3f\x80\xb3\xb\x11\x86\x2f\xc3\x45\xff\xc1\x8b\x17\xde\xaa\xdc\xaa\xb5\xeb\xb4\x55\x99\xd9\x4\xf0\xa0\xc6\xbd\xf4\x61\x88\xc4\x72\xd\xa\x51\xb4\xe0\xb\x70\xfe\xb0\xb7\x7b\x47\x7d\x50\x6d\x36\xea\xd5\x58\x53\x22\x1\x83\xf\x77\x8e\x83\x7\x89\xe5\x2e\x14\x63\xfb\x8e\xdf\x86\x92\xd7\x1f\x2c\xf2\x87\xc5\x26\x82\x4\xde\x29\xd5\xe5\x66\xe3\xa0\xd1\x63\x9e\xdd\x7\x98\xed\x2b\x3d\x88\xf6\xbb\xed\x96\xba\x4b\xdb\xac\x5e\xc8\x54\x16\xf8\x3e\x22\x81\x76\x3\xf3\x9b\x8d\xc4\xeb\x69\x7a\xc\xfd\x2a\x73\x3d\x2d\xfd\x2a\x83\x7e\x4d\xff\xfe\xac\x85\xfe\xa4\xb5\x9f\x96\x9e\x67\xd0\x77\x99\xf2\xff\x8a\x80\x67\x68\xa\x3a\xe0\x87\x20\x5\x2d\x35\xff\x2d\xdf\x8f\x5e\x0\x42\x5f\x2d\x44\x8a\xb5\xd8\x81\x35\x5c\x85\xe2\xd8\x30\x8d\xf1\x74\xac\xfa\xed\x6b\xf2\x25\xed\x6b\xc1\x53\xf0\xc6\xcc\x84\xf6\x2c\x62\x22\xf5\x52\x13\x5c\xc1\x1b\x6f\xfc\xa1\x0\xa5\x65\xce\xbe\x56\x67\xfd\xba\xf5\x71\xf9\x97\x22\x14\xa2\xbf\x65\xc3\x75\x90\x46\x96\xf7\x3b\x11\x1e\xfc\xad\x97\xfc\xfc\xad\xd2\xf4\xe4\x95\x40\x73\xe3\x5f\x4\x90\x7c\x32\x3e\x7\xc9\x89\xe6\x1e\x33\x73\xa9\x1d\x11\x9\xa\x1b\x53\xba\x33\xd1\xf8\x6f\x64\x3c\x3a\x1d\xd3\xba\x62\x44\xb4\x3e\x7b\x3b\xb1\xc6\x63\x62\xba\x8e\x5f\x57\x78\xf4\x9a\x47\xc6\xef\xc3\xaa\x6b\x6b\xc6\x28\x22\x9b\x64\xb2\xc8\x67\x4\xc2\xf7\xe0\x2d\xdf\x6e\x9f\xb8\x9a\x7e\x4c\xfa\x33\xa5\x34\x7b\x23\x3d\xef\x9\xd4\x3d\xbe\xaf\x5b\xfe\x57\x11\x56\xfd\xd7\x9e\x7e\x10\xac\x3\x0\xcd\x34\x2d\x37\x1c\xae\xf9\x52\x6a\x4e\xaf\x52\xd\x94\x94\x90\x81\x8d\xff\x14\x0\x66\xac\xa5\x71\xbb\x8\x39\xef\x97\x8a\xec\xe7\xae\xfc\x3a\x5\x38\x69\xd7\x18\xb1\x67\xdc\x23\x32\x34\x4c\xef\xf7\x27\x7c\xe0\x3f\xe3\x26\x67\x3f\xcd\x52\x40\x72\xc8\x58\x33\x5d\x43\xf7\x40\x7c\xeb\x95\x9c\xaf\x74\x3d\x6d\x25\xb0\x53\xde\x2\xc9\xa7\x6\x49\xeb\xc\xce\x40\xa2\x2b\xd3\x54\xcd\xb2\x46\xa3\xda\x45\xe2\xf5\x5f\xb\x90\xf1\xbf\xaa\x35\x28\xca\xf5\x46\x2c\xe7\xad\x41\xc1\x27\x76\x94\x76\xaf\xbd\x8d\xbe\xcd\xcc\x11\x6f\xa0\xe7\x19\xbc\xa\x79\x9f\xb8\xfd\xf1\xf6\xd\xf4\x1d\xbb\xba\xf0\x49\x3f\x54\x7b\x34\x2d\xb5\x5b\xcd\x47\x48\x8\x33\xb6\x43\xc\x11\xbf\x3\xe7\x7d\xc6\xdd\xbb\x77\xef\xde\xe\x31\xff\xf2\xe7\xe9\x38\xfb\x4e\x88\xfd\x57\xf3\xec\xbb\x21\xf6\x5f\xff\x3c\xbd\xf3\x7b\xb0\xa6\x5b\xe3\x78\x74\x77\x50\xec\x3d\xd8\xb9\x2f\x7c\xf1\xa1\x27\x34\xb4\x46\x9a\x39\xac\x58\xf6\x70\xf6\xcb\x68\x5a\x8b\x39\xa1\xdf\x47\x4f\x8e\xfe\x5b\x10\x7e\x21\x26\xf6\x3a\x3b\x7f\x23\x6e\xec\x71\xc5\x8e\xbf\x77\xa\x19\x8c\x88\x4e\x3\xfc\x7f\x1\x0\x0\xff\xff\x11\x83\x2b\x9");
  }
}
