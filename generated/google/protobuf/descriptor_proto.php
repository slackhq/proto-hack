<?hh // strict
namespace google\protobuf;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/descriptor.proto

class FileDescriptorSet implements \Protobuf\Message {
  public vec<\google\protobuf\FileDescriptorProto> $file;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'file' => vec<\google\protobuf\FileDescriptorProto>,
  ) $s = shape()) {
    $this->file = $s['file'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.FileDescriptorSet";
  }

  public static function ParseFrom(string $input): ?FileDescriptorSet {
    $msg = new FileDescriptorSet();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\FileDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->file []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->file as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('file', 'file', $this->file);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'file':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FileDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->file []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileDescriptorSet)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->file as $v) {
      $nv = new \google\protobuf\FileDescriptorProto();
      $nv->CopyFrom($v);
      $this->file []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class FileDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private string $package;
  private bool $was_package_set;
  public vec<string> $dependency;
  public vec<int> $public_dependency;
  public vec<int> $weak_dependency;
  public vec<\google\protobuf\DescriptorProto> $message_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\ServiceDescriptorProto> $service;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  private ?\google\protobuf\FileOptions $options;
  private bool $was_options_set;
  private ?\google\protobuf\SourceCodeInfo $source_code_info;
  private bool $was_source_code_info_set;
  private string $syntax;
  private bool $was_syntax_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'package' => string,
    ?'dependency' => vec<string>,
    ?'public_dependency' => vec<int>,
    ?'weak_dependency' => vec<int>,
    ?'message_type' => vec<\google\protobuf\DescriptorProto>,
    ?'enum_type' => vec<\google\protobuf\EnumDescriptorProto>,
    ?'service' => vec<\google\protobuf\ServiceDescriptorProto>,
    ?'extension' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'options' => ?\google\protobuf\FileOptions,
    ?'source_code_info' => ?\google\protobuf\SourceCodeInfo,
    ?'syntax' => string,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'package')) {
      $this->package = $s['package'];
      $this->was_package_set = true;
    } else {
      $this->package = '';
      $this->was_package_set = false;
    }
    $this->dependency = $s['dependency'] ?? vec[];
    $this->public_dependency = $s['public_dependency'] ?? vec[];
    $this->weak_dependency = $s['weak_dependency'] ?? vec[];
    $this->message_type = $s['message_type'] ?? vec[];
    $this->enum_type = $s['enum_type'] ?? vec[];
    $this->service = $s['service'] ?? vec[];
    $this->extension = $s['extension'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    if (Shapes::keyExists($s, 'source_code_info')) {
      $this->source_code_info = $s['source_code_info'];
      $this->was_source_code_info_set = true;
    } else {
      $this->source_code_info = null;
      $this->was_source_code_info_set = false;
    }
    if (Shapes::keyExists($s, 'syntax')) {
      $this->syntax = $s['syntax'];
      $this->was_syntax_set = true;
    } else {
      $this->syntax = '';
      $this->was_syntax_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getPackage(): string {
    return $this->package;
  }

  public function setPackage(string $v): void {
    $this->package = $v;
    $this->was_package_set = true;
  }

  public function hasPackage(): bool {
    return $this->was_package_set;
  }

  public function getOptions(): ?\google\protobuf\FileOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\FileOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function getSourceCodeInfo(): ?\google\protobuf\SourceCodeInfo {
    return $this->source_code_info;
  }

  public function setSourceCodeInfo(?\google\protobuf\SourceCodeInfo $v): void {
    $this->source_code_info = $v;
    $this->was_source_code_info_set = true;
  }

  public function hasSourceCodeInfo(): bool {
    return $this->was_source_code_info_set;
  }

  public function getSyntax(): string {
    return $this->syntax;
  }

  public function setSyntax(string $v): void {
    $this->syntax = $v;
    $this->was_syntax_set = true;
  }

  public function hasSyntax(): bool {
    return $this->was_syntax_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FileDescriptorProto";
  }

  public static function ParseFrom(string $input): ?FileDescriptorProto {
    $msg = new FileDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->package = $d->readString();
          $this->was_package_set = true;
          break;
        case 3:
          $this->dependency []= $d->readString();
          break;
        case 4:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->message_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\ServiceDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->service []= $obj;
          break;
        case 7:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 8:
          if ($this->options is null) {
            $this->options = new \google\protobuf\FileOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          if ($this->source_code_info is null) {
            $this->source_code_info = new \google\protobuf\SourceCodeInfo();
            $this->was_source_code_info_set = true;
          }
          $this->source_code_info->MergeFrom($d->readDecoder());
          break;
        case 10:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->public_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->public_dependency []= $d->readVarint32Signed();
          }
          break;
        case 11:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->weak_dependency []= $packed->readVarint32Signed();
            }
          } else {
            $this->weak_dependency []= $d->readVarint32Signed();
          }
          break;
        case 12:
          $this->syntax = $d->readString();
          $this->was_syntax_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_package_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->package);
    }
    foreach ($this->dependency as $elem) {
      $e->writeTag(3, 2);
      $e->writeString($elem);
    }
    foreach ($this->message_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->service as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 7);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 8);
      }
    }
    $msg = $this->source_code_info;
    if ($msg != null) {
      if ($this->was_source_code_info_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 9);
      }
    }
    foreach ($this->public_dependency as $elem) {
      $e->writeTag(10, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->weak_dependency as $elem) {
      $e->writeTag(11, 0);
      $e->writeVarint($elem);
    }
    if ($this->was_syntax_set) {
      $e->writeTag(12, 2);
      $e->writeString($this->syntax);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasPackage()) {
      $e->writeString('package', 'package', $this->package, false);
    }
    $e->writePrimitiveList('dependency', 'dependency', $this->dependency);
    $e->writeMessageList('message_type', 'messageType', $this->message_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('service', 'service', $this->service);
    $e->writeMessageList('extension', 'extension', $this->extension);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    if ($this->hasSourceCodeInfo()) {
      $e->writeMessage('source_code_info', 'sourceCodeInfo', $this->source_code_info, false);
    }
    $e->writePrimitiveList('public_dependency', 'publicDependency', $this->public_dependency);
    $e->writePrimitiveList('weak_dependency', 'weakDependency', $this->weak_dependency);
    if ($this->hasSyntax()) {
      $e->writeString('syntax', 'syntax', $this->syntax, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'package':
          $this->package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_package_set = true;
          break;
        case 'dependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->dependency []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'message_type': case 'messageType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->message_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'service':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\ServiceDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->service []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\FileOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'source_code_info': case 'sourceCodeInfo':
          if ($v is null) break;
          if ($this->source_code_info is null) {
            $this->source_code_info = new \google\protobuf\SourceCodeInfo();
            $this->was_source_code_info_set = true;
          }
          $this->source_code_info->MergeJsonFrom($v);
          break;
        case 'public_dependency': case 'publicDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->public_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'weak_dependency': case 'weakDependency':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->weak_dependency []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'syntax':
          $this->syntax = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_syntax_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasPackage()) {
      $this->setPackage($o->getPackage());
    }
    $this->dependency = $o->dependency;
    foreach ($o->message_type as $v) {
      $nv = new \google\protobuf\DescriptorProto();
      $nv->CopyFrom($v);
      $this->message_type []= $nv;
    }
    foreach ($o->enum_type as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto();
      $nv->CopyFrom($v);
      $this->enum_type []= $nv;
    }
    foreach ($o->service as $v) {
      $nv = new \google\protobuf\ServiceDescriptorProto();
      $nv->CopyFrom($v);
      $this->service []= $nv;
    }
    foreach ($o->extension as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->extension []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FileOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $tmp = $o->source_code_info;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\SourceCodeInfo();
      $nv->CopyFrom($tmp);
      $this->setSourceCodeInfo($nv);
    } else if ($o->hasSourceCodeInfo()) {
      $this->setSourceCodeInfo(null);
    }
    $this->public_dependency = $o->public_dependency;
    $this->weak_dependency = $o->weak_dependency;
    if ($o->hasSyntax()) {
      $this->setSyntax($o->getSyntax());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto_ExtensionRange implements \Protobuf\Message {
  private int $start;
  private bool $was_start_set;
  private int $end;
  private bool $was_end_set;
  private ?\google\protobuf\ExtensionRangeOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
    ?'options' => ?\google\protobuf\ExtensionRangeOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'start')) {
      $this->start = $s['start'];
      $this->was_start_set = true;
    } else {
      $this->start = 0;
      $this->was_start_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getStart(): int {
    return $this->start;
  }

  public function setStart(int $v): void {
    $this->start = $v;
    $this->was_start_set = true;
  }

  public function hasStart(): bool {
    return $this->was_start_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function getOptions(): ?\google\protobuf\ExtensionRangeOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\ExtensionRangeOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto.ExtensionRange";
  }

  public static function ParseFrom(string $input): ?DescriptorProto_ExtensionRange {
    $msg = new DescriptorProto_ExtensionRange();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          $this->was_start_set = true;
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\ExtensionRangeOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_start_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->was_end_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasStart()) {
      $e->writeInt32('start', 'start', $this->start, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_start_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\ExtensionRangeOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto_ExtensionRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasStart()) {
      $this->setStart($o->getStart());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\ExtensionRangeOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto_ReservedRange implements \Protobuf\Message {
  private int $start;
  private bool $was_start_set;
  private int $end;
  private bool $was_end_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'start')) {
      $this->start = $s['start'];
      $this->was_start_set = true;
    } else {
      $this->start = 0;
      $this->was_start_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getStart(): int {
    return $this->start;
  }

  public function setStart(int $v): void {
    $this->start = $v;
    $this->was_start_set = true;
  }

  public function hasStart(): bool {
    return $this->was_start_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto.ReservedRange";
  }

  public static function ParseFrom(string $input): ?DescriptorProto_ReservedRange {
    $msg = new DescriptorProto_ReservedRange();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          $this->was_start_set = true;
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_start_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->was_end_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasStart()) {
      $e->writeInt32('start', 'start', $this->start, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_start_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto_ReservedRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasStart()) {
      $this->setStart($o->getStart());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class DescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  public vec<\google\protobuf\FieldDescriptorProto> $field;
  public vec<\google\protobuf\FieldDescriptorProto> $extension;
  public vec<\google\protobuf\DescriptorProto> $nested_type;
  public vec<\google\protobuf\EnumDescriptorProto> $enum_type;
  public vec<\google\protobuf\DescriptorProto_ExtensionRange> $extension_range;
  public vec<\google\protobuf\OneofDescriptorProto> $oneof_decl;
  private ?\google\protobuf\MessageOptions $options;
  private bool $was_options_set;
  public vec<\google\protobuf\DescriptorProto_ReservedRange> $reserved_range;
  public vec<string> $reserved_name;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'field' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'extension' => vec<\google\protobuf\FieldDescriptorProto>,
    ?'nested_type' => vec<\google\protobuf\DescriptorProto>,
    ?'enum_type' => vec<\google\protobuf\EnumDescriptorProto>,
    ?'extension_range' => vec<\google\protobuf\DescriptorProto_ExtensionRange>,
    ?'oneof_decl' => vec<\google\protobuf\OneofDescriptorProto>,
    ?'options' => ?\google\protobuf\MessageOptions,
    ?'reserved_range' => vec<\google\protobuf\DescriptorProto_ReservedRange>,
    ?'reserved_name' => vec<string>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    $this->field = $s['field'] ?? vec[];
    $this->extension = $s['extension'] ?? vec[];
    $this->nested_type = $s['nested_type'] ?? vec[];
    $this->enum_type = $s['enum_type'] ?? vec[];
    $this->extension_range = $s['extension_range'] ?? vec[];
    $this->oneof_decl = $s['oneof_decl'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->reserved_range = $s['reserved_range'] ?? vec[];
    $this->reserved_name = $s['reserved_name'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\MessageOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\MessageOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.DescriptorProto";
  }

  public static function ParseFrom(string $input): ?DescriptorProto {
    $msg = new DescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->field []= $obj;
          break;
        case 3:
          $obj = new \google\protobuf\DescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->nested_type []= $obj;
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->enum_type []= $obj;
          break;
        case 5:
          $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
          $obj->MergeFrom($d->readDecoder());
          $this->extension_range []= $obj;
          break;
        case 6:
          $obj = new \google\protobuf\FieldDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->extension []= $obj;
          break;
        case 7:
          if ($this->options is null) {
            $this->options = new \google\protobuf\MessageOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 8:
          $obj = new \google\protobuf\OneofDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->oneof_decl []= $obj;
          break;
        case 9:
          $obj = new \google\protobuf\DescriptorProto_ReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 10:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->field as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    foreach ($this->nested_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    foreach ($this->enum_type as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->extension_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->extension as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 7);
      }
    }
    foreach ($this->oneof_decl as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 8);
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 9);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(10, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    $e->writeMessageList('field', 'field', $this->field);
    $e->writeMessageList('nested_type', 'nestedType', $this->nested_type);
    $e->writeMessageList('enum_type', 'enumType', $this->enum_type);
    $e->writeMessageList('extension_range', 'extensionRange', $this->extension_range);
    $e->writeMessageList('extension', 'extension', $this->extension);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    $e->writeMessageList('oneof_decl', 'oneofDecl', $this->oneof_decl);
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'field':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->field []= $obj;
          }
          break;
        case 'nested_type': case 'nestedType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->nested_type []= $obj;
          }
          break;
        case 'enum_type': case 'enumType':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->enum_type []= $obj;
          }
          break;
        case 'extension_range': case 'extensionRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ExtensionRange();
            $obj->MergeJsonFrom($vv);
            $this->extension_range []= $obj;
          }
          break;
        case 'extension':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\FieldDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->extension []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\MessageOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_decl': case 'oneofDecl':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\OneofDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->oneof_decl []= $obj;
          }
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\DescriptorProto_ReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is DescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    foreach ($o->field as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->field []= $nv;
    }
    foreach ($o->nested_type as $v) {
      $nv = new \google\protobuf\DescriptorProto();
      $nv->CopyFrom($v);
      $this->nested_type []= $nv;
    }
    foreach ($o->enum_type as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto();
      $nv->CopyFrom($v);
      $this->enum_type []= $nv;
    }
    foreach ($o->extension_range as $v) {
      $nv = new \google\protobuf\DescriptorProto_ExtensionRange();
      $nv->CopyFrom($v);
      $this->extension_range []= $nv;
    }
    foreach ($o->extension as $v) {
      $nv = new \google\protobuf\FieldDescriptorProto();
      $nv->CopyFrom($v);
      $this->extension []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\MessageOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    foreach ($o->oneof_decl as $v) {
      $nv = new \google\protobuf\OneofDescriptorProto();
      $nv->CopyFrom($v);
      $this->oneof_decl []= $nv;
    }
    foreach ($o->reserved_range as $v) {
      $nv = new \google\protobuf\DescriptorProto_ReservedRange();
      $nv->CopyFrom($v);
      $this->reserved_range []= $nv;
    }
    $this->reserved_name = $o->reserved_name;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ExtensionRangeOptions implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.ExtensionRangeOptions";
  }

  public static function ParseFrom(string $input): ?ExtensionRangeOptions {
    $msg = new ExtensionRangeOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ExtensionRangeOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FieldDescriptorProto_Type_enum_t as int = int;
abstract class FieldDescriptorProto_Type {
  const FieldDescriptorProto_Type_enum_t TYPE_DOUBLE = 1;
  const FieldDescriptorProto_Type_enum_t TYPE_FLOAT = 2;
  const FieldDescriptorProto_Type_enum_t TYPE_INT64 = 3;
  const FieldDescriptorProto_Type_enum_t TYPE_UINT64 = 4;
  const FieldDescriptorProto_Type_enum_t TYPE_INT32 = 5;
  const FieldDescriptorProto_Type_enum_t TYPE_FIXED64 = 6;
  const FieldDescriptorProto_Type_enum_t TYPE_FIXED32 = 7;
  const FieldDescriptorProto_Type_enum_t TYPE_BOOL = 8;
  const FieldDescriptorProto_Type_enum_t TYPE_STRING = 9;
  const FieldDescriptorProto_Type_enum_t TYPE_GROUP = 10;
  const FieldDescriptorProto_Type_enum_t TYPE_MESSAGE = 11;
  const FieldDescriptorProto_Type_enum_t TYPE_BYTES = 12;
  const FieldDescriptorProto_Type_enum_t TYPE_UINT32 = 13;
  const FieldDescriptorProto_Type_enum_t TYPE_ENUM = 14;
  const FieldDescriptorProto_Type_enum_t TYPE_SFIXED32 = 15;
  const FieldDescriptorProto_Type_enum_t TYPE_SFIXED64 = 16;
  const FieldDescriptorProto_Type_enum_t TYPE_SINT32 = 17;
  const FieldDescriptorProto_Type_enum_t TYPE_SINT64 = 18;
  private static dict<int, string> $itos = dict[
    1 => 'TYPE_DOUBLE',
    2 => 'TYPE_FLOAT',
    3 => 'TYPE_INT64',
    4 => 'TYPE_UINT64',
    5 => 'TYPE_INT32',
    6 => 'TYPE_FIXED64',
    7 => 'TYPE_FIXED32',
    8 => 'TYPE_BOOL',
    9 => 'TYPE_STRING',
    10 => 'TYPE_GROUP',
    11 => 'TYPE_MESSAGE',
    12 => 'TYPE_BYTES',
    13 => 'TYPE_UINT32',
    14 => 'TYPE_ENUM',
    15 => 'TYPE_SFIXED32',
    16 => 'TYPE_SFIXED64',
    17 => 'TYPE_SINT32',
    18 => 'TYPE_SINT64',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'TYPE_DOUBLE' => 1,
    'TYPE_FLOAT' => 2,
    'TYPE_INT64' => 3,
    'TYPE_UINT64' => 4,
    'TYPE_INT32' => 5,
    'TYPE_FIXED64' => 6,
    'TYPE_FIXED32' => 7,
    'TYPE_BOOL' => 8,
    'TYPE_STRING' => 9,
    'TYPE_GROUP' => 10,
    'TYPE_MESSAGE' => 11,
    'TYPE_BYTES' => 12,
    'TYPE_UINT32' => 13,
    'TYPE_ENUM' => 14,
    'TYPE_SFIXED32' => 15,
    'TYPE_SFIXED64' => 16,
    'TYPE_SINT32' => 17,
    'TYPE_SINT64' => 18,
  ];
  public static function FromMixed(mixed $m): FieldDescriptorProto_Type_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldDescriptorProto_Type_enum_t {
    return $i;
  }
}

newtype FieldDescriptorProto_Label_enum_t as int = int;
abstract class FieldDescriptorProto_Label {
  const FieldDescriptorProto_Label_enum_t LABEL_OPTIONAL = 1;
  const FieldDescriptorProto_Label_enum_t LABEL_REQUIRED = 2;
  const FieldDescriptorProto_Label_enum_t LABEL_REPEATED = 3;
  private static dict<int, string> $itos = dict[
    1 => 'LABEL_OPTIONAL',
    2 => 'LABEL_REQUIRED',
    3 => 'LABEL_REPEATED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'LABEL_OPTIONAL' => 1,
    'LABEL_REQUIRED' => 2,
    'LABEL_REPEATED' => 3,
  ];
  public static function FromMixed(mixed $m): FieldDescriptorProto_Label_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldDescriptorProto_Label_enum_t {
    return $i;
  }
}

class FieldDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private int $number;
  private bool $was_number_set;
  private \google\protobuf\FieldDescriptorProto_Label_enum_t $label;
  private bool $was_label_set;
  private \google\protobuf\FieldDescriptorProto_Type_enum_t $type;
  private bool $was_type_set;
  private string $type_name;
  private bool $was_type_name_set;
  private string $extendee;
  private bool $was_extendee_set;
  private string $default_value;
  private bool $was_default_value_set;
  private int $oneof_index;
  private bool $was_oneof_index_set;
  private string $json_name;
  private bool $was_json_name_set;
  private ?\google\protobuf\FieldOptions $options;
  private bool $was_options_set;
  private bool $proto3_optional;
  private bool $was_proto3_optional_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'number' => int,
    ?'label' => \google\protobuf\FieldDescriptorProto_Label_enum_t,
    ?'type' => \google\protobuf\FieldDescriptorProto_Type_enum_t,
    ?'type_name' => string,
    ?'extendee' => string,
    ?'default_value' => string,
    ?'oneof_index' => int,
    ?'json_name' => string,
    ?'options' => ?\google\protobuf\FieldOptions,
    ?'proto3_optional' => bool,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'number')) {
      $this->number = $s['number'];
      $this->was_number_set = true;
    } else {
      $this->number = 0;
      $this->was_number_set = false;
    }
    if (Shapes::keyExists($s, 'label')) {
      $this->label = $s['label'];
      $this->was_label_set = true;
    } else {
      $this->label = \google\protobuf\FieldDescriptorProto_Label::LABEL_OPTIONAL;
      $this->was_label_set = false;
    }
    if (Shapes::keyExists($s, 'type')) {
      $this->type = $s['type'];
      $this->was_type_set = true;
    } else {
      $this->type = \google\protobuf\FieldDescriptorProto_Type::TYPE_DOUBLE;
      $this->was_type_set = false;
    }
    if (Shapes::keyExists($s, 'type_name')) {
      $this->type_name = $s['type_name'];
      $this->was_type_name_set = true;
    } else {
      $this->type_name = '';
      $this->was_type_name_set = false;
    }
    if (Shapes::keyExists($s, 'extendee')) {
      $this->extendee = $s['extendee'];
      $this->was_extendee_set = true;
    } else {
      $this->extendee = '';
      $this->was_extendee_set = false;
    }
    if (Shapes::keyExists($s, 'default_value')) {
      $this->default_value = $s['default_value'];
      $this->was_default_value_set = true;
    } else {
      $this->default_value = '';
      $this->was_default_value_set = false;
    }
    if (Shapes::keyExists($s, 'oneof_index')) {
      $this->oneof_index = $s['oneof_index'];
      $this->was_oneof_index_set = true;
    } else {
      $this->oneof_index = 0;
      $this->was_oneof_index_set = false;
    }
    if (Shapes::keyExists($s, 'json_name')) {
      $this->json_name = $s['json_name'];
      $this->was_json_name_set = true;
    } else {
      $this->json_name = '';
      $this->was_json_name_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    if (Shapes::keyExists($s, 'proto3_optional')) {
      $this->proto3_optional = $s['proto3_optional'];
      $this->was_proto3_optional_set = true;
    } else {
      $this->proto3_optional = false;
      $this->was_proto3_optional_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getNumber(): int {
    return $this->number;
  }

  public function setNumber(int $v): void {
    $this->number = $v;
    $this->was_number_set = true;
  }

  public function hasNumber(): bool {
    return $this->was_number_set;
  }

  public function getLabel(): \google\protobuf\FieldDescriptorProto_Label_enum_t {
    return $this->label;
  }

  public function setLabel(\google\protobuf\FieldDescriptorProto_Label_enum_t $v): void {
    $this->label = $v;
    $this->was_label_set = true;
  }

  public function hasLabel(): bool {
    return $this->was_label_set;
  }

  public function getType(): \google\protobuf\FieldDescriptorProto_Type_enum_t {
    return $this->type;
  }

  public function setType(\google\protobuf\FieldDescriptorProto_Type_enum_t $v): void {
    $this->type = $v;
    $this->was_type_set = true;
  }

  public function hasType(): bool {
    return $this->was_type_set;
  }

  public function getTypeName(): string {
    return $this->type_name;
  }

  public function setTypeName(string $v): void {
    $this->type_name = $v;
    $this->was_type_name_set = true;
  }

  public function hasTypeName(): bool {
    return $this->was_type_name_set;
  }

  public function getExtendee(): string {
    return $this->extendee;
  }

  public function setExtendee(string $v): void {
    $this->extendee = $v;
    $this->was_extendee_set = true;
  }

  public function hasExtendee(): bool {
    return $this->was_extendee_set;
  }

  public function getDefaultValue(): string {
    return $this->default_value;
  }

  public function setDefaultValue(string $v): void {
    $this->default_value = $v;
    $this->was_default_value_set = true;
  }

  public function hasDefaultValue(): bool {
    return $this->was_default_value_set;
  }

  public function getOneofIndex(): int {
    return $this->oneof_index;
  }

  public function setOneofIndex(int $v): void {
    $this->oneof_index = $v;
    $this->was_oneof_index_set = true;
  }

  public function hasOneofIndex(): bool {
    return $this->was_oneof_index_set;
  }

  public function getJsonName(): string {
    return $this->json_name;
  }

  public function setJsonName(string $v): void {
    $this->json_name = $v;
    $this->was_json_name_set = true;
  }

  public function hasJsonName(): bool {
    return $this->was_json_name_set;
  }

  public function getOptions(): ?\google\protobuf\FieldOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\FieldOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function getProto3Optional(): bool {
    return $this->proto3_optional;
  }

  public function setProto3Optional(bool $v): void {
    $this->proto3_optional = $v;
    $this->was_proto3_optional_set = true;
  }

  public function hasProto3Optional(): bool {
    return $this->was_proto3_optional_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FieldDescriptorProto";
  }

  public static function ParseFrom(string $input): ?FieldDescriptorProto {
    $msg = new FieldDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->extendee = $d->readString();
          $this->was_extendee_set = true;
          break;
        case 3:
          $this->number = $d->readVarint32Signed();
          $this->was_number_set = true;
          break;
        case 4:
          $this->label = \google\protobuf\FieldDescriptorProto_Label::FromInt($d->readVarint());
          $this->was_label_set = true;
          break;
        case 5:
          $this->type = \google\protobuf\FieldDescriptorProto_Type::FromInt($d->readVarint());
          $this->was_type_set = true;
          break;
        case 6:
          $this->type_name = $d->readString();
          $this->was_type_name_set = true;
          break;
        case 7:
          $this->default_value = $d->readString();
          $this->was_default_value_set = true;
          break;
        case 8:
          if ($this->options is null) {
            $this->options = new \google\protobuf\FieldOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 9:
          $this->oneof_index = $d->readVarint32Signed();
          $this->was_oneof_index_set = true;
          break;
        case 10:
          $this->json_name = $d->readString();
          $this->was_json_name_set = true;
          break;
        case 17:
          $this->proto3_optional = $d->readBool();
          $this->was_proto3_optional_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_extendee_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->extendee);
    }
    if ($this->was_number_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->number);
    }
    if ($this->was_label_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->label);
    }
    if ($this->was_type_set) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->type);
    }
    if ($this->was_type_name_set) {
      $e->writeTag(6, 2);
      $e->writeString($this->type_name);
    }
    if ($this->was_default_value_set) {
      $e->writeTag(7, 2);
      $e->writeString($this->default_value);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 8);
      }
    }
    if ($this->was_oneof_index_set) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->oneof_index);
    }
    if ($this->was_json_name_set) {
      $e->writeTag(10, 2);
      $e->writeString($this->json_name);
    }
    if ($this->was_proto3_optional_set) {
      $e->writeTag(17, 0);
      $e->writeBool($this->proto3_optional);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasExtendee()) {
      $e->writeString('extendee', 'extendee', $this->extendee, false);
    }
    if ($this->hasNumber()) {
      $e->writeInt32('number', 'number', $this->number, false);
    }
    if ($this->hasLabel()) {
      $e->writeEnum('label', 'label', \google\protobuf\FieldDescriptorProto_Label::ToStringDict(), $this->label, false);
    }
    if ($this->hasType()) {
      $e->writeEnum('type', 'type', \google\protobuf\FieldDescriptorProto_Type::ToStringDict(), $this->type, false);
    }
    if ($this->hasTypeName()) {
      $e->writeString('type_name', 'typeName', $this->type_name, false);
    }
    if ($this->hasDefaultValue()) {
      $e->writeString('default_value', 'defaultValue', $this->default_value, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    if ($this->hasOneofIndex()) {
      $e->writeInt32('oneof_index', 'oneofIndex', $this->oneof_index, false);
    }
    if ($this->hasJsonName()) {
      $e->writeString('json_name', 'jsonName', $this->json_name, false);
    }
    if ($this->hasProto3Optional()) {
      $e->writeBool('proto3_optional', 'proto3Optional', $this->proto3_optional, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'extendee':
          $this->extendee = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_extendee_set = true;
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_number_set = true;
          break;
        case 'label':
          $this->label = \google\protobuf\FieldDescriptorProto_Label::FromMixed($v);
          $this->was_label_set = true;
          break;
        case 'type':
          $this->type = \google\protobuf\FieldDescriptorProto_Type::FromMixed($v);
          $this->was_type_set = true;
          break;
        case 'type_name': case 'typeName':
          $this->type_name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_type_name_set = true;
          break;
        case 'default_value': case 'defaultValue':
          $this->default_value = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_default_value_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\FieldOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'oneof_index': case 'oneofIndex':
          $this->oneof_index = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_oneof_index_set = true;
          break;
        case 'json_name': case 'jsonName':
          $this->json_name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_json_name_set = true;
          break;
        case 'proto3_optional': case 'proto3Optional':
          $this->proto3_optional = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_proto3_optional_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FieldDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasExtendee()) {
      $this->setExtendee($o->getExtendee());
    }
    if ($o->hasNumber()) {
      $this->setNumber($o->getNumber());
    }
    if ($o->hasLabel()) {
      $this->setLabel($o->getLabel());
    }
    if ($o->hasType()) {
      $this->setType($o->getType());
    }
    if ($o->hasTypeName()) {
      $this->setTypeName($o->getTypeName());
    }
    if ($o->hasDefaultValue()) {
      $this->setDefaultValue($o->getDefaultValue());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\FieldOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    if ($o->hasOneofIndex()) {
      $this->setOneofIndex($o->getOneofIndex());
    }
    if ($o->hasJsonName()) {
      $this->setJsonName($o->getJsonName());
    }
    if ($o->hasProto3Optional()) {
      $this->setProto3Optional($o->getProto3Optional());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class OneofDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private ?\google\protobuf\OneofOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'options' => ?\google\protobuf\OneofOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\OneofOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\OneofOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.OneofDescriptorProto";
  }

  public static function ParseFrom(string $input): ?OneofDescriptorProto {
    $msg = new OneofDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          if ($this->options is null) {
            $this->options = new \google\protobuf\OneofOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 2);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\OneofOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is OneofDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\OneofOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumDescriptorProto_EnumReservedRange implements \Protobuf\Message {
  private int $start;
  private bool $was_start_set;
  private int $end;
  private bool $was_end_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'start' => int,
    ?'end' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'start')) {
      $this->start = $s['start'];
      $this->was_start_set = true;
    } else {
      $this->start = 0;
      $this->was_start_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getStart(): int {
    return $this->start;
  }

  public function setStart(int $v): void {
    $this->start = $v;
    $this->was_start_set = true;
  }

  public function hasStart(): bool {
    return $this->was_start_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumDescriptorProto.EnumReservedRange";
  }

  public static function ParseFrom(string $input): ?EnumDescriptorProto_EnumReservedRange {
    $msg = new EnumDescriptorProto_EnumReservedRange();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->start = $d->readVarint32Signed();
          $this->was_start_set = true;
          break;
        case 2:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_start_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->start);
    }
    if ($this->was_end_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->end);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasStart()) {
      $e->writeInt32('start', 'start', $this->start, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'start':
          $this->start = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_start_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumDescriptorProto_EnumReservedRange)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasStart()) {
      $this->setStart($o->getStart());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  public vec<\google\protobuf\EnumValueDescriptorProto> $value;
  private ?\google\protobuf\EnumOptions $options;
  private bool $was_options_set;
  public vec<\google\protobuf\EnumDescriptorProto_EnumReservedRange> $reserved_range;
  public vec<string> $reserved_name;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'value' => vec<\google\protobuf\EnumValueDescriptorProto>,
    ?'options' => ?\google\protobuf\EnumOptions,
    ?'reserved_range' => vec<\google\protobuf\EnumDescriptorProto_EnumReservedRange>,
    ?'reserved_name' => vec<string>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    $this->value = $s['value'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->reserved_range = $s['reserved_range'] ?? vec[];
    $this->reserved_name = $s['reserved_name'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\EnumOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\EnumOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumDescriptorProto";
  }

  public static function ParseFrom(string $input): ?EnumDescriptorProto {
    $msg = new EnumDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $obj = new \google\protobuf\EnumValueDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->value []= $obj;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 4:
          $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
          $obj->MergeFrom($d->readDecoder());
          $this->reserved_range []= $obj;
          break;
        case 5:
          $this->reserved_name []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->value as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    foreach ($this->reserved_range as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    foreach ($this->reserved_name as $elem) {
      $e->writeTag(5, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    $e->writeMessageList('value', 'value', $this->value);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    $e->writeMessageList('reserved_range', 'reservedRange', $this->reserved_range);
    $e->writePrimitiveList('reserved_name', 'reservedName', $this->reserved_name);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'value':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumValueDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->value []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'reserved_range': case 'reservedRange':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
            $obj->MergeJsonFrom($vv);
            $this->reserved_range []= $obj;
          }
          break;
        case 'reserved_name': case 'reservedName':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->reserved_name []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    foreach ($o->value as $v) {
      $nv = new \google\protobuf\EnumValueDescriptorProto();
      $nv->CopyFrom($v);
      $this->value []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\EnumOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    foreach ($o->reserved_range as $v) {
      $nv = new \google\protobuf\EnumDescriptorProto_EnumReservedRange();
      $nv->CopyFrom($v);
      $this->reserved_range []= $nv;
    }
    $this->reserved_name = $o->reserved_name;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumValueDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private int $number;
  private bool $was_number_set;
  private ?\google\protobuf\EnumValueOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'number' => int,
    ?'options' => ?\google\protobuf\EnumValueOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'number')) {
      $this->number = $s['number'];
      $this->was_number_set = true;
    } else {
      $this->number = 0;
      $this->was_number_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getNumber(): int {
    return $this->number;
  }

  public function setNumber(int $v): void {
    $this->number = $v;
    $this->was_number_set = true;
  }

  public function hasNumber(): bool {
    return $this->was_number_set;
  }

  public function getOptions(): ?\google\protobuf\EnumValueOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\EnumValueOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumValueDescriptorProto";
  }

  public static function ParseFrom(string $input): ?EnumValueDescriptorProto {
    $msg = new EnumValueDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->number = $d->readVarint32Signed();
          $this->was_number_set = true;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumValueOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_number_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->number);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasNumber()) {
      $e->writeInt32('number', 'number', $this->number, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_number_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\EnumValueOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumValueDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasNumber()) {
      $this->setNumber($o->getNumber());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\EnumValueOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ServiceDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  public vec<\google\protobuf\MethodDescriptorProto> $method;
  private ?\google\protobuf\ServiceOptions $options;
  private bool $was_options_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'method' => vec<\google\protobuf\MethodDescriptorProto>,
    ?'options' => ?\google\protobuf\ServiceOptions,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    $this->method = $s['method'] ?? vec[];
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getOptions(): ?\google\protobuf\ServiceOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\ServiceOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function MessageName(): string {
    return "google.protobuf.ServiceDescriptorProto";
  }

  public static function ParseFrom(string $input): ?ServiceDescriptorProto {
    $msg = new ServiceDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $obj = new \google\protobuf\MethodDescriptorProto();
          $obj->MergeFrom($d->readDecoder());
          $this->method []= $obj;
          break;
        case 3:
          if ($this->options is null) {
            $this->options = new \google\protobuf\ServiceOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->method as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    $e->writeMessageList('method', 'method', $this->method);
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'method':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\MethodDescriptorProto();
            $obj->MergeJsonFrom($vv);
            $this->method []= $obj;
          }
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\ServiceOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ServiceDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    foreach ($o->method as $v) {
      $nv = new \google\protobuf\MethodDescriptorProto();
      $nv->CopyFrom($v);
      $this->method []= $nv;
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\ServiceOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class MethodDescriptorProto implements \Protobuf\Message {
  private string $name;
  private bool $was_name_set;
  private string $input_type;
  private bool $was_input_type_set;
  private string $output_type;
  private bool $was_output_type_set;
  private ?\google\protobuf\MethodOptions $options;
  private bool $was_options_set;
  private bool $client_streaming;
  private bool $was_client_streaming_set;
  private bool $server_streaming;
  private bool $was_server_streaming_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'input_type' => string,
    ?'output_type' => string,
    ?'options' => ?\google\protobuf\MethodOptions,
    ?'client_streaming' => bool,
    ?'server_streaming' => bool,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'name')) {
      $this->name = $s['name'];
      $this->was_name_set = true;
    } else {
      $this->name = '';
      $this->was_name_set = false;
    }
    if (Shapes::keyExists($s, 'input_type')) {
      $this->input_type = $s['input_type'];
      $this->was_input_type_set = true;
    } else {
      $this->input_type = '';
      $this->was_input_type_set = false;
    }
    if (Shapes::keyExists($s, 'output_type')) {
      $this->output_type = $s['output_type'];
      $this->was_output_type_set = true;
    } else {
      $this->output_type = '';
      $this->was_output_type_set = false;
    }
    if (Shapes::keyExists($s, 'options')) {
      $this->options = $s['options'];
      $this->was_options_set = true;
    } else {
      $this->options = null;
      $this->was_options_set = false;
    }
    if (Shapes::keyExists($s, 'client_streaming')) {
      $this->client_streaming = $s['client_streaming'];
      $this->was_client_streaming_set = true;
    } else {
      $this->client_streaming = false;
      $this->was_client_streaming_set = false;
    }
    if (Shapes::keyExists($s, 'server_streaming')) {
      $this->server_streaming = $s['server_streaming'];
      $this->was_server_streaming_set = true;
    } else {
      $this->server_streaming = false;
      $this->was_server_streaming_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getName(): string {
    return $this->name;
  }

  public function setName(string $v): void {
    $this->name = $v;
    $this->was_name_set = true;
  }

  public function hasName(): bool {
    return $this->was_name_set;
  }

  public function getInputType(): string {
    return $this->input_type;
  }

  public function setInputType(string $v): void {
    $this->input_type = $v;
    $this->was_input_type_set = true;
  }

  public function hasInputType(): bool {
    return $this->was_input_type_set;
  }

  public function getOutputType(): string {
    return $this->output_type;
  }

  public function setOutputType(string $v): void {
    $this->output_type = $v;
    $this->was_output_type_set = true;
  }

  public function hasOutputType(): bool {
    return $this->was_output_type_set;
  }

  public function getOptions(): ?\google\protobuf\MethodOptions {
    return $this->options;
  }

  public function setOptions(?\google\protobuf\MethodOptions $v): void {
    $this->options = $v;
    $this->was_options_set = true;
  }

  public function hasOptions(): bool {
    return $this->was_options_set;
  }

  public function getClientStreaming(): bool {
    return $this->client_streaming;
  }

  public function setClientStreaming(bool $v): void {
    $this->client_streaming = $v;
    $this->was_client_streaming_set = true;
  }

  public function hasClientStreaming(): bool {
    return $this->was_client_streaming_set;
  }

  public function getServerStreaming(): bool {
    return $this->server_streaming;
  }

  public function setServerStreaming(bool $v): void {
    $this->server_streaming = $v;
    $this->was_server_streaming_set = true;
  }

  public function hasServerStreaming(): bool {
    return $this->was_server_streaming_set;
  }

  public function MessageName(): string {
    return "google.protobuf.MethodDescriptorProto";
  }

  public static function ParseFrom(string $input): ?MethodDescriptorProto {
    $msg = new MethodDescriptorProto();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          $this->was_name_set = true;
          break;
        case 2:
          $this->input_type = $d->readString();
          $this->was_input_type_set = true;
          break;
        case 3:
          $this->output_type = $d->readString();
          $this->was_output_type_set = true;
          break;
        case 4:
          if ($this->options is null) {
            $this->options = new \google\protobuf\MethodOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeFrom($d->readDecoder());
          break;
        case 5:
          $this->client_streaming = $d->readBool();
          $this->was_client_streaming_set = true;
          break;
        case 6:
          $this->server_streaming = $d->readBool();
          $this->was_server_streaming_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_name_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->was_input_type_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->input_type);
    }
    if ($this->was_output_type_set) {
      $e->writeTag(3, 2);
      $e->writeString($this->output_type);
    }
    $msg = $this->options;
    if ($msg != null) {
      if ($this->was_options_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 4);
      }
    }
    if ($this->was_client_streaming_set) {
      $e->writeTag(5, 0);
      $e->writeBool($this->client_streaming);
    }
    if ($this->was_server_streaming_set) {
      $e->writeTag(6, 0);
      $e->writeBool($this->server_streaming);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasName()) {
      $e->writeString('name', 'name', $this->name, false);
    }
    if ($this->hasInputType()) {
      $e->writeString('input_type', 'inputType', $this->input_type, false);
    }
    if ($this->hasOutputType()) {
      $e->writeString('output_type', 'outputType', $this->output_type, false);
    }
    if ($this->hasOptions()) {
      $e->writeMessage('options', 'options', $this->options, false);
    }
    if ($this->hasClientStreaming()) {
      $e->writeBool('client_streaming', 'clientStreaming', $this->client_streaming, false);
    }
    if ($this->hasServerStreaming()) {
      $e->writeBool('server_streaming', 'serverStreaming', $this->server_streaming, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_name_set = true;
          break;
        case 'input_type': case 'inputType':
          $this->input_type = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_input_type_set = true;
          break;
        case 'output_type': case 'outputType':
          $this->output_type = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_output_type_set = true;
          break;
        case 'options':
          if ($v is null) break;
          if ($this->options is null) {
            $this->options = new \google\protobuf\MethodOptions();
            $this->was_options_set = true;
          }
          $this->options->MergeJsonFrom($v);
          break;
        case 'client_streaming': case 'clientStreaming':
          $this->client_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_client_streaming_set = true;
          break;
        case 'server_streaming': case 'serverStreaming':
          $this->server_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_server_streaming_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MethodDescriptorProto)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasName()) {
      $this->setName($o->getName());
    }
    if ($o->hasInputType()) {
      $this->setInputType($o->getInputType());
    }
    if ($o->hasOutputType()) {
      $this->setOutputType($o->getOutputType());
    }
    $tmp = $o->options;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\MethodOptions();
      $nv->CopyFrom($tmp);
      $this->setOptions($nv);
    } else if ($o->hasOptions()) {
      $this->setOptions(null);
    }
    if ($o->hasClientStreaming()) {
      $this->setClientStreaming($o->getClientStreaming());
    }
    if ($o->hasServerStreaming()) {
      $this->setServerStreaming($o->getServerStreaming());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FileOptions_OptimizeMode_enum_t as int = int;
abstract class FileOptions_OptimizeMode {
  const FileOptions_OptimizeMode_enum_t SPEED = 1;
  const FileOptions_OptimizeMode_enum_t CODE_SIZE = 2;
  const FileOptions_OptimizeMode_enum_t LITE_RUNTIME = 3;
  private static dict<int, string> $itos = dict[
    1 => 'SPEED',
    2 => 'CODE_SIZE',
    3 => 'LITE_RUNTIME',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'SPEED' => 1,
    'CODE_SIZE' => 2,
    'LITE_RUNTIME' => 3,
  ];
  public static function FromMixed(mixed $m): FileOptions_OptimizeMode_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FileOptions_OptimizeMode_enum_t {
    return $i;
  }
}

class FileOptions implements \Protobuf\Message {
  private string $java_package;
  private bool $was_java_package_set;
  private string $java_outer_classname;
  private bool $was_java_outer_classname_set;
  private bool $java_multiple_files;
  private bool $was_java_multiple_files_set;
  private bool $java_generate_equals_and_hash;
  private bool $was_java_generate_equals_and_hash_set;
  private bool $java_string_check_utf8;
  private bool $was_java_string_check_utf8_set;
  private \google\protobuf\FileOptions_OptimizeMode_enum_t $optimize_for;
  private bool $was_optimize_for_set;
  private string $go_package;
  private bool $was_go_package_set;
  private bool $cc_generic_services;
  private bool $was_cc_generic_services_set;
  private bool $java_generic_services;
  private bool $was_java_generic_services_set;
  private bool $py_generic_services;
  private bool $was_py_generic_services_set;
  private bool $php_generic_services;
  private bool $was_php_generic_services_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  private bool $cc_enable_arenas;
  private bool $was_cc_enable_arenas_set;
  private string $objc_class_prefix;
  private bool $was_objc_class_prefix_set;
  private string $csharp_namespace;
  private bool $was_csharp_namespace_set;
  private string $swift_prefix;
  private bool $was_swift_prefix_set;
  private string $php_class_prefix;
  private bool $was_php_class_prefix_set;
  private string $php_namespace;
  private bool $was_php_namespace_set;
  private string $php_metadata_namespace;
  private bool $was_php_metadata_namespace_set;
  private string $ruby_package;
  private bool $was_ruby_package_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'java_package' => string,
    ?'java_outer_classname' => string,
    ?'java_multiple_files' => bool,
    ?'java_generate_equals_and_hash' => bool,
    ?'java_string_check_utf8' => bool,
    ?'optimize_for' => \google\protobuf\FileOptions_OptimizeMode_enum_t,
    ?'go_package' => string,
    ?'cc_generic_services' => bool,
    ?'java_generic_services' => bool,
    ?'py_generic_services' => bool,
    ?'php_generic_services' => bool,
    ?'deprecated' => bool,
    ?'cc_enable_arenas' => bool,
    ?'objc_class_prefix' => string,
    ?'csharp_namespace' => string,
    ?'swift_prefix' => string,
    ?'php_class_prefix' => string,
    ?'php_namespace' => string,
    ?'php_metadata_namespace' => string,
    ?'ruby_package' => string,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'java_package')) {
      $this->java_package = $s['java_package'];
      $this->was_java_package_set = true;
    } else {
      $this->java_package = '';
      $this->was_java_package_set = false;
    }
    if (Shapes::keyExists($s, 'java_outer_classname')) {
      $this->java_outer_classname = $s['java_outer_classname'];
      $this->was_java_outer_classname_set = true;
    } else {
      $this->java_outer_classname = '';
      $this->was_java_outer_classname_set = false;
    }
    if (Shapes::keyExists($s, 'java_multiple_files')) {
      $this->java_multiple_files = $s['java_multiple_files'];
      $this->was_java_multiple_files_set = true;
    } else {
      $this->java_multiple_files = false;
      $this->was_java_multiple_files_set = false;
    }
    if (Shapes::keyExists($s, 'java_generate_equals_and_hash')) {
      $this->java_generate_equals_and_hash = $s['java_generate_equals_and_hash'];
      $this->was_java_generate_equals_and_hash_set = true;
    } else {
      $this->java_generate_equals_and_hash = false;
      $this->was_java_generate_equals_and_hash_set = false;
    }
    if (Shapes::keyExists($s, 'java_string_check_utf8')) {
      $this->java_string_check_utf8 = $s['java_string_check_utf8'];
      $this->was_java_string_check_utf8_set = true;
    } else {
      $this->java_string_check_utf8 = false;
      $this->was_java_string_check_utf8_set = false;
    }
    if (Shapes::keyExists($s, 'optimize_for')) {
      $this->optimize_for = $s['optimize_for'];
      $this->was_optimize_for_set = true;
    } else {
      $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::SPEED;
      $this->was_optimize_for_set = false;
    }
    if (Shapes::keyExists($s, 'go_package')) {
      $this->go_package = $s['go_package'];
      $this->was_go_package_set = true;
    } else {
      $this->go_package = '';
      $this->was_go_package_set = false;
    }
    if (Shapes::keyExists($s, 'cc_generic_services')) {
      $this->cc_generic_services = $s['cc_generic_services'];
      $this->was_cc_generic_services_set = true;
    } else {
      $this->cc_generic_services = false;
      $this->was_cc_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'java_generic_services')) {
      $this->java_generic_services = $s['java_generic_services'];
      $this->was_java_generic_services_set = true;
    } else {
      $this->java_generic_services = false;
      $this->was_java_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'py_generic_services')) {
      $this->py_generic_services = $s['py_generic_services'];
      $this->was_py_generic_services_set = true;
    } else {
      $this->py_generic_services = false;
      $this->was_py_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'php_generic_services')) {
      $this->php_generic_services = $s['php_generic_services'];
      $this->was_php_generic_services_set = true;
    } else {
      $this->php_generic_services = false;
      $this->was_php_generic_services_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'cc_enable_arenas')) {
      $this->cc_enable_arenas = $s['cc_enable_arenas'];
      $this->was_cc_enable_arenas_set = true;
    } else {
      $this->cc_enable_arenas = true;
      $this->was_cc_enable_arenas_set = false;
    }
    if (Shapes::keyExists($s, 'objc_class_prefix')) {
      $this->objc_class_prefix = $s['objc_class_prefix'];
      $this->was_objc_class_prefix_set = true;
    } else {
      $this->objc_class_prefix = '';
      $this->was_objc_class_prefix_set = false;
    }
    if (Shapes::keyExists($s, 'csharp_namespace')) {
      $this->csharp_namespace = $s['csharp_namespace'];
      $this->was_csharp_namespace_set = true;
    } else {
      $this->csharp_namespace = '';
      $this->was_csharp_namespace_set = false;
    }
    if (Shapes::keyExists($s, 'swift_prefix')) {
      $this->swift_prefix = $s['swift_prefix'];
      $this->was_swift_prefix_set = true;
    } else {
      $this->swift_prefix = '';
      $this->was_swift_prefix_set = false;
    }
    if (Shapes::keyExists($s, 'php_class_prefix')) {
      $this->php_class_prefix = $s['php_class_prefix'];
      $this->was_php_class_prefix_set = true;
    } else {
      $this->php_class_prefix = '';
      $this->was_php_class_prefix_set = false;
    }
    if (Shapes::keyExists($s, 'php_namespace')) {
      $this->php_namespace = $s['php_namespace'];
      $this->was_php_namespace_set = true;
    } else {
      $this->php_namespace = '';
      $this->was_php_namespace_set = false;
    }
    if (Shapes::keyExists($s, 'php_metadata_namespace')) {
      $this->php_metadata_namespace = $s['php_metadata_namespace'];
      $this->was_php_metadata_namespace_set = true;
    } else {
      $this->php_metadata_namespace = '';
      $this->was_php_metadata_namespace_set = false;
    }
    if (Shapes::keyExists($s, 'ruby_package')) {
      $this->ruby_package = $s['ruby_package'];
      $this->was_ruby_package_set = true;
    } else {
      $this->ruby_package = '';
      $this->was_ruby_package_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getJavaPackage(): string {
    return $this->java_package;
  }

  public function setJavaPackage(string $v): void {
    $this->java_package = $v;
    $this->was_java_package_set = true;
  }

  public function hasJavaPackage(): bool {
    return $this->was_java_package_set;
  }

  public function getJavaOuterClassname(): string {
    return $this->java_outer_classname;
  }

  public function setJavaOuterClassname(string $v): void {
    $this->java_outer_classname = $v;
    $this->was_java_outer_classname_set = true;
  }

  public function hasJavaOuterClassname(): bool {
    return $this->was_java_outer_classname_set;
  }

  public function getJavaMultipleFiles(): bool {
    return $this->java_multiple_files;
  }

  public function setJavaMultipleFiles(bool $v): void {
    $this->java_multiple_files = $v;
    $this->was_java_multiple_files_set = true;
  }

  public function hasJavaMultipleFiles(): bool {
    return $this->was_java_multiple_files_set;
  }

  public function getJavaGenerateEqualsAndHash(): bool {
    return $this->java_generate_equals_and_hash;
  }

  public function setJavaGenerateEqualsAndHash(bool $v): void {
    $this->java_generate_equals_and_hash = $v;
    $this->was_java_generate_equals_and_hash_set = true;
  }

  public function hasJavaGenerateEqualsAndHash(): bool {
    return $this->was_java_generate_equals_and_hash_set;
  }

  public function getJavaStringCheckUtf8(): bool {
    return $this->java_string_check_utf8;
  }

  public function setJavaStringCheckUtf8(bool $v): void {
    $this->java_string_check_utf8 = $v;
    $this->was_java_string_check_utf8_set = true;
  }

  public function hasJavaStringCheckUtf8(): bool {
    return $this->was_java_string_check_utf8_set;
  }

  public function getOptimizeFor(): \google\protobuf\FileOptions_OptimizeMode_enum_t {
    return $this->optimize_for;
  }

  public function setOptimizeFor(\google\protobuf\FileOptions_OptimizeMode_enum_t $v): void {
    $this->optimize_for = $v;
    $this->was_optimize_for_set = true;
  }

  public function hasOptimizeFor(): bool {
    return $this->was_optimize_for_set;
  }

  public function getGoPackage(): string {
    return $this->go_package;
  }

  public function setGoPackage(string $v): void {
    $this->go_package = $v;
    $this->was_go_package_set = true;
  }

  public function hasGoPackage(): bool {
    return $this->was_go_package_set;
  }

  public function getCcGenericServices(): bool {
    return $this->cc_generic_services;
  }

  public function setCcGenericServices(bool $v): void {
    $this->cc_generic_services = $v;
    $this->was_cc_generic_services_set = true;
  }

  public function hasCcGenericServices(): bool {
    return $this->was_cc_generic_services_set;
  }

  public function getJavaGenericServices(): bool {
    return $this->java_generic_services;
  }

  public function setJavaGenericServices(bool $v): void {
    $this->java_generic_services = $v;
    $this->was_java_generic_services_set = true;
  }

  public function hasJavaGenericServices(): bool {
    return $this->was_java_generic_services_set;
  }

  public function getPyGenericServices(): bool {
    return $this->py_generic_services;
  }

  public function setPyGenericServices(bool $v): void {
    $this->py_generic_services = $v;
    $this->was_py_generic_services_set = true;
  }

  public function hasPyGenericServices(): bool {
    return $this->was_py_generic_services_set;
  }

  public function getPhpGenericServices(): bool {
    return $this->php_generic_services;
  }

  public function setPhpGenericServices(bool $v): void {
    $this->php_generic_services = $v;
    $this->was_php_generic_services_set = true;
  }

  public function hasPhpGenericServices(): bool {
    return $this->was_php_generic_services_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getCcEnableArenas(): bool {
    return $this->cc_enable_arenas;
  }

  public function setCcEnableArenas(bool $v): void {
    $this->cc_enable_arenas = $v;
    $this->was_cc_enable_arenas_set = true;
  }

  public function hasCcEnableArenas(): bool {
    return $this->was_cc_enable_arenas_set;
  }

  public function getObjcClassPrefix(): string {
    return $this->objc_class_prefix;
  }

  public function setObjcClassPrefix(string $v): void {
    $this->objc_class_prefix = $v;
    $this->was_objc_class_prefix_set = true;
  }

  public function hasObjcClassPrefix(): bool {
    return $this->was_objc_class_prefix_set;
  }

  public function getCsharpNamespace(): string {
    return $this->csharp_namespace;
  }

  public function setCsharpNamespace(string $v): void {
    $this->csharp_namespace = $v;
    $this->was_csharp_namespace_set = true;
  }

  public function hasCsharpNamespace(): bool {
    return $this->was_csharp_namespace_set;
  }

  public function getSwiftPrefix(): string {
    return $this->swift_prefix;
  }

  public function setSwiftPrefix(string $v): void {
    $this->swift_prefix = $v;
    $this->was_swift_prefix_set = true;
  }

  public function hasSwiftPrefix(): bool {
    return $this->was_swift_prefix_set;
  }

  public function getPhpClassPrefix(): string {
    return $this->php_class_prefix;
  }

  public function setPhpClassPrefix(string $v): void {
    $this->php_class_prefix = $v;
    $this->was_php_class_prefix_set = true;
  }

  public function hasPhpClassPrefix(): bool {
    return $this->was_php_class_prefix_set;
  }

  public function getPhpNamespace(): string {
    return $this->php_namespace;
  }

  public function setPhpNamespace(string $v): void {
    $this->php_namespace = $v;
    $this->was_php_namespace_set = true;
  }

  public function hasPhpNamespace(): bool {
    return $this->was_php_namespace_set;
  }

  public function getPhpMetadataNamespace(): string {
    return $this->php_metadata_namespace;
  }

  public function setPhpMetadataNamespace(string $v): void {
    $this->php_metadata_namespace = $v;
    $this->was_php_metadata_namespace_set = true;
  }

  public function hasPhpMetadataNamespace(): bool {
    return $this->was_php_metadata_namespace_set;
  }

  public function getRubyPackage(): string {
    return $this->ruby_package;
  }

  public function setRubyPackage(string $v): void {
    $this->ruby_package = $v;
    $this->was_ruby_package_set = true;
  }

  public function hasRubyPackage(): bool {
    return $this->was_ruby_package_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FileOptions";
  }

  public static function ParseFrom(string $input): ?FileOptions {
    $msg = new FileOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->java_package = $d->readString();
          $this->was_java_package_set = true;
          break;
        case 8:
          $this->java_outer_classname = $d->readString();
          $this->was_java_outer_classname_set = true;
          break;
        case 9:
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::FromInt($d->readVarint());
          $this->was_optimize_for_set = true;
          break;
        case 10:
          $this->java_multiple_files = $d->readBool();
          $this->was_java_multiple_files_set = true;
          break;
        case 11:
          $this->go_package = $d->readString();
          $this->was_go_package_set = true;
          break;
        case 16:
          $this->cc_generic_services = $d->readBool();
          $this->was_cc_generic_services_set = true;
          break;
        case 17:
          $this->java_generic_services = $d->readBool();
          $this->was_java_generic_services_set = true;
          break;
        case 18:
          $this->py_generic_services = $d->readBool();
          $this->was_py_generic_services_set = true;
          break;
        case 20:
          $this->java_generate_equals_and_hash = $d->readBool();
          $this->was_java_generate_equals_and_hash_set = true;
          break;
        case 23:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 27:
          $this->java_string_check_utf8 = $d->readBool();
          $this->was_java_string_check_utf8_set = true;
          break;
        case 31:
          $this->cc_enable_arenas = $d->readBool();
          $this->was_cc_enable_arenas_set = true;
          break;
        case 36:
          $this->objc_class_prefix = $d->readString();
          $this->was_objc_class_prefix_set = true;
          break;
        case 37:
          $this->csharp_namespace = $d->readString();
          $this->was_csharp_namespace_set = true;
          break;
        case 39:
          $this->swift_prefix = $d->readString();
          $this->was_swift_prefix_set = true;
          break;
        case 40:
          $this->php_class_prefix = $d->readString();
          $this->was_php_class_prefix_set = true;
          break;
        case 41:
          $this->php_namespace = $d->readString();
          $this->was_php_namespace_set = true;
          break;
        case 42:
          $this->php_generic_services = $d->readBool();
          $this->was_php_generic_services_set = true;
          break;
        case 44:
          $this->php_metadata_namespace = $d->readString();
          $this->was_php_metadata_namespace_set = true;
          break;
        case 45:
          $this->ruby_package = $d->readString();
          $this->was_ruby_package_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_java_package_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->java_package);
    }
    if ($this->was_java_outer_classname_set) {
      $e->writeTag(8, 2);
      $e->writeString($this->java_outer_classname);
    }
    if ($this->was_optimize_for_set) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->optimize_for);
    }
    if ($this->was_java_multiple_files_set) {
      $e->writeTag(10, 0);
      $e->writeBool($this->java_multiple_files);
    }
    if ($this->was_go_package_set) {
      $e->writeTag(11, 2);
      $e->writeString($this->go_package);
    }
    if ($this->was_cc_generic_services_set) {
      $e->writeTag(16, 0);
      $e->writeBool($this->cc_generic_services);
    }
    if ($this->was_java_generic_services_set) {
      $e->writeTag(17, 0);
      $e->writeBool($this->java_generic_services);
    }
    if ($this->was_py_generic_services_set) {
      $e->writeTag(18, 0);
      $e->writeBool($this->py_generic_services);
    }
    if ($this->was_java_generate_equals_and_hash_set) {
      $e->writeTag(20, 0);
      $e->writeBool($this->java_generate_equals_and_hash);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(23, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_java_string_check_utf8_set) {
      $e->writeTag(27, 0);
      $e->writeBool($this->java_string_check_utf8);
    }
    if ($this->was_cc_enable_arenas_set) {
      $e->writeTag(31, 0);
      $e->writeBool($this->cc_enable_arenas);
    }
    if ($this->was_objc_class_prefix_set) {
      $e->writeTag(36, 2);
      $e->writeString($this->objc_class_prefix);
    }
    if ($this->was_csharp_namespace_set) {
      $e->writeTag(37, 2);
      $e->writeString($this->csharp_namespace);
    }
    if ($this->was_swift_prefix_set) {
      $e->writeTag(39, 2);
      $e->writeString($this->swift_prefix);
    }
    if ($this->was_php_class_prefix_set) {
      $e->writeTag(40, 2);
      $e->writeString($this->php_class_prefix);
    }
    if ($this->was_php_namespace_set) {
      $e->writeTag(41, 2);
      $e->writeString($this->php_namespace);
    }
    if ($this->was_php_generic_services_set) {
      $e->writeTag(42, 0);
      $e->writeBool($this->php_generic_services);
    }
    if ($this->was_php_metadata_namespace_set) {
      $e->writeTag(44, 2);
      $e->writeString($this->php_metadata_namespace);
    }
    if ($this->was_ruby_package_set) {
      $e->writeTag(45, 2);
      $e->writeString($this->ruby_package);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasJavaPackage()) {
      $e->writeString('java_package', 'javaPackage', $this->java_package, false);
    }
    if ($this->hasJavaOuterClassname()) {
      $e->writeString('java_outer_classname', 'javaOuterClassname', $this->java_outer_classname, false);
    }
    if ($this->hasOptimizeFor()) {
      $e->writeEnum('optimize_for', 'optimizeFor', \google\protobuf\FileOptions_OptimizeMode::ToStringDict(), $this->optimize_for, false);
    }
    if ($this->hasJavaMultipleFiles()) {
      $e->writeBool('java_multiple_files', 'javaMultipleFiles', $this->java_multiple_files, false);
    }
    if ($this->hasGoPackage()) {
      $e->writeString('go_package', 'goPackage', $this->go_package, false);
    }
    if ($this->hasCcGenericServices()) {
      $e->writeBool('cc_generic_services', 'ccGenericServices', $this->cc_generic_services, false);
    }
    if ($this->hasJavaGenericServices()) {
      $e->writeBool('java_generic_services', 'javaGenericServices', $this->java_generic_services, false);
    }
    if ($this->hasPyGenericServices()) {
      $e->writeBool('py_generic_services', 'pyGenericServices', $this->py_generic_services, false);
    }
    if ($this->hasJavaGenerateEqualsAndHash()) {
      $e->writeBool('java_generate_equals_and_hash', 'javaGenerateEqualsAndHash', $this->java_generate_equals_and_hash, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasJavaStringCheckUtf8()) {
      $e->writeBool('java_string_check_utf8', 'javaStringCheckUtf8', $this->java_string_check_utf8, false);
    }
    if ($this->hasCcEnableArenas()) {
      $e->writeBool('cc_enable_arenas', 'ccEnableArenas', $this->cc_enable_arenas, false);
    }
    if ($this->hasObjcClassPrefix()) {
      $e->writeString('objc_class_prefix', 'objcClassPrefix', $this->objc_class_prefix, false);
    }
    if ($this->hasCsharpNamespace()) {
      $e->writeString('csharp_namespace', 'csharpNamespace', $this->csharp_namespace, false);
    }
    if ($this->hasSwiftPrefix()) {
      $e->writeString('swift_prefix', 'swiftPrefix', $this->swift_prefix, false);
    }
    if ($this->hasPhpClassPrefix()) {
      $e->writeString('php_class_prefix', 'phpClassPrefix', $this->php_class_prefix, false);
    }
    if ($this->hasPhpNamespace()) {
      $e->writeString('php_namespace', 'phpNamespace', $this->php_namespace, false);
    }
    if ($this->hasPhpGenericServices()) {
      $e->writeBool('php_generic_services', 'phpGenericServices', $this->php_generic_services, false);
    }
    if ($this->hasPhpMetadataNamespace()) {
      $e->writeString('php_metadata_namespace', 'phpMetadataNamespace', $this->php_metadata_namespace, false);
    }
    if ($this->hasRubyPackage()) {
      $e->writeString('ruby_package', 'rubyPackage', $this->ruby_package, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'java_package': case 'javaPackage':
          $this->java_package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_java_package_set = true;
          break;
        case 'java_outer_classname': case 'javaOuterClassname':
          $this->java_outer_classname = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_java_outer_classname_set = true;
          break;
        case 'optimize_for': case 'optimizeFor':
          $this->optimize_for = \google\protobuf\FileOptions_OptimizeMode::FromMixed($v);
          $this->was_optimize_for_set = true;
          break;
        case 'java_multiple_files': case 'javaMultipleFiles':
          $this->java_multiple_files = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_multiple_files_set = true;
          break;
        case 'go_package': case 'goPackage':
          $this->go_package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_go_package_set = true;
          break;
        case 'cc_generic_services': case 'ccGenericServices':
          $this->cc_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_cc_generic_services_set = true;
          break;
        case 'java_generic_services': case 'javaGenericServices':
          $this->java_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_generic_services_set = true;
          break;
        case 'py_generic_services': case 'pyGenericServices':
          $this->py_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_py_generic_services_set = true;
          break;
        case 'java_generate_equals_and_hash': case 'javaGenerateEqualsAndHash':
          $this->java_generate_equals_and_hash = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_generate_equals_and_hash_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'java_string_check_utf8': case 'javaStringCheckUtf8':
          $this->java_string_check_utf8 = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_java_string_check_utf8_set = true;
          break;
        case 'cc_enable_arenas': case 'ccEnableArenas':
          $this->cc_enable_arenas = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_cc_enable_arenas_set = true;
          break;
        case 'objc_class_prefix': case 'objcClassPrefix':
          $this->objc_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_objc_class_prefix_set = true;
          break;
        case 'csharp_namespace': case 'csharpNamespace':
          $this->csharp_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_csharp_namespace_set = true;
          break;
        case 'swift_prefix': case 'swiftPrefix':
          $this->swift_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_swift_prefix_set = true;
          break;
        case 'php_class_prefix': case 'phpClassPrefix':
          $this->php_class_prefix = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_php_class_prefix_set = true;
          break;
        case 'php_namespace': case 'phpNamespace':
          $this->php_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_php_namespace_set = true;
          break;
        case 'php_generic_services': case 'phpGenericServices':
          $this->php_generic_services = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_php_generic_services_set = true;
          break;
        case 'php_metadata_namespace': case 'phpMetadataNamespace':
          $this->php_metadata_namespace = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_php_metadata_namespace_set = true;
          break;
        case 'ruby_package': case 'rubyPackage':
          $this->ruby_package = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_ruby_package_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FileOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasJavaPackage()) {
      $this->setJavaPackage($o->getJavaPackage());
    }
    if ($o->hasJavaOuterClassname()) {
      $this->setJavaOuterClassname($o->getJavaOuterClassname());
    }
    if ($o->hasOptimizeFor()) {
      $this->setOptimizeFor($o->getOptimizeFor());
    }
    if ($o->hasJavaMultipleFiles()) {
      $this->setJavaMultipleFiles($o->getJavaMultipleFiles());
    }
    if ($o->hasGoPackage()) {
      $this->setGoPackage($o->getGoPackage());
    }
    if ($o->hasCcGenericServices()) {
      $this->setCcGenericServices($o->getCcGenericServices());
    }
    if ($o->hasJavaGenericServices()) {
      $this->setJavaGenericServices($o->getJavaGenericServices());
    }
    if ($o->hasPyGenericServices()) {
      $this->setPyGenericServices($o->getPyGenericServices());
    }
    if ($o->hasJavaGenerateEqualsAndHash()) {
      $this->setJavaGenerateEqualsAndHash($o->getJavaGenerateEqualsAndHash());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasJavaStringCheckUtf8()) {
      $this->setJavaStringCheckUtf8($o->getJavaStringCheckUtf8());
    }
    if ($o->hasCcEnableArenas()) {
      $this->setCcEnableArenas($o->getCcEnableArenas());
    }
    if ($o->hasObjcClassPrefix()) {
      $this->setObjcClassPrefix($o->getObjcClassPrefix());
    }
    if ($o->hasCsharpNamespace()) {
      $this->setCsharpNamespace($o->getCsharpNamespace());
    }
    if ($o->hasSwiftPrefix()) {
      $this->setSwiftPrefix($o->getSwiftPrefix());
    }
    if ($o->hasPhpClassPrefix()) {
      $this->setPhpClassPrefix($o->getPhpClassPrefix());
    }
    if ($o->hasPhpNamespace()) {
      $this->setPhpNamespace($o->getPhpNamespace());
    }
    if ($o->hasPhpGenericServices()) {
      $this->setPhpGenericServices($o->getPhpGenericServices());
    }
    if ($o->hasPhpMetadataNamespace()) {
      $this->setPhpMetadataNamespace($o->getPhpMetadataNamespace());
    }
    if ($o->hasRubyPackage()) {
      $this->setRubyPackage($o->getRubyPackage());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class MessageOptions implements \Protobuf\Message {
  private bool $message_set_wire_format;
  private bool $was_message_set_wire_format_set;
  private bool $no_standard_descriptor_accessor;
  private bool $was_no_standard_descriptor_accessor_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  private bool $map_entry;
  private bool $was_map_entry_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'message_set_wire_format' => bool,
    ?'no_standard_descriptor_accessor' => bool,
    ?'deprecated' => bool,
    ?'map_entry' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'message_set_wire_format')) {
      $this->message_set_wire_format = $s['message_set_wire_format'];
      $this->was_message_set_wire_format_set = true;
    } else {
      $this->message_set_wire_format = false;
      $this->was_message_set_wire_format_set = false;
    }
    if (Shapes::keyExists($s, 'no_standard_descriptor_accessor')) {
      $this->no_standard_descriptor_accessor = $s['no_standard_descriptor_accessor'];
      $this->was_no_standard_descriptor_accessor_set = true;
    } else {
      $this->no_standard_descriptor_accessor = false;
      $this->was_no_standard_descriptor_accessor_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'map_entry')) {
      $this->map_entry = $s['map_entry'];
      $this->was_map_entry_set = true;
    } else {
      $this->map_entry = false;
      $this->was_map_entry_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getMessageSetWireFormat(): bool {
    return $this->message_set_wire_format;
  }

  public function setMessageSetWireFormat(bool $v): void {
    $this->message_set_wire_format = $v;
    $this->was_message_set_wire_format_set = true;
  }

  public function hasMessageSetWireFormat(): bool {
    return $this->was_message_set_wire_format_set;
  }

  public function getNoStandardDescriptorAccessor(): bool {
    return $this->no_standard_descriptor_accessor;
  }

  public function setNoStandardDescriptorAccessor(bool $v): void {
    $this->no_standard_descriptor_accessor = $v;
    $this->was_no_standard_descriptor_accessor_set = true;
  }

  public function hasNoStandardDescriptorAccessor(): bool {
    return $this->was_no_standard_descriptor_accessor_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getMapEntry(): bool {
    return $this->map_entry;
  }

  public function setMapEntry(bool $v): void {
    $this->map_entry = $v;
    $this->was_map_entry_set = true;
  }

  public function hasMapEntry(): bool {
    return $this->was_map_entry_set;
  }

  public function MessageName(): string {
    return "google.protobuf.MessageOptions";
  }

  public static function ParseFrom(string $input): ?MessageOptions {
    $msg = new MessageOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->message_set_wire_format = $d->readBool();
          $this->was_message_set_wire_format_set = true;
          break;
        case 2:
          $this->no_standard_descriptor_accessor = $d->readBool();
          $this->was_no_standard_descriptor_accessor_set = true;
          break;
        case 3:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 7:
          $this->map_entry = $d->readBool();
          $this->was_map_entry_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_message_set_wire_format_set) {
      $e->writeTag(1, 0);
      $e->writeBool($this->message_set_wire_format);
    }
    if ($this->was_no_standard_descriptor_accessor_set) {
      $e->writeTag(2, 0);
      $e->writeBool($this->no_standard_descriptor_accessor);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_map_entry_set) {
      $e->writeTag(7, 0);
      $e->writeBool($this->map_entry);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasMessageSetWireFormat()) {
      $e->writeBool('message_set_wire_format', 'messageSetWireFormat', $this->message_set_wire_format, false);
    }
    if ($this->hasNoStandardDescriptorAccessor()) {
      $e->writeBool('no_standard_descriptor_accessor', 'noStandardDescriptorAccessor', $this->no_standard_descriptor_accessor, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasMapEntry()) {
      $e->writeBool('map_entry', 'mapEntry', $this->map_entry, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'message_set_wire_format': case 'messageSetWireFormat':
          $this->message_set_wire_format = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_message_set_wire_format_set = true;
          break;
        case 'no_standard_descriptor_accessor': case 'noStandardDescriptorAccessor':
          $this->no_standard_descriptor_accessor = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_no_standard_descriptor_accessor_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'map_entry': case 'mapEntry':
          $this->map_entry = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_map_entry_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MessageOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasMessageSetWireFormat()) {
      $this->setMessageSetWireFormat($o->getMessageSetWireFormat());
    }
    if ($o->hasNoStandardDescriptorAccessor()) {
      $this->setNoStandardDescriptorAccessor($o->getNoStandardDescriptorAccessor());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasMapEntry()) {
      $this->setMapEntry($o->getMapEntry());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype FieldOptions_CType_enum_t as int = int;
abstract class FieldOptions_CType {
  const FieldOptions_CType_enum_t STRING = 0;
  const FieldOptions_CType_enum_t CORD = 1;
  const FieldOptions_CType_enum_t STRING_PIECE = 2;
  private static dict<int, string> $itos = dict[
    0 => 'STRING',
    1 => 'CORD',
    2 => 'STRING_PIECE',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'STRING' => 0,
    'CORD' => 1,
    'STRING_PIECE' => 2,
  ];
  public static function FromMixed(mixed $m): FieldOptions_CType_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_CType_enum_t {
    return $i;
  }
}

newtype FieldOptions_JSType_enum_t as int = int;
abstract class FieldOptions_JSType {
  const FieldOptions_JSType_enum_t JS_NORMAL = 0;
  const FieldOptions_JSType_enum_t JS_STRING = 1;
  const FieldOptions_JSType_enum_t JS_NUMBER = 2;
  private static dict<int, string> $itos = dict[
    0 => 'JS_NORMAL',
    1 => 'JS_STRING',
    2 => 'JS_NUMBER',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'JS_NORMAL' => 0,
    'JS_STRING' => 1,
    'JS_NUMBER' => 2,
  ];
  public static function FromMixed(mixed $m): FieldOptions_JSType_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): FieldOptions_JSType_enum_t {
    return $i;
  }
}

class FieldOptions implements \Protobuf\Message {
  private \google\protobuf\FieldOptions_CType_enum_t $ctype;
  private bool $was_ctype_set;
  private bool $packed;
  private bool $was_packed_set;
  private \google\protobuf\FieldOptions_JSType_enum_t $jstype;
  private bool $was_jstype_set;
  private bool $lazy;
  private bool $was_lazy_set;
  private bool $unverified_lazy;
  private bool $was_unverified_lazy_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  private bool $weak;
  private bool $was_weak_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'ctype' => \google\protobuf\FieldOptions_CType_enum_t,
    ?'packed' => bool,
    ?'jstype' => \google\protobuf\FieldOptions_JSType_enum_t,
    ?'lazy' => bool,
    ?'unverified_lazy' => bool,
    ?'deprecated' => bool,
    ?'weak' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'ctype')) {
      $this->ctype = $s['ctype'];
      $this->was_ctype_set = true;
    } else {
      $this->ctype = \google\protobuf\FieldOptions_CType::STRING;
      $this->was_ctype_set = false;
    }
    if (Shapes::keyExists($s, 'packed')) {
      $this->packed = $s['packed'];
      $this->was_packed_set = true;
    } else {
      $this->packed = false;
      $this->was_packed_set = false;
    }
    if (Shapes::keyExists($s, 'jstype')) {
      $this->jstype = $s['jstype'];
      $this->was_jstype_set = true;
    } else {
      $this->jstype = \google\protobuf\FieldOptions_JSType::JS_NORMAL;
      $this->was_jstype_set = false;
    }
    if (Shapes::keyExists($s, 'lazy')) {
      $this->lazy = $s['lazy'];
      $this->was_lazy_set = true;
    } else {
      $this->lazy = false;
      $this->was_lazy_set = false;
    }
    if (Shapes::keyExists($s, 'unverified_lazy')) {
      $this->unverified_lazy = $s['unverified_lazy'];
      $this->was_unverified_lazy_set = true;
    } else {
      $this->unverified_lazy = false;
      $this->was_unverified_lazy_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'weak')) {
      $this->weak = $s['weak'];
      $this->was_weak_set = true;
    } else {
      $this->weak = false;
      $this->was_weak_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getCtype(): \google\protobuf\FieldOptions_CType_enum_t {
    return $this->ctype;
  }

  public function setCtype(\google\protobuf\FieldOptions_CType_enum_t $v): void {
    $this->ctype = $v;
    $this->was_ctype_set = true;
  }

  public function hasCtype(): bool {
    return $this->was_ctype_set;
  }

  public function getPacked(): bool {
    return $this->packed;
  }

  public function setPacked(bool $v): void {
    $this->packed = $v;
    $this->was_packed_set = true;
  }

  public function hasPacked(): bool {
    return $this->was_packed_set;
  }

  public function getJstype(): \google\protobuf\FieldOptions_JSType_enum_t {
    return $this->jstype;
  }

  public function setJstype(\google\protobuf\FieldOptions_JSType_enum_t $v): void {
    $this->jstype = $v;
    $this->was_jstype_set = true;
  }

  public function hasJstype(): bool {
    return $this->was_jstype_set;
  }

  public function getLazy(): bool {
    return $this->lazy;
  }

  public function setLazy(bool $v): void {
    $this->lazy = $v;
    $this->was_lazy_set = true;
  }

  public function hasLazy(): bool {
    return $this->was_lazy_set;
  }

  public function getUnverifiedLazy(): bool {
    return $this->unverified_lazy;
  }

  public function setUnverifiedLazy(bool $v): void {
    $this->unverified_lazy = $v;
    $this->was_unverified_lazy_set = true;
  }

  public function hasUnverifiedLazy(): bool {
    return $this->was_unverified_lazy_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getWeak(): bool {
    return $this->weak;
  }

  public function setWeak(bool $v): void {
    $this->weak = $v;
    $this->was_weak_set = true;
  }

  public function hasWeak(): bool {
    return $this->was_weak_set;
  }

  public function MessageName(): string {
    return "google.protobuf.FieldOptions";
  }

  public static function ParseFrom(string $input): ?FieldOptions {
    $msg = new FieldOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->ctype = \google\protobuf\FieldOptions_CType::FromInt($d->readVarint());
          $this->was_ctype_set = true;
          break;
        case 2:
          $this->packed = $d->readBool();
          $this->was_packed_set = true;
          break;
        case 3:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 5:
          $this->lazy = $d->readBool();
          $this->was_lazy_set = true;
          break;
        case 6:
          $this->jstype = \google\protobuf\FieldOptions_JSType::FromInt($d->readVarint());
          $this->was_jstype_set = true;
          break;
        case 10:
          $this->weak = $d->readBool();
          $this->was_weak_set = true;
          break;
        case 15:
          $this->unverified_lazy = $d->readBool();
          $this->was_unverified_lazy_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_ctype_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->ctype);
    }
    if ($this->was_packed_set) {
      $e->writeTag(2, 0);
      $e->writeBool($this->packed);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_lazy_set) {
      $e->writeTag(5, 0);
      $e->writeBool($this->lazy);
    }
    if ($this->was_jstype_set) {
      $e->writeTag(6, 0);
      $e->writeVarint($this->jstype);
    }
    if ($this->was_weak_set) {
      $e->writeTag(10, 0);
      $e->writeBool($this->weak);
    }
    if ($this->was_unverified_lazy_set) {
      $e->writeTag(15, 0);
      $e->writeBool($this->unverified_lazy);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasCtype()) {
      $e->writeEnum('ctype', 'ctype', \google\protobuf\FieldOptions_CType::ToStringDict(), $this->ctype, false);
    }
    if ($this->hasPacked()) {
      $e->writeBool('packed', 'packed', $this->packed, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasLazy()) {
      $e->writeBool('lazy', 'lazy', $this->lazy, false);
    }
    if ($this->hasJstype()) {
      $e->writeEnum('jstype', 'jstype', \google\protobuf\FieldOptions_JSType::ToStringDict(), $this->jstype, false);
    }
    if ($this->hasWeak()) {
      $e->writeBool('weak', 'weak', $this->weak, false);
    }
    if ($this->hasUnverifiedLazy()) {
      $e->writeBool('unverified_lazy', 'unverifiedLazy', $this->unverified_lazy, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'ctype':
          $this->ctype = \google\protobuf\FieldOptions_CType::FromMixed($v);
          $this->was_ctype_set = true;
          break;
        case 'packed':
          $this->packed = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_packed_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'lazy':
          $this->lazy = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_lazy_set = true;
          break;
        case 'jstype':
          $this->jstype = \google\protobuf\FieldOptions_JSType::FromMixed($v);
          $this->was_jstype_set = true;
          break;
        case 'weak':
          $this->weak = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_weak_set = true;
          break;
        case 'unverified_lazy': case 'unverifiedLazy':
          $this->unverified_lazy = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_unverified_lazy_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is FieldOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasCtype()) {
      $this->setCtype($o->getCtype());
    }
    if ($o->hasPacked()) {
      $this->setPacked($o->getPacked());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasLazy()) {
      $this->setLazy($o->getLazy());
    }
    if ($o->hasJstype()) {
      $this->setJstype($o->getJstype());
    }
    if ($o->hasWeak()) {
      $this->setWeak($o->getWeak());
    }
    if ($o->hasUnverifiedLazy()) {
      $this->setUnverifiedLazy($o->getUnverifiedLazy());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class OneofOptions implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.OneofOptions";
  }

  public static function ParseFrom(string $input): ?OneofOptions {
    $msg = new OneofOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is OneofOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumOptions implements \Protobuf\Message {
  private bool $allow_alias;
  private bool $was_allow_alias_set;
  private bool $deprecated;
  private bool $was_deprecated_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'allow_alias' => bool,
    ?'deprecated' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'allow_alias')) {
      $this->allow_alias = $s['allow_alias'];
      $this->was_allow_alias_set = true;
    } else {
      $this->allow_alias = false;
      $this->was_allow_alias_set = false;
    }
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getAllowAlias(): bool {
    return $this->allow_alias;
  }

  public function setAllowAlias(bool $v): void {
    $this->allow_alias = $v;
    $this->was_allow_alias_set = true;
  }

  public function hasAllowAlias(): bool {
    return $this->was_allow_alias_set;
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumOptions";
  }

  public static function ParseFrom(string $input): ?EnumOptions {
    $msg = new EnumOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $this->allow_alias = $d->readBool();
          $this->was_allow_alias_set = true;
          break;
        case 3:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_allow_alias_set) {
      $e->writeTag(2, 0);
      $e->writeBool($this->allow_alias);
    }
    if ($this->was_deprecated_set) {
      $e->writeTag(3, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasAllowAlias()) {
      $e->writeBool('allow_alias', 'allowAlias', $this->allow_alias, false);
    }
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'allow_alias': case 'allowAlias':
          $this->allow_alias = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_allow_alias_set = true;
          break;
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasAllowAlias()) {
      $this->setAllowAlias($o->getAllowAlias());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumValueOptions implements \Protobuf\Message {
  private bool $deprecated;
  private bool $was_deprecated_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'deprecated' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function MessageName(): string {
    return "google.protobuf.EnumValueOptions";
  }

  public static function ParseFrom(string $input): ?EnumValueOptions {
    $msg = new EnumValueOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_deprecated_set) {
      $e->writeTag(1, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumValueOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ServiceOptions implements \Protobuf\Message {
  private bool $deprecated;
  private bool $was_deprecated_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'deprecated' => bool,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function MessageName(): string {
    return "google.protobuf.ServiceOptions";
  }

  public static function ParseFrom(string $input): ?ServiceOptions {
    $msg = new ServiceOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_deprecated_set) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ServiceOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype MethodOptions_IdempotencyLevel_enum_t as int = int;
abstract class MethodOptions_IdempotencyLevel {
  const MethodOptions_IdempotencyLevel_enum_t IDEMPOTENCY_UNKNOWN = 0;
  const MethodOptions_IdempotencyLevel_enum_t NO_SIDE_EFFECTS = 1;
  const MethodOptions_IdempotencyLevel_enum_t IDEMPOTENT = 2;
  private static dict<int, string> $itos = dict[
    0 => 'IDEMPOTENCY_UNKNOWN',
    1 => 'NO_SIDE_EFFECTS',
    2 => 'IDEMPOTENT',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'IDEMPOTENCY_UNKNOWN' => 0,
    'NO_SIDE_EFFECTS' => 1,
    'IDEMPOTENT' => 2,
  ];
  public static function FromMixed(mixed $m): MethodOptions_IdempotencyLevel_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): MethodOptions_IdempotencyLevel_enum_t {
    return $i;
  }
}

class MethodOptions implements \Protobuf\Message {
  private bool $deprecated;
  private bool $was_deprecated_set;
  private \google\protobuf\MethodOptions_IdempotencyLevel_enum_t $idempotency_level;
  private bool $was_idempotency_level_set;
  public vec<\google\protobuf\UninterpretedOption> $uninterpreted_option;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'deprecated' => bool,
    ?'idempotency_level' => \google\protobuf\MethodOptions_IdempotencyLevel_enum_t,
    ?'uninterpreted_option' => vec<\google\protobuf\UninterpretedOption>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'deprecated')) {
      $this->deprecated = $s['deprecated'];
      $this->was_deprecated_set = true;
    } else {
      $this->deprecated = false;
      $this->was_deprecated_set = false;
    }
    if (Shapes::keyExists($s, 'idempotency_level')) {
      $this->idempotency_level = $s['idempotency_level'];
      $this->was_idempotency_level_set = true;
    } else {
      $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::IDEMPOTENCY_UNKNOWN;
      $this->was_idempotency_level_set = false;
    }
    $this->uninterpreted_option = $s['uninterpreted_option'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getDeprecated(): bool {
    return $this->deprecated;
  }

  public function setDeprecated(bool $v): void {
    $this->deprecated = $v;
    $this->was_deprecated_set = true;
  }

  public function hasDeprecated(): bool {
    return $this->was_deprecated_set;
  }

  public function getIdempotencyLevel(): \google\protobuf\MethodOptions_IdempotencyLevel_enum_t {
    return $this->idempotency_level;
  }

  public function setIdempotencyLevel(\google\protobuf\MethodOptions_IdempotencyLevel_enum_t $v): void {
    $this->idempotency_level = $v;
    $this->was_idempotency_level_set = true;
  }

  public function hasIdempotencyLevel(): bool {
    return $this->was_idempotency_level_set;
  }

  public function MessageName(): string {
    return "google.protobuf.MethodOptions";
  }

  public static function ParseFrom(string $input): ?MethodOptions {
    $msg = new MethodOptions();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 33:
          $this->deprecated = $d->readBool();
          $this->was_deprecated_set = true;
          break;
        case 34:
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::FromInt($d->readVarint());
          $this->was_idempotency_level_set = true;
          break;
        case 999:
          $obj = new \google\protobuf\UninterpretedOption();
          $obj->MergeFrom($d->readDecoder());
          $this->uninterpreted_option []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_deprecated_set) {
      $e->writeTag(33, 0);
      $e->writeBool($this->deprecated);
    }
    if ($this->was_idempotency_level_set) {
      $e->writeTag(34, 0);
      $e->writeVarint($this->idempotency_level);
    }
    foreach ($this->uninterpreted_option as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 999);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasDeprecated()) {
      $e->writeBool('deprecated', 'deprecated', $this->deprecated, false);
    }
    if ($this->hasIdempotencyLevel()) {
      $e->writeEnum('idempotency_level', 'idempotencyLevel', \google\protobuf\MethodOptions_IdempotencyLevel::ToStringDict(), $this->idempotency_level, false);
    }
    $e->writeMessageList('uninterpreted_option', 'uninterpretedOption', $this->uninterpreted_option);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'deprecated':
          $this->deprecated = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_deprecated_set = true;
          break;
        case 'idempotency_level': case 'idempotencyLevel':
          $this->idempotency_level = \google\protobuf\MethodOptions_IdempotencyLevel::FromMixed($v);
          $this->was_idempotency_level_set = true;
          break;
        case 'uninterpreted_option': case 'uninterpretedOption':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption();
            $obj->MergeJsonFrom($vv);
            $this->uninterpreted_option []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is MethodOptions)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasDeprecated()) {
      $this->setDeprecated($o->getDeprecated());
    }
    if ($o->hasIdempotencyLevel()) {
      $this->setIdempotencyLevel($o->getIdempotencyLevel());
    }
    foreach ($o->uninterpreted_option as $v) {
      $nv = new \google\protobuf\UninterpretedOption();
      $nv->CopyFrom($v);
      $this->uninterpreted_option []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UninterpretedOption_NamePart implements \Protobuf\Message {
  public string $name_part;
  public bool $is_extension;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name_part' => string,
    ?'is_extension' => bool,
  ) $s = shape()) {
    $this->name_part = $s['name_part'] ?? '';
    $this->is_extension = $s['is_extension'] ?? false;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.UninterpretedOption.NamePart";
  }

  public static function ParseFrom(string $input): ?UninterpretedOption_NamePart {
    $msg = new UninterpretedOption_NamePart();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name_part = $d->readString();
          break;
        case 2:
          $this->is_extension = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name_part !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name_part);
    }
    if ($this->is_extension !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->is_extension);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name_part', 'namePart', $this->name_part, false);
    $e->writeBool('is_extension', 'isExtension', $this->is_extension, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name_part': case 'namePart':
          $this->name_part = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'is_extension': case 'isExtension':
          $this->is_extension = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UninterpretedOption_NamePart)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name_part = $o->name_part;
    $this->is_extension = $o->is_extension;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UninterpretedOption implements \Protobuf\Message {
  public vec<\google\protobuf\UninterpretedOption_NamePart> $name;
  private string $identifier_value;
  private bool $was_identifier_value_set;
  private int $positive_int_value;
  private bool $was_positive_int_value_set;
  private int $negative_int_value;
  private bool $was_negative_int_value_set;
  private float $double_value;
  private bool $was_double_value_set;
  private string $string_value;
  private bool $was_string_value_set;
  private string $aggregate_value;
  private bool $was_aggregate_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => vec<\google\protobuf\UninterpretedOption_NamePart>,
    ?'identifier_value' => string,
    ?'positive_int_value' => int,
    ?'negative_int_value' => int,
    ?'double_value' => float,
    ?'string_value' => string,
    ?'aggregate_value' => string,
  ) $s = shape()) {
    $this->name = $s['name'] ?? vec[];
    if (Shapes::keyExists($s, 'identifier_value')) {
      $this->identifier_value = $s['identifier_value'];
      $this->was_identifier_value_set = true;
    } else {
      $this->identifier_value = '';
      $this->was_identifier_value_set = false;
    }
    if (Shapes::keyExists($s, 'positive_int_value')) {
      $this->positive_int_value = $s['positive_int_value'];
      $this->was_positive_int_value_set = true;
    } else {
      $this->positive_int_value = 0;
      $this->was_positive_int_value_set = false;
    }
    if (Shapes::keyExists($s, 'negative_int_value')) {
      $this->negative_int_value = $s['negative_int_value'];
      $this->was_negative_int_value_set = true;
    } else {
      $this->negative_int_value = 0;
      $this->was_negative_int_value_set = false;
    }
    if (Shapes::keyExists($s, 'double_value')) {
      $this->double_value = $s['double_value'];
      $this->was_double_value_set = true;
    } else {
      $this->double_value = 0.0;
      $this->was_double_value_set = false;
    }
    if (Shapes::keyExists($s, 'string_value')) {
      $this->string_value = $s['string_value'];
      $this->was_string_value_set = true;
    } else {
      $this->string_value = '';
      $this->was_string_value_set = false;
    }
    if (Shapes::keyExists($s, 'aggregate_value')) {
      $this->aggregate_value = $s['aggregate_value'];
      $this->was_aggregate_value_set = true;
    } else {
      $this->aggregate_value = '';
      $this->was_aggregate_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getIdentifierValue(): string {
    return $this->identifier_value;
  }

  public function setIdentifierValue(string $v): void {
    $this->identifier_value = $v;
    $this->was_identifier_value_set = true;
  }

  public function hasIdentifierValue(): bool {
    return $this->was_identifier_value_set;
  }

  public function getPositiveIntValue(): int {
    return $this->positive_int_value;
  }

  public function setPositiveIntValue(int $v): void {
    $this->positive_int_value = $v;
    $this->was_positive_int_value_set = true;
  }

  public function hasPositiveIntValue(): bool {
    return $this->was_positive_int_value_set;
  }

  public function getNegativeIntValue(): int {
    return $this->negative_int_value;
  }

  public function setNegativeIntValue(int $v): void {
    $this->negative_int_value = $v;
    $this->was_negative_int_value_set = true;
  }

  public function hasNegativeIntValue(): bool {
    return $this->was_negative_int_value_set;
  }

  public function getDoubleValue(): float {
    return $this->double_value;
  }

  public function setDoubleValue(float $v): void {
    $this->double_value = $v;
    $this->was_double_value_set = true;
  }

  public function hasDoubleValue(): bool {
    return $this->was_double_value_set;
  }

  public function getStringValue(): string {
    return $this->string_value;
  }

  public function setStringValue(string $v): void {
    $this->string_value = $v;
    $this->was_string_value_set = true;
  }

  public function hasStringValue(): bool {
    return $this->was_string_value_set;
  }

  public function getAggregateValue(): string {
    return $this->aggregate_value;
  }

  public function setAggregateValue(string $v): void {
    $this->aggregate_value = $v;
    $this->was_aggregate_value_set = true;
  }

  public function hasAggregateValue(): bool {
    return $this->was_aggregate_value_set;
  }

  public function MessageName(): string {
    return "google.protobuf.UninterpretedOption";
  }

  public static function ParseFrom(string $input): ?UninterpretedOption {
    $msg = new UninterpretedOption();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 2:
          $obj = new \google\protobuf\UninterpretedOption_NamePart();
          $obj->MergeFrom($d->readDecoder());
          $this->name []= $obj;
          break;
        case 3:
          $this->identifier_value = $d->readString();
          $this->was_identifier_value_set = true;
          break;
        case 4:
          $this->positive_int_value = $d->readVarint();
          $this->was_positive_int_value_set = true;
          break;
        case 5:
          $this->negative_int_value = $d->readVarint();
          $this->was_negative_int_value_set = true;
          break;
        case 6:
          $this->double_value = $d->readDouble();
          $this->was_double_value_set = true;
          break;
        case 7:
          $this->string_value = $d->readString();
          $this->was_string_value_set = true;
          break;
        case 8:
          $this->aggregate_value = $d->readString();
          $this->was_aggregate_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->name as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    if ($this->was_identifier_value_set) {
      $e->writeTag(3, 2);
      $e->writeString($this->identifier_value);
    }
    if ($this->was_positive_int_value_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->positive_int_value);
    }
    if ($this->was_negative_int_value_set) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->negative_int_value);
    }
    if ($this->was_double_value_set) {
      $e->writeTag(6, 1);
      $e->writeDouble($this->double_value);
    }
    if ($this->was_string_value_set) {
      $e->writeTag(7, 2);
      $e->writeString($this->string_value);
    }
    if ($this->was_aggregate_value_set) {
      $e->writeTag(8, 2);
      $e->writeString($this->aggregate_value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('name', 'name', $this->name);
    if ($this->hasIdentifierValue()) {
      $e->writeString('identifier_value', 'identifierValue', $this->identifier_value, false);
    }
    if ($this->hasPositiveIntValue()) {
      $e->writeInt64Unsigned('positive_int_value', 'positiveIntValue', $this->positive_int_value, false);
    }
    if ($this->hasNegativeIntValue()) {
      $e->writeInt64Signed('negative_int_value', 'negativeIntValue', $this->negative_int_value, false);
    }
    if ($this->hasDoubleValue()) {
      $e->writeFloat('double_value', 'doubleValue', $this->double_value, false);
    }
    if ($this->hasStringValue()) {
      $e->writeBytes('string_value', 'stringValue', $this->string_value, false);
    }
    if ($this->hasAggregateValue()) {
      $e->writeString('aggregate_value', 'aggregateValue', $this->aggregate_value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\UninterpretedOption_NamePart();
            $obj->MergeJsonFrom($vv);
            $this->name []= $obj;
          }
          break;
        case 'identifier_value': case 'identifierValue':
          $this->identifier_value = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_identifier_value_set = true;
          break;
        case 'positive_int_value': case 'positiveIntValue':
          $this->positive_int_value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          $this->was_positive_int_value_set = true;
          break;
        case 'negative_int_value': case 'negativeIntValue':
          $this->negative_int_value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_negative_int_value_set = true;
          break;
        case 'double_value': case 'doubleValue':
          $this->double_value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          $this->was_double_value_set = true;
          break;
        case 'string_value': case 'stringValue':
          $this->string_value = \Protobuf\Internal\JsonDecoder::readBytes($v);
          $this->was_string_value_set = true;
          break;
        case 'aggregate_value': case 'aggregateValue':
          $this->aggregate_value = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_aggregate_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UninterpretedOption)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->name as $v) {
      $nv = new \google\protobuf\UninterpretedOption_NamePart();
      $nv->CopyFrom($v);
      $this->name []= $nv;
    }
    if ($o->hasIdentifierValue()) {
      $this->setIdentifierValue($o->getIdentifierValue());
    }
    if ($o->hasPositiveIntValue()) {
      $this->setPositiveIntValue($o->getPositiveIntValue());
    }
    if ($o->hasNegativeIntValue()) {
      $this->setNegativeIntValue($o->getNegativeIntValue());
    }
    if ($o->hasDoubleValue()) {
      $this->setDoubleValue($o->getDoubleValue());
    }
    if ($o->hasStringValue()) {
      $this->setStringValue($o->getStringValue());
    }
    if ($o->hasAggregateValue()) {
      $this->setAggregateValue($o->getAggregateValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class SourceCodeInfo_Location implements \Protobuf\Message {
  public vec<int> $path;
  public vec<int> $span;
  private string $leading_comments;
  private bool $was_leading_comments_set;
  private string $trailing_comments;
  private bool $was_trailing_comments_set;
  public vec<string> $leading_detached_comments;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'path' => vec<int>,
    ?'span' => vec<int>,
    ?'leading_comments' => string,
    ?'trailing_comments' => string,
    ?'leading_detached_comments' => vec<string>,
  ) $s = shape()) {
    $this->path = $s['path'] ?? vec[];
    $this->span = $s['span'] ?? vec[];
    if (Shapes::keyExists($s, 'leading_comments')) {
      $this->leading_comments = $s['leading_comments'];
      $this->was_leading_comments_set = true;
    } else {
      $this->leading_comments = '';
      $this->was_leading_comments_set = false;
    }
    if (Shapes::keyExists($s, 'trailing_comments')) {
      $this->trailing_comments = $s['trailing_comments'];
      $this->was_trailing_comments_set = true;
    } else {
      $this->trailing_comments = '';
      $this->was_trailing_comments_set = false;
    }
    $this->leading_detached_comments = $s['leading_detached_comments'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getLeadingComments(): string {
    return $this->leading_comments;
  }

  public function setLeadingComments(string $v): void {
    $this->leading_comments = $v;
    $this->was_leading_comments_set = true;
  }

  public function hasLeadingComments(): bool {
    return $this->was_leading_comments_set;
  }

  public function getTrailingComments(): string {
    return $this->trailing_comments;
  }

  public function setTrailingComments(string $v): void {
    $this->trailing_comments = $v;
    $this->was_trailing_comments_set = true;
  }

  public function hasTrailingComments(): bool {
    return $this->was_trailing_comments_set;
  }

  public function MessageName(): string {
    return "google.protobuf.SourceCodeInfo.Location";
  }

  public static function ParseFrom(string $input): ?SourceCodeInfo_Location {
    $msg = new SourceCodeInfo_Location();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->span []= $packed->readVarint32Signed();
            }
          } else {
            $this->span []= $d->readVarint32Signed();
          }
          break;
        case 3:
          $this->leading_comments = $d->readString();
          $this->was_leading_comments_set = true;
          break;
        case 4:
          $this->trailing_comments = $d->readString();
          $this->was_trailing_comments_set = true;
          break;
        case 6:
          $this->leading_detached_comments []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if (\count($this->path) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->path as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 1);
    }
    if (\count($this->span) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->span as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 2);
    }
    if ($this->was_leading_comments_set) {
      $e->writeTag(3, 2);
      $e->writeString($this->leading_comments);
    }
    if ($this->was_trailing_comments_set) {
      $e->writeTag(4, 2);
      $e->writeString($this->trailing_comments);
    }
    foreach ($this->leading_detached_comments as $elem) {
      $e->writeTag(6, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    $e->writePrimitiveList('span', 'span', $this->span);
    if ($this->hasLeadingComments()) {
      $e->writeString('leading_comments', 'leadingComments', $this->leading_comments, false);
    }
    if ($this->hasTrailingComments()) {
      $e->writeString('trailing_comments', 'trailingComments', $this->trailing_comments, false);
    }
    $e->writePrimitiveList('leading_detached_comments', 'leadingDetachedComments', $this->leading_detached_comments);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'span':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->span []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'leading_comments': case 'leadingComments':
          $this->leading_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_leading_comments_set = true;
          break;
        case 'trailing_comments': case 'trailingComments':
          $this->trailing_comments = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_trailing_comments_set = true;
          break;
        case 'leading_detached_comments': case 'leadingDetachedComments':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->leading_detached_comments []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is SourceCodeInfo_Location)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->path = $o->path;
    $this->span = $o->span;
    if ($o->hasLeadingComments()) {
      $this->setLeadingComments($o->getLeadingComments());
    }
    if ($o->hasTrailingComments()) {
      $this->setTrailingComments($o->getTrailingComments());
    }
    $this->leading_detached_comments = $o->leading_detached_comments;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class SourceCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\SourceCodeInfo_Location> $location;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'location' => vec<\google\protobuf\SourceCodeInfo_Location>,
  ) $s = shape()) {
    $this->location = $s['location'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.SourceCodeInfo";
  }

  public static function ParseFrom(string $input): ?SourceCodeInfo {
    $msg = new SourceCodeInfo();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\SourceCodeInfo_Location();
          $obj->MergeFrom($d->readDecoder());
          $this->location []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->location as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('location', 'location', $this->location);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'location':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\SourceCodeInfo_Location();
            $obj->MergeJsonFrom($vv);
            $this->location []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is SourceCodeInfo)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->location as $v) {
      $nv = new \google\protobuf\SourceCodeInfo_Location();
      $nv->CopyFrom($v);
      $this->location []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class GeneratedCodeInfo_Annotation implements \Protobuf\Message {
  public vec<int> $path;
  private string $source_file;
  private bool $was_source_file_set;
  private int $begin;
  private bool $was_begin_set;
  private int $end;
  private bool $was_end_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'path' => vec<int>,
    ?'source_file' => string,
    ?'begin' => int,
    ?'end' => int,
  ) $s = shape()) {
    $this->path = $s['path'] ?? vec[];
    if (Shapes::keyExists($s, 'source_file')) {
      $this->source_file = $s['source_file'];
      $this->was_source_file_set = true;
    } else {
      $this->source_file = '';
      $this->was_source_file_set = false;
    }
    if (Shapes::keyExists($s, 'begin')) {
      $this->begin = $s['begin'];
      $this->was_begin_set = true;
    } else {
      $this->begin = 0;
      $this->was_begin_set = false;
    }
    if (Shapes::keyExists($s, 'end')) {
      $this->end = $s['end'];
      $this->was_end_set = true;
    } else {
      $this->end = 0;
      $this->was_end_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getSourceFile(): string {
    return $this->source_file;
  }

  public function setSourceFile(string $v): void {
    $this->source_file = $v;
    $this->was_source_file_set = true;
  }

  public function hasSourceFile(): bool {
    return $this->was_source_file_set;
  }

  public function getBegin(): int {
    return $this->begin;
  }

  public function setBegin(int $v): void {
    $this->begin = $v;
    $this->was_begin_set = true;
  }

  public function hasBegin(): bool {
    return $this->was_begin_set;
  }

  public function getEnd(): int {
    return $this->end;
  }

  public function setEnd(int $v): void {
    $this->end = $v;
    $this->was_end_set = true;
  }

  public function hasEnd(): bool {
    return $this->was_end_set;
  }

  public function MessageName(): string {
    return "google.protobuf.GeneratedCodeInfo.Annotation";
  }

  public static function ParseFrom(string $input): ?GeneratedCodeInfo_Annotation {
    $msg = new GeneratedCodeInfo_Annotation();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->path []= $packed->readVarint32Signed();
            }
          } else {
            $this->path []= $d->readVarint32Signed();
          }
          break;
        case 2:
          $this->source_file = $d->readString();
          $this->was_source_file_set = true;
          break;
        case 3:
          $this->begin = $d->readVarint32Signed();
          $this->was_begin_set = true;
          break;
        case 4:
          $this->end = $d->readVarint32Signed();
          $this->was_end_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if (\count($this->path) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->path as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 1);
    }
    if ($this->was_source_file_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->source_file);
    }
    if ($this->was_begin_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->begin);
    }
    if ($this->was_end_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->end);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writePrimitiveList('path', 'path', $this->path);
    if ($this->hasSourceFile()) {
      $e->writeString('source_file', 'sourceFile', $this->source_file, false);
    }
    if ($this->hasBegin()) {
      $e->writeInt32('begin', 'begin', $this->begin, false);
    }
    if ($this->hasEnd()) {
      $e->writeInt32('end', 'end', $this->end, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'path':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->path []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'source_file': case 'sourceFile':
          $this->source_file = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_source_file_set = true;
          break;
        case 'begin':
          $this->begin = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_begin_set = true;
          break;
        case 'end':
          $this->end = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_end_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is GeneratedCodeInfo_Annotation)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->path = $o->path;
    if ($o->hasSourceFile()) {
      $this->setSourceFile($o->getSourceFile());
    }
    if ($o->hasBegin()) {
      $this->setBegin($o->getBegin());
    }
    if ($o->hasEnd()) {
      $this->setEnd($o->getEnd());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class GeneratedCodeInfo implements \Protobuf\Message {
  public vec<\google\protobuf\GeneratedCodeInfo_Annotation> $annotation;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'annotation' => vec<\google\protobuf\GeneratedCodeInfo_Annotation>,
  ) $s = shape()) {
    $this->annotation = $s['annotation'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.GeneratedCodeInfo";
  }

  public static function ParseFrom(string $input): ?GeneratedCodeInfo {
    $msg = new GeneratedCodeInfo();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
          $obj->MergeFrom($d->readDecoder());
          $this->annotation []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->annotation as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessageList('annotation', 'annotation', $this->annotation);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'annotation':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\GeneratedCodeInfo_Annotation();
            $obj->MergeJsonFrom($vv);
            $this->annotation []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is GeneratedCodeInfo)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->annotation as $v) {
      $nv = new \google\protobuf\GeneratedCodeInfo_Annotation();
      $nv->CopyFrom($v);
      $this->annotation []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_descriptor__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/descriptor.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 10338 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\xc4\x59\x5d\x6f\xe3\xc6\xb9\x8e\x24\x4a\xa6\x5e\xc9\xd2\x78\xec\xec\x72\x9d\x8f\xf5\x2a\x1f\xeb\xdd\x24\xda\x60\xbf\xb2\x71\xe\x72\x8e\x2c\x71\x1d\xf9\xc8\x92\xe\x25\x9f\x7c\x0\x5\x31\x26\x47\x32\x77\x29\x92\x21\xa9\xdd\x75\x50\x14\xb\xf4\xaa\x97\xed\x65\x51\xf4\xa2\x37\x1\xfa\x3\xa\xf4\xae\xfd\x3\x5\xfa\xf\xa\xb4\x40\xfb\x13\x7a\x59\xcc\xc\x49\x51\x1f\xce\x3a\x1\x92\x5c\xd9\xf3\xcc\xf3\xbe\xf3\xce\xcb\x67\x66\xde\x19\xc1\xce\xd8\x75\xc7\x36\xbd\xe5\xf9\x6e\xe8\x9e\x4c\x47\xb7\x4c\x1a\x18\xbe\xe5\x85\xae\x5f\xe7\x18\xae\xa\x46\x3d\x66\xd4\x8e\x60\xe3\xa1\x65\xd3\x56\x42\x1c\xd0\x10\x3f\x0\x69\x64\xd9\x54\xc9\xec\xe4\x76\x4b\xb7\xdf\xac\x2f\x18\xd5\xe7\x2d\xfa\xc\xd6\xb8\x45\xed\x1f\x12\x6c\xae\xe8\xc5\x18\x24\x87\x4c\x98\xc7\xcc\x6e\x51\xe3\xff\x63\x5\xd6\x3c\x62\x3c\x26\x63\xaa\x64\x39\x1c\x37\xf1\xeb\x0\x26\xf5\xa8\x63\x52\xc7\x38\x53\x72\x3b\xb9\xdd\xa2\x96\x42\xf0\x3b\xb0\xe1\x4d\x4f\x6c\xcb\xd0\x53\x34\xd8\xc9\xed\xe6\x35\x24\x3a\x5a\x33\xf2\x75\xa8\x3e\xa5\xe4\x71\x9a\x5a\xe2\xd4\xa\x83\x53\xc4\x26\x94\x27\x34\x8\xc8\x98\xea\xe1\x99\x47\x15\x89\xcf\x7e\x67\x69\xf6\x8b\x33\x2f\x45\x56\xc3\x33\x8f\xe2\x6\x14\xa9\x33\x9d\x8\xf\xf9\x73\xf2\xa7\x3a\xd3\xc9\xa2\x17\x99\x99\x45\x2e\xd6\x2\xea\x3f\xb1\xc\xaa\x14\xb8\x83\xeb\x4b\xe\x6\xa2\x7f\xd1\x47\x6c\x87\x9b\x50\xa4\xcf\x42\xea\x4\x96\xeb\x28\x6b\xdc\xc9\x5b\x2b\xbe\x22\xb5\xcd\x45\x17\x33\x3b\x7c\x1f\xd6\x5c\x2f\xb4\x5c\x27\x50\xe4\x9d\xcc\x6e\xe9\xf6\xab\x2b\x85\xd0\x13\x1c\x2d\x26\xe3\x36\xa0\xc0\x9d\xfa\x6\xd5\xd\xd7\xa4\xba\xe5\x8c\x5c\xa5\xc8\x1d\x5c\x5d\x9e\x8\x27\x36\x5d\x93\xb6\x9d\x91\xab\x55\x82\xb9\x36\xbe\x4\x85\xe0\xcc\x9\xc9\x33\xa5\xcc\x15\x12\xb5\x6a\x7f\x2c\x40\xf5\x22\x12\xfb\x8\xf2\x23\x36\x4b\x25\xfb\x6d\x72\x20\x6c\xe6\x93\x58\xf8\x8e\x49\x6c\x40\xc9\xa1\x41\x48\x4d\xa1\x88\xdc\x5\x35\x5\xc2\x68\x59\x52\xd2\x77\x92\xd4\x67\x50\x4d\x42\xd2\x7d\xe2\x8c\x63\x6d\xde\x7a\x51\x24\x75\x35\xb6\xd3\x98\x99\x56\xa1\x73\x6d\xdc\x2\x70\x1d\xea\x8e\x74\x93\x1a\xb6\x22\x9f\x93\xa5\x1e\xa3\x2c\x65\xc9\x15\xa8\x61\xe3\xf\x67\x52\x5b\x3b\x47\x29\x47\x62\x91\x2d\xa9\xed\x18\x2a\x3e\x65\xba\xa7\x66\x34\xb3\x22\xf\xa2\xfe\xc2\x99\x69\x91\x99\x98\xd8\xba\x9f\x6e\xe2\x37\x20\x1\x74\x2e\x2b\xe0\xbb\x50\x39\x6\xbb\x64\x42\xb7\xbf\x82\xca\x7c\x7a\xf0\x16\xe4\x83\x90\xf8\x21\x57\x61\x5e\x13\xd\x8c\x20\x47\x1d\x93\xef\x72\x79\x8d\xfd\x8b\xff\x67\x36\xe1\x1c\x9f\xf0\xdb\xcb\x5f\x74\xce\xf3\xe2\xbc\xb7\x3f\x80\xf5\xb9\x9\x5c\x74\xe8\xda\x4f\xe1\xe5\x95\xae\xf1\x67\xb0\x35\x75\x2c\x27\xa4\xbe\xe7\x53\xa6\x58\x31\x94\xf2\xcf\xb5\x73\x34\x77\x9c\x66\xb\x2f\xda\xe6\x74\x19\xbc\x59\x94\xff\xb5\x86\x9e\x3f\x7f\xfe\x3c\x5b\xfb\x73\x1\xb6\x56\xad\x99\x95\xcb\xf7\x12\x14\x9c\xe9\xe4\x84\xfa\x3c\x49\x79\x2d\x6a\xe1\x6\xe4\x6d\x72\x42\x6d\x45\xda\xc9\xec\x56\x6e\xbf\x73\xa1\x55\x59\xef\x30\x13\x4d\x58\xe2\x8f\x41\x8a\xb6\x68\xe6\xe1\xe6\xc5\x3c\xb0\xb5\xa4\x71\x3b\xfc\xa\x14\xd9\x5f\xa1\x8d\x2\x8f\x59\x66\x0\xd3\x5\xde\x6\x99\x2f\x13\x93\xc6\x47\x5b\xd2\x66\xc2\x32\xe9\x88\x4c\xed\x50\x7f\x42\xec\x29\xe5\x82\x2f\x6a\xe5\x8\xfc\x7f\x86\xe1\xab\x50\x12\xab\xca\x72\x4c\xfa\x8c\xef\x9e\x79\x4d\x2c\xb4\x36\x43\xd8\xf0\x8f\x2\xd7\x89\xa5\xc9\x87\x60\x0\x1f\xfe\x83\xc5\x8d\xfb\xb5\xd5\xd3\x5b\x5a\x4b\xd7\xa1\xca\x19\x77\xa2\x4f\x4f\x6c\x65\x63\x27\xb3\x2b\x6b\x15\x1\xf7\x22\xb4\xf6\x87\x2c\x48\x7c\x63\xa9\x42\x69\xf8\x79\x5f\xd5\x5b\xbd\xe3\xfd\x8e\x8a\x32\xb8\x2\xc0\x81\x87\x9d\x5e\x63\x88\xb2\x49\xbb\xdd\x1d\xde\xbf\x8b\x72\x89\xc1\xb1\x0\xa4\x34\xe1\xce\x6d\x94\xc7\x8\xca\xc2\x41\xfb\x33\xb5\x75\xff\x2e\x2a\xcc\x23\x77\x6e\xa3\x35\xbc\xe\x45\x8e\xec\xf7\x7a\x1d\x24\x27\x3e\x7\x43\xad\xdd\x3d\x40\xc5\xc4\xe7\x81\xd6\x3b\xee\x23\x48\x3c\x1c\xa9\x83\x41\xe3\x40\x45\xa5\x84\xb1\xff\xf9\x50\x1d\xa0\xf2\x5c\x58\x77\x6e\xa3\xf5\x64\x8\xb5\x7b\x7c\x84\x2a\x78\x3\xd6\xc5\x10\x71\x10\xd5\x5\xe8\xfe\x5d\x84\x66\x81\x8\x2f\x1b\x73\xc0\xfd\xbb\x8\xd7\x9a\x90\xe7\x32\xc4\x18\x2a\x9d\xc6\xbe\xda\xd1\x7b\xfd\x61\xbb\xd7\x6d\x74\x50\x66\x86\x69\xea\xff\x1d\xb7\x35\xb5\x85\xb2\x69\xac\xaf\x36\x86\x6a\xb\xe5\x6a\x6\x6c\xad\xda\x50\x57\x2e\xa1\x94\x16\xb2\xe7\x68\x81\xfb\x5a\xd4\x42\xed\xef\x59\xd8\x5c\x71\xa8\xac\x1c\xe4\xbf\x21\x2f\xb4\x2c\x8e\xd9\x1b\x2b\x4f\x27\xae\xec\xa5\xa3\x96\xdb\xa5\x4b\x8d\xdc\x39\xa5\x6\x73\xb1\x24\xd8\x9f\x2c\x6d\xfe\xe2\x7c\xbc\x7f\x91\xf3\x91\x63\xdf\xee\x10\xc8\xaf\x38\x4\x3e\x82\x8d\x25\x47\x17\xde\x8c\x7f\x9e\x1\xe5\xbc\xe4\xbc\x60\x4b\xcc\xce\x6d\x89\x1f\x2d\x66\xf0\xda\xf9\x1f\x61\xe9\x5b\x7f\x9d\x81\x4b\xab\x4b\xca\x95\x31\x7c\xc\x85\x9\xd\x4f\xdd\xb8\xac\x7a\x7b\xc5\x61\xcd\xba\x17\x3f\x76\x64\x95\x3e\xed\x73\xe7\xd5\x85\x22\x9a\xa5\x48\x7f\x91\x85\x97\x57\x3a\x5f\x19\xe8\x6b\x0\x96\xe3\x4d\x43\x51\x3a\x89\x9d\xb8\xc8\x11\xbe\x79\xb1\x5d\x76\x1a\x26\xfd\x39\xde\xf\x2\xe2\x84\x7\xb3\x40\x25\x1e\xe8\xeb\xe7\xcc\x74\x49\x98\xef\x3\x32\x6c\x8b\x3a\xa1\x1e\x84\x3e\x25\x13\xcb\x19\xf3\xa3\x46\xde\xcb\x8f\x88\x1d\x50\xad\x2a\xba\x7\x71\x2f\xb3\xe0\x2\xf2\x53\x16\x85\x39\xb\xd1\x9d\x58\xd4\x7e\x59\x84\x52\xaa\x0\xc7\xd7\xa0\xfc\x88\x3c\x21\x7a\x7c\xa9\x12\x99\x28\x31\xac\x1f\x5d\xac\xde\x87\x2d\x4e\x71\xa7\x21\xf5\x75\xc3\x26\x41\xc0\x93\x26\x73\x2a\x66\x7d\x3d\xd6\xd5\x8c\x7b\xf0\x3d\xd8\xe4\x16\x93\xa9\x1d\x5a\x9e\x4d\x75\x76\xcd\xb\xf8\x91\x93\x44\xb6\xc1\x18\x47\x11\x81\x45\x14\xe0\x16\xbc\xc6\xcd\xc6\xd4\xa1\x3e\x9\xa9\x4e\xbf\x9c\x12\x3b\xd0\x89\x63\xea\xa7\x24\x38\x55\xb6\x98\x83\xfd\xac\x92\xd1\xae\x30\xe2\x41\xc4\x53\x39\xad\xe1\x98\x9f\x90\xe0\x14\xef\xc1\x25\xee\x25\x8\x7d\xcb\x19\xeb\xc6\x29\x35\x1e\xeb\xd3\x70\xf4\x40\x79\x25\x3d\x3e\x8f\x70\xc0\x39\x4d\x46\x39\xe\x47\xf\xf0\x0\xca\xec\x63\x4c\xac\xaf\xa8\x3e\x72\x7d\x7e\x86\x56\x56\x6c\x4d\xa9\xc\xd6\x7b\x91\xc1\x91\x6b\xd2\xbd\xfc\xa0\xaf\xaa\x2d\xad\x14\x7b\x79\xe8\xfa\x4c\x50\x63\x37\x49\x70\x49\x8\x6a\xec\xc6\xe9\xbd\x7\x9b\x86\x21\xe6\x6c\x19\x7a\x74\x19\xb\x14\x34\x97\x2c\xc3\x38\x10\x84\x48\xe3\x1\xfe\x10\x5e\x9e\x25\x2b\x6d\xb8\xb1\x34\xcb\x45\xd3\x7b\xb0\xe9\x9d\x2d\x1b\xe2\xb9\x11\xbd\xb3\x45\xb3\xf\x60\xcb\x3b\xf5\x96\xed\x6e\xa6\xed\xb0\x77\xea\x2d\x1a\xbe\xc5\x6f\xe6\x3e\x35\x48\x48\x4d\xe5\x72\x9a\x9e\xea\xc0\x75\x40\x86\xa1\x53\x87\x9c\xd8\x54\x27\x3e\x75\x48\xa0\x5c\xe5\x64\x29\xf4\xa7\x54\xab\x18\x86\xca\x3b\x1b\xbc\xf\xdf\x84\xd\xf7\xe4\x91\x21\x14\xa9\x7b\x3e\x1d\x59\xcf\x94\x37\x79\x7a\xab\xac\x83\xeb\xb1\xcf\x61\x7c\x3\x90\x11\x9c\x12\xdf\xe3\x5b\x72\xe0\x11\x83\x2a\x6f\x9\xaa\xc0\xbb\x31\xcc\x56\x44\xf0\xd4\x1a\x85\xb1\xc7\xeb\x62\x45\x70\x2c\xf2\xb6\xb\x88\x65\x62\x6e\xe0\x5d\x4e\xab\x78\xa7\x5e\x7a\xdc\x37\x60\x9d\x31\x67\x83\xde\x10\x85\x9b\x77\x9a\x1a\xf1\x2e\x5c\x62\xa4\x9\xd\x89\x49\x42\x92\x62\xbf\xcb\xd9\x2c\xed\x47\x51\xe7\x5c\x9c\xfe\xf4\xe4\x2c\x11\xd6\x7b\x22\x4e\x86\xc5\xd2\xfa\xde\x8a\xf3\xda\x1e\x94\xd3\xba\xc7\x45\x10\xca\x47\x19\x56\x4\x35\x7b\x2d\x56\xbe\x7c\xa1\xa2\x2c\x2b\xa3\x3a\xed\xa1\xaa\x6b\xc7\xdd\x61\xfb\x48\x45\xb9\x54\x61\x7f\x28\xc9\x6f\xa3\xeb\xac\x6a\xa8\xcc\xdf\xd4\xf0\x7f\xc1\xe5\xf8\x59\x25\xa0\xa1\xfe\xd4\xf2\xf9\x82\x9c\x10\x71\x38\x26\xfa\xd9\x8a\x58\x3\x1a\x7e\x6a\xf9\x6c\xb9\x4d\x48\x88\x3b\x70\xd5\x71\xf5\x20\x24\x8e\x49\x7c\x53\x9f\x3d\x68\xe9\xc4\x30\x68\x10\xb8\xe2\x20\x4c\xbc\xbc\xea\xb8\x83\x88\x3c\x3b\x21\x1a\x11\x75\x41\xbe\xb9\xf3\xe4\xfb\xa\x14\x27\xc4\xd3\xa9\x13\xfa\x67\xbc\x3e\x97\x35\x79\x42\x3c\x95\xb5\x7f\x90\x6b\xd2\xa1\x24\x4b\x28\x7f\x28\xc9\x79\x54\x38\x94\xe4\x2\x5a\x3b\x94\x64\x19\x15\xf\x25\xb9\x88\xa0\xf6\x2b\x9\xca\xe9\xa\x9e\x5d\x88\xc\x7e\x86\x65\xf8\x2e\xf7\xc6\x37\xd6\xfb\xf5\x26\x3b\xdc\xf6\xa\xa2\x5c\xd6\x84\x25\x2b\x2c\x98\xfc\xa8\x28\x4f\x64\x2d\x6a\xe1\x3\x28\x3c\xa\xb8\xef\x2\xf7\xfd\xe6\x37\xfb\x3e\x1c\x70\xe7\xc5\xc3\x81\xde\xed\x69\x47\x8d\x8e\x16\x99\xe3\x2b\x20\xd9\xe4\xab\xb3\xf9\x63\x90\x43\xb8\xe\xd5\xa9\xf3\x84\xfa\xd6\xc8\xa2\xa6\xce\x59\xd5\x34\xab\x32\xeb\xed\x30\xfe\x5\x3f\xe3\x15\x90\x9e\x52\xf2\x78\xfe\xb0\xe2\xd0\xf7\xb8\x9c\x6e\x41\x9e\xe7\x17\x3\x44\x19\x46\x2f\x61\x19\xa4\x66\x4f\x63\x4b\xa\x41\x59\xa0\x7a\xbf\xad\x36\x55\x94\xad\xdd\x83\x82\x48\x1a\x5b\x6e\x49\xda\xd0\x4b\x51\x33\xf2\x91\x89\x7b\x8f\x8f\xf6\x55\xd\x65\x97\xc4\x52\xb\xa0\x9c\xae\xe4\x7f\x98\xeb\xfc\x9f\x32\x50\x4a\x55\xe6\xac\xa4\x22\xb6\xed\x3e\xd5\x89\x6d\x91\x20\x92\x12\x70\xa8\xc1\x90\x8b\x7e\xba\x1f\x68\x91\xe5\x51\xa1\xf6\xdb\xc\xa0\xc5\xd2\x78\x21\xcc\xcc\x8f\x19\x66\xed\x37\x19\xa8\xcc\xd7\xc3\xb\xe1\x5d\xfb\x51\xc3\xfb\x5b\x16\xd6\xe7\xaa\xe0\x8b\x46\xf7\x25\x6c\x58\x26\x9d\x78\x6e\x48\x1d\xe3\x4c\xb7\xe9\x13\x6a\x2b\x35\xbe\xc9\xdc\xfa\xe6\x3a\xbb\xde\x9e\xd9\x75\x98\xd9\xde\x66\xbb\xa5\x1e\xf5\x7b\x43\xb5\xdb\xfc\x5c\x3f\xee\xfe\x6f\xb7\xf7\x69\x57\x43\xd6\x2\xed\x7b\x5c\xf6\x7d\x40\x8b\x41\xe1\xcb\xb0\x2a\x2c\xf4\x12\xde\x84\x6a\xb7\xa7\xf\xda\x2d\x55\x57\x1f\x3e\x54\x9b\xc3\x81\x78\x39\x49\xd8\xc3\xb9\x5\x5e\xfb\x75\xe\x36\x57\x44\x82\x1b\xd1\x9d\x47\x5c\xc3\xde\xbb\x48\xf4\x75\x56\x75\xf4\x89\x1f\x46\x57\xa4\x1b\xc0\xb2\xe4\x84\x6c\x73\xf5\xa3\x17\x29\x71\x11\xaa\xce\x70\xf1\x28\xf5\x2e\x60\xcf\xd\xac\xd0\x7a\x42\x75\xcb\x89\x9f\xaf\xd8\xc5\x48\xd2\x50\xdc\xd3\x76\xc2\x84\xed\xd0\x31\x59\x60\xb3\xcd\x3f\xa7\xa1\xb8\x27\x61\x5f\x83\xb2\xe9\x4e\x59\xb5\x28\x78\xec\xac\xc9\x68\x25\x81\x25\x94\xe8\x1e\x30\x7b\x37\x2b\x6b\x25\x81\x9\xca\x75\xa8\x92\xf1\xd8\x67\xce\x63\x47\xe2\x66\x53\x49\x60\x4e\xdc\x3e\x4\x39\xce\x3\x3b\xec\x59\x26\x74\x4f\x5c\xd7\xb3\xbb\x45\x4d\x76\xe2\xce\x6b\x50\xb6\x2\x7d\xf6\x33\x40\x76\x27\xbb\x2b\x6b\x25\x2b\x48\x9e\x50\x6b\x5f\x67\xa1\x32\xff\x33\x6\x6e\x81\x6c\xbb\x6\xe1\xd2\x12\xbf\xa1\xed\xbe\xe0\x97\x8f\x7a\x27\xe2\x6b\x89\xe5\xf6\x5f\x32\x20\xc7\x30\xbe\x4\x92\x47\xc2\x53\xee\x2e\xbf\x9f\x45\x19\x8d\xb7\x19\x1e\x78\xc4\xe1\x12\x88\x70\xd6\x66\xdf\xd5\xa6\xc4\xe4\xd7\x26\x77\x32\xa1\x4e\x18\xc4\xdf\x35\xc2\x9b\x11\x8c\xdf\x81\x8d\xd0\x27\x96\x3d\xc7\x95\x38\x17\xc5\x1d\x9\x79\xf\xae\xc4\x7e\x4d\x1a\x12\xe3\x94\x9a\x33\xa3\x2\x7f\x1e\xb9\x1c\x11\x5a\x51\x7f\x6c\x5b\xfb\x6b\x6\x36\xe2\x8b\x9e\x99\x24\xeb\x8\x80\x38\x8e\x1b\xa6\xd3\xb5\x2c\xe5\x25\xbb\x7a\x23\x31\xd2\x52\xe\xb6\x27\x0\xb3\x9e\x73\xd3\x76\x15\x4a\xd1\x6f\x54\xfc\x87\x4e\xf1\x34\x0\x2\x62\x37\x42\xbc\x5\xf9\x13\x3a\xb6\x9c\xe8\xe5\x59\x34\xe2\x7\x1c\x29\x79\xc0\xd9\xff\x19\x6c\x1a\xee\x64\x31\xdc\x7d\xb4\xf0\x3c\x11\x7c\x92\xf9\xe2\xbd\x88\x34\x76\x6d\xe2\x8c\xeb\xae\x3f\x9e\xfd\x50\xcb\x2a\xa4\x20\xf5\x73\xad\x77\xf2\xef\x4c\xe6\x77\xd9\xdc\x41\x7f\xff\xf7\xd9\xed\x3\x61\xd8\x8f\x93\xa1\xd1\x91\x4d\xd\x36\xc1\xff\x4\x0\x0\xff\xff\xa5\x44\x7d\x26");
  }
}
