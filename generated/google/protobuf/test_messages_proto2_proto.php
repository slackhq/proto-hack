<?hh // strict
namespace protobuf_test_messages\proto2;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/test_messages_proto2.proto

newtype ForeignEnumProto2_enum_t as int = int;
abstract class ForeignEnumProto2 {
  const ForeignEnumProto2_enum_t FOREIGN_FOO = 0;
  const ForeignEnumProto2_enum_t FOREIGN_BAR = 1;
  const ForeignEnumProto2_enum_t FOREIGN_BAZ = 2;
  private static dict<int, string> $itos = dict[
    0 => 'FOREIGN_FOO',
    1 => 'FOREIGN_BAR',
    2 => 'FOREIGN_BAZ',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FOREIGN_FOO' => 0,
    'FOREIGN_BAR' => 1,
    'FOREIGN_BAZ' => 2,
  ];
  public static function FromMixed(mixed $m): ForeignEnumProto2_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): ForeignEnumProto2_enum_t {
    return $i;
  }
}

newtype TestAllTypesProto2_NestedEnum_enum_t as int = int;
abstract class TestAllTypesProto2_NestedEnum {
  const TestAllTypesProto2_NestedEnum_enum_t FOO = 0;
  const TestAllTypesProto2_NestedEnum_enum_t BAR = 1;
  const TestAllTypesProto2_NestedEnum_enum_t BAZ = 2;
  const TestAllTypesProto2_NestedEnum_enum_t NEG = -1;
  private static dict<int, string> $itos = dict[
    0 => 'FOO',
    1 => 'BAR',
    2 => 'BAZ',
    -1 => 'NEG',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FOO' => 0,
    'BAR' => 1,
    'BAZ' => 2,
    'NEG' => -1,
  ];
  public static function FromMixed(mixed $m): TestAllTypesProto2_NestedEnum_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): TestAllTypesProto2_NestedEnum_enum_t {
    return $i;
  }
}

enum TestAllTypesProto2_oneof_field_oneof_t: int {
  NOT_SET = 0;
  oneof_uint32 = 111;
  oneof_nested_message = 112;
  oneof_string = 113;
  oneof_bytes = 114;
  oneof_bool = 115;
  oneof_uint64 = 116;
  oneof_float = 117;
  oneof_double = 118;
  oneof_enum = 119;
}

interface TestAllTypesProto2_oneof_field {
  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): TestAllTypesProto2_oneof_field;
}

class TestAllTypesProto2_oneof_field_NOT_SET implements TestAllTypesProto2_oneof_field {
  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): TestAllTypesProto2_oneof_field { return $this; }
}

class TestAllTypesProto2_oneof_field_oneof_uint32 implements TestAllTypesProto2_oneof_field {
  public function __construct(public int $oneof_uint32) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_uint32;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(111, 0);;
    $e->writeVarint($this->oneof_uint32);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('oneof_uint32', 'oneofUint32', $this->oneof_uint32, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_uint32($this->oneof_uint32);
  }
}

class TestAllTypesProto2_oneof_field_oneof_nested_message implements TestAllTypesProto2_oneof_field {
  public function __construct(public \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $oneof_nested_message) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_nested_message;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->oneof_nested_message->WriteTo($nested);
    $e->writeEncoder($nested, 112);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('oneof_nested_message', 'oneofNestedMessage', $this->oneof_nested_message, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
    $nv->CopyFrom($this->oneof_nested_message);
    return new TestAllTypesProto2_oneof_field_oneof_nested_message($nv);
  }
}

class TestAllTypesProto2_oneof_field_oneof_string implements TestAllTypesProto2_oneof_field {
  public function __construct(public string $oneof_string) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_string;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(113, 2);;
    $e->writeString($this->oneof_string);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('oneof_string', 'oneofString', $this->oneof_string, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_string($this->oneof_string);
  }
}

class TestAllTypesProto2_oneof_field_oneof_bytes implements TestAllTypesProto2_oneof_field {
  public function __construct(public string $oneof_bytes) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_bytes;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(114, 2);;
    $e->writeString($this->oneof_bytes);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBytes('oneof_bytes', 'oneofBytes', $this->oneof_bytes, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_bytes($this->oneof_bytes);
  }
}

class TestAllTypesProto2_oneof_field_oneof_bool implements TestAllTypesProto2_oneof_field {
  public function __construct(public bool $oneof_bool) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_bool;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(115, 0);;
    $e->writeBool($this->oneof_bool);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('oneof_bool', 'oneofBool', $this->oneof_bool, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_bool($this->oneof_bool);
  }
}

class TestAllTypesProto2_oneof_field_oneof_uint64 implements TestAllTypesProto2_oneof_field {
  public function __construct(public int $oneof_uint64) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_uint64;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(116, 0);;
    $e->writeVarint($this->oneof_uint64);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('oneof_uint64', 'oneofUint64', $this->oneof_uint64, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_uint64($this->oneof_uint64);
  }
}

class TestAllTypesProto2_oneof_field_oneof_float implements TestAllTypesProto2_oneof_field {
  public function __construct(public float $oneof_float) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_float;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(117, 5);;
    $e->writeFloat($this->oneof_float);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeFloat('oneof_float', 'oneofFloat', $this->oneof_float, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_float($this->oneof_float);
  }
}

class TestAllTypesProto2_oneof_field_oneof_double implements TestAllTypesProto2_oneof_field {
  public function __construct(public float $oneof_double) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_double;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(118, 1);;
    $e->writeDouble($this->oneof_double);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeFloat('oneof_double', 'oneofDouble', $this->oneof_double, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_double($this->oneof_double);
  }
}

class TestAllTypesProto2_oneof_field_oneof_enum implements TestAllTypesProto2_oneof_field {
  public function __construct(public \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t $oneof_enum) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_enum;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(119, 0);;
    $e->writeVarint($this->oneof_enum);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('oneof_enum', 'oneofEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->oneof_enum, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_enum($this->oneof_enum);
  }
}

class TestAllTypesProto2_NestedMessage implements \Protobuf\Message {
  private int $a;
  private bool $was_a_set;
  private ?\protobuf_test_messages\proto2\TestAllTypesProto2 $corecursive;
  private bool $was_corecursive_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'a' => int,
    ?'corecursive' => ?\protobuf_test_messages\proto2\TestAllTypesProto2,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'a')) {
      $this->a = $s['a'];
      $this->was_a_set = true;
    } else {
      $this->a = 0;
      $this->was_a_set = false;
    }
    if (Shapes::keyExists($s, 'corecursive')) {
      $this->corecursive = $s['corecursive'];
      $this->was_corecursive_set = true;
    } else {
      $this->corecursive = null;
      $this->was_corecursive_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getA(): int {
    return $this->a;
  }

  public function setA(int $v): void {
    $this->a = $v;
    $this->was_a_set = true;
  }

  public function hasA(): bool {
    return $this->was_a_set;
  }

  public function getCorecursive(): ?\protobuf_test_messages\proto2\TestAllTypesProto2 {
    return $this->corecursive;
  }

  public function setCorecursive(?\protobuf_test_messages\proto2\TestAllTypesProto2 $v): void {
    $this->corecursive = $v;
    $this->was_corecursive_set = true;
  }

  public function hasCorecursive(): bool {
    return $this->was_corecursive_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.NestedMessage";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_NestedMessage {
    $msg = new TestAllTypesProto2_NestedMessage();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->a = $d->readVarint32Signed();
          $this->was_a_set = true;
          break;
        case 2:
          if ($this->corecursive is null) {
            $this->corecursive = new \protobuf_test_messages\proto2\TestAllTypesProto2();
            $this->was_corecursive_set = true;
          }
          $this->corecursive->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_a_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->a);
    }
    $msg = $this->corecursive;
    if ($msg != null) {
      if ($this->was_corecursive_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 2);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasA()) {
      $e->writeInt32('a', 'a', $this->a, false);
    }
    if ($this->hasCorecursive()) {
      $e->writeMessage('corecursive', 'corecursive', $this->corecursive, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'a':
          $this->a = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_a_set = true;
          break;
        case 'corecursive':
          if ($v is null) break;
          if ($this->corecursive is null) {
            $this->corecursive = new \protobuf_test_messages\proto2\TestAllTypesProto2();
            $this->was_corecursive_set = true;
          }
          $this->corecursive->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_NestedMessage)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasA()) {
      $this->setA($o->getA());
    }
    $tmp = $o->corecursive;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2();
      $nv->CopyFrom($tmp);
      $this->setCorecursive($nv);
    } else if ($o->hasCorecursive()) {
      $this->setCorecursive(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt32Int32Entry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private int $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): int {
    return $this->value;
  }

  public function setValue(int $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt32Int32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapInt32Int32Entry {
    $msg = new TestAllTypesProto2_MapInt32Int32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readVarint32Signed();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt32('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeInt32('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt32Int32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt64Int64Entry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private int $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): int {
    return $this->value;
  }

  public function setValue(int $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt64Int64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapInt64Int64Entry {
    $msg = new TestAllTypesProto2_MapInt64Int64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readVarint();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt64Signed('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeInt64Signed('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt64Int64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapUint32Uint32Entry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private int $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): int {
    return $this->value;
  }

  public function setValue(int $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapUint32Uint32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapUint32Uint32Entry {
    $msg = new TestAllTypesProto2_MapUint32Uint32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readVarint32();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt32('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeInt32('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapUint32Uint32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapUint64Uint64Entry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private int $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): int {
    return $this->value;
  }

  public function setValue(int $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapUint64Uint64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapUint64Uint64Entry {
    $msg = new TestAllTypesProto2_MapUint64Uint64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readVarint();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt64Unsigned('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeInt64Unsigned('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapUint64Uint64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSint32Sint32Entry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private int $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): int {
    return $this->value;
  }

  public function setValue(int $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSint32Sint32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapSint32Sint32Entry {
    $msg = new TestAllTypesProto2_MapSint32Sint32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarintZigZag32();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readVarintZigZag32();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 0);
      $e->writeVarintZigZag32($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 0);
      $e->writeVarintZigZag32($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt32('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeInt32('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSint32Sint32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSint64Sint64Entry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private int $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): int {
    return $this->value;
  }

  public function setValue(int $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSint64Sint64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapSint64Sint64Entry {
    $msg = new TestAllTypesProto2_MapSint64Sint64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarintZigZag64();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readVarintZigZag64();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 0);
      $e->writeVarintZigZag64($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 0);
      $e->writeVarintZigZag64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt64Signed('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeInt64Signed('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSint64Sint64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapFixed32Fixed32Entry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private int $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): int {
    return $this->value;
  }

  public function setValue(int $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapFixed32Fixed32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapFixed32Fixed32Entry {
    $msg = new TestAllTypesProto2_MapFixed32Fixed32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt32Unsigned();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readLittleEndianInt32Unsigned();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 5);
      $e->writeLittleEndianInt32Unsigned($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 5);
      $e->writeLittleEndianInt32Unsigned($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt32('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeInt32('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapFixed32Fixed32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapFixed64Fixed64Entry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private int $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): int {
    return $this->value;
  }

  public function setValue(int $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapFixed64Fixed64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapFixed64Fixed64Entry {
    $msg = new TestAllTypesProto2_MapFixed64Fixed64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt64();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readLittleEndianInt64();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 1);
      $e->writeLittleEndianInt64($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 1);
      $e->writeLittleEndianInt64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt64Unsigned('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeInt64Unsigned('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapFixed64Fixed64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSfixed32Sfixed32Entry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private int $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): int {
    return $this->value;
  }

  public function setValue(int $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSfixed32Sfixed32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapSfixed32Sfixed32Entry {
    $msg = new TestAllTypesProto2_MapSfixed32Sfixed32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt32Signed();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readLittleEndianInt32Signed();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 5);
      $e->writeLittleEndianInt32Signed($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 5);
      $e->writeLittleEndianInt32Signed($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt32('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeInt32('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSfixed32Sfixed32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSfixed64Sfixed64Entry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private int $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): int {
    return $this->value;
  }

  public function setValue(int $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSfixed64Sfixed64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapSfixed64Sfixed64Entry {
    $msg = new TestAllTypesProto2_MapSfixed64Sfixed64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt64();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readLittleEndianInt64();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 1);
      $e->writeLittleEndianInt64($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 1);
      $e->writeLittleEndianInt64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt64Signed('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeInt64Signed('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSfixed64Sfixed64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt32BoolEntry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private bool $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => bool,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = false;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): bool {
    return $this->value;
  }

  public function setValue(bool $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt32BoolEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapInt32BoolEntry {
    $msg = new TestAllTypesProto2_MapInt32BoolEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readBool();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 0);
      $e->writeBool($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt32('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeBool('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt32BoolEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt32FloatEntry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private float $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => float,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0.0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): float {
    return $this->value;
  }

  public function setValue(float $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt32FloatEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapInt32FloatEntry {
    $msg = new TestAllTypesProto2_MapInt32FloatEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readFloat();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 5);
      $e->writeFloat($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt32('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeFloat('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt32FloatEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt32DoubleEntry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private float $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => float,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = 0.0;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): float {
    return $this->value;
  }

  public function setValue(float $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt32DoubleEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapInt32DoubleEntry {
    $msg = new TestAllTypesProto2_MapInt32DoubleEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readDouble();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 1);
      $e->writeDouble($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt32('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeFloat('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt32DoubleEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt32NestedMessageEntry implements \Protobuf\Message {
  private int $key;
  private bool $was_key_set;
  private ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = 0;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = null;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): int {
    return $this->key;
  }

  public function setKey(int $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage {
    return $this->value;
  }

  public function setValue(?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt32NestedMessageEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapInt32NestedMessageEntry {
    $msg = new TestAllTypesProto2_MapInt32NestedMessageEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          $this->was_key_set = true;
          break;
        case 2:
          if ($this->value is null) {
            $this->value = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
            $this->was_value_set = true;
          }
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      if ($this->was_value_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 2);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeInt32('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeMessage('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_key_set = true;
          break;
        case 'value':
          if ($v is null) break;
          if ($this->value is null) {
            $this->value = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
            $this->was_value_set = true;
          }
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt32NestedMessageEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    $tmp = $o->value;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->setValue($nv);
    } else if ($o->hasValue()) {
      $this->setValue(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapBoolBoolEntry implements \Protobuf\Message {
  private bool $key;
  private bool $was_key_set;
  private bool $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => bool,
    ?'value' => bool,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = false;
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = false;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): bool {
    return $this->key;
  }

  public function setKey(bool $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): bool {
    return $this->value;
  }

  public function setValue(bool $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapBoolBoolEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapBoolBoolEntry {
    $msg = new TestAllTypesProto2_MapBoolBoolEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readBool();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readBool();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 0);
      $e->writeBool($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 0);
      $e->writeBool($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeBool('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeBool('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapBoolBoolEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringStringEntry implements \Protobuf\Message {
  private string $key;
  private bool $was_key_set;
  private string $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => string,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = '';
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = '';
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): string {
    return $this->key;
  }

  public function setKey(string $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): string {
    return $this->value;
  }

  public function setValue(string $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringStringEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringStringEntry {
    $msg = new TestAllTypesProto2_MapStringStringEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readString();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeString('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeString('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringStringEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringBytesEntry implements \Protobuf\Message {
  private string $key;
  private bool $was_key_set;
  private string $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => string,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = '';
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = '';
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): string {
    return $this->key;
  }

  public function setKey(string $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): string {
    return $this->value;
  }

  public function setValue(string $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringBytesEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringBytesEntry {
    $msg = new TestAllTypesProto2_MapStringBytesEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = $d->readString();
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeString('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeBytes('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readBytes($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringBytesEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringNestedMessageEntry implements \Protobuf\Message {
  private string $key;
  private bool $was_key_set;
  private ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = '';
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = null;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): string {
    return $this->key;
  }

  public function setKey(string $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage {
    return $this->value;
  }

  public function setValue(?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringNestedMessageEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringNestedMessageEntry {
    $msg = new TestAllTypesProto2_MapStringNestedMessageEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          $this->was_key_set = true;
          break;
        case 2:
          if ($this->value is null) {
            $this->value = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
            $this->was_value_set = true;
          }
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      if ($this->was_value_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 2);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeString('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeMessage('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_key_set = true;
          break;
        case 'value':
          if ($v is null) break;
          if ($this->value is null) {
            $this->value = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
            $this->was_value_set = true;
          }
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringNestedMessageEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    $tmp = $o->value;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->setValue($nv);
    } else if ($o->hasValue()) {
      $this->setValue(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringForeignMessageEntry implements \Protobuf\Message {
  private string $key;
  private bool $was_key_set;
  private ?\protobuf_test_messages\proto2\ForeignMessageProto2 $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => ?\protobuf_test_messages\proto2\ForeignMessageProto2,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = '';
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = null;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): string {
    return $this->key;
  }

  public function setKey(string $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): ?\protobuf_test_messages\proto2\ForeignMessageProto2 {
    return $this->value;
  }

  public function setValue(?\protobuf_test_messages\proto2\ForeignMessageProto2 $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringForeignMessageEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringForeignMessageEntry {
    $msg = new TestAllTypesProto2_MapStringForeignMessageEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          $this->was_key_set = true;
          break;
        case 2:
          if ($this->value is null) {
            $this->value = new \protobuf_test_messages\proto2\ForeignMessageProto2();
            $this->was_value_set = true;
          }
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      if ($this->was_value_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 2);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeString('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeMessage('value', 'value', $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_key_set = true;
          break;
        case 'value':
          if ($v is null) break;
          if ($this->value is null) {
            $this->value = new \protobuf_test_messages\proto2\ForeignMessageProto2();
            $this->was_value_set = true;
          }
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringForeignMessageEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    $tmp = $o->value;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($tmp);
      $this->setValue($nv);
    } else if ($o->hasValue()) {
      $this->setValue(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringNestedEnumEntry implements \Protobuf\Message {
  private string $key;
  private bool $was_key_set;
  private \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = '';
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FOO;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): string {
    return $this->key;
  }

  public function setKey(string $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t {
    return $this->value;
  }

  public function setValue(\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringNestedEnumEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringNestedEnumEntry {
    $msg = new TestAllTypesProto2_MapStringNestedEnumEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeString('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeEnum('value', 'value', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringNestedEnumEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringForeignEnumEntry implements \Protobuf\Message {
  private string $key;
  private bool $was_key_set;
  private \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t $value;
  private bool $was_value_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'key')) {
      $this->key = $s['key'];
      $this->was_key_set = true;
    } else {
      $this->key = '';
      $this->was_key_set = false;
    }
    if (Shapes::keyExists($s, 'value')) {
      $this->value = $s['value'];
      $this->was_value_set = true;
    } else {
      $this->value = \protobuf_test_messages\proto2\ForeignEnumProto2::FOREIGN_FOO;
      $this->was_value_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getKey(): string {
    return $this->key;
  }

  public function setKey(string $v): void {
    $this->key = $v;
    $this->was_key_set = true;
  }

  public function hasKey(): bool {
    return $this->was_key_set;
  }

  public function getValue(): \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t {
    return $this->value;
  }

  public function setValue(\protobuf_test_messages\proto2\ForeignEnumProto2_enum_t $v): void {
    $this->value = $v;
    $this->was_value_set = true;
  }

  public function hasValue(): bool {
    return $this->was_value_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringForeignEnumEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringForeignEnumEntry {
    $msg = new TestAllTypesProto2_MapStringForeignEnumEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          $this->was_key_set = true;
          break;
        case 2:
          $this->value = \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($d->readVarint());
          $this->was_value_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_key_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->was_value_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasKey()) {
      $e->writeString('key', 'key', $this->key, false);
    }
    if ($this->hasValue()) {
      $e->writeEnum('value', 'value', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->value, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_key_set = true;
          break;
        case 'value':
          $this->value = \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($v);
          $this->was_value_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringForeignEnumEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasKey()) {
      $this->setKey($o->getKey());
    }
    if ($o->hasValue()) {
      $this->setValue($o->getValue());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_Data implements \Protobuf\Message {
  private int $group_int32;
  private bool $was_group_int32_set;
  private int $group_uint32;
  private bool $was_group_uint32_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'group_int32' => int,
    ?'group_uint32' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'group_int32')) {
      $this->group_int32 = $s['group_int32'];
      $this->was_group_int32_set = true;
    } else {
      $this->group_int32 = 0;
      $this->was_group_int32_set = false;
    }
    if (Shapes::keyExists($s, 'group_uint32')) {
      $this->group_uint32 = $s['group_uint32'];
      $this->was_group_uint32_set = true;
    } else {
      $this->group_uint32 = 0;
      $this->was_group_uint32_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getGroupInt32(): int {
    return $this->group_int32;
  }

  public function setGroupInt32(int $v): void {
    $this->group_int32 = $v;
    $this->was_group_int32_set = true;
  }

  public function hasGroupInt32(): bool {
    return $this->was_group_int32_set;
  }

  public function getGroupUint32(): int {
    return $this->group_uint32;
  }

  public function setGroupUint32(int $v): void {
    $this->group_uint32 = $v;
    $this->was_group_uint32_set = true;
  }

  public function hasGroupUint32(): bool {
    return $this->was_group_uint32_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.Data";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_Data {
    $msg = new TestAllTypesProto2_Data();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 202:
          $this->group_int32 = $d->readVarint32Signed();
          $this->was_group_int32_set = true;
          break;
        case 203:
          $this->group_uint32 = $d->readVarint32();
          $this->was_group_uint32_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_group_int32_set) {
      $e->writeTag(202, 0);
      $e->writeVarint($this->group_int32);
    }
    if ($this->was_group_uint32_set) {
      $e->writeTag(203, 0);
      $e->writeVarint($this->group_uint32);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasGroupInt32()) {
      $e->writeInt32('group_int32', 'groupInt32', $this->group_int32, false);
    }
    if ($this->hasGroupUint32()) {
      $e->writeInt32('group_uint32', 'groupUint32', $this->group_uint32, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'group_int32': case 'groupInt32':
          $this->group_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_group_int32_set = true;
          break;
        case 'group_uint32': case 'groupUint32':
          $this->group_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          $this->was_group_uint32_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_Data)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasGroupInt32()) {
      $this->setGroupInt32($o->getGroupInt32());
    }
    if ($o->hasGroupUint32()) {
      $this->setGroupUint32($o->getGroupUint32());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MultiWordGroupField implements \Protobuf\Message {
  private int $group_int32;
  private bool $was_group_int32_set;
  private int $group_uint32;
  private bool $was_group_uint32_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'group_int32' => int,
    ?'group_uint32' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'group_int32')) {
      $this->group_int32 = $s['group_int32'];
      $this->was_group_int32_set = true;
    } else {
      $this->group_int32 = 0;
      $this->was_group_int32_set = false;
    }
    if (Shapes::keyExists($s, 'group_uint32')) {
      $this->group_uint32 = $s['group_uint32'];
      $this->was_group_uint32_set = true;
    } else {
      $this->group_uint32 = 0;
      $this->was_group_uint32_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getGroupInt32(): int {
    return $this->group_int32;
  }

  public function setGroupInt32(int $v): void {
    $this->group_int32 = $v;
    $this->was_group_int32_set = true;
  }

  public function hasGroupInt32(): bool {
    return $this->was_group_int32_set;
  }

  public function getGroupUint32(): int {
    return $this->group_uint32;
  }

  public function setGroupUint32(int $v): void {
    $this->group_uint32 = $v;
    $this->was_group_uint32_set = true;
  }

  public function hasGroupUint32(): bool {
    return $this->was_group_uint32_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MultiWordGroupField";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MultiWordGroupField {
    $msg = new TestAllTypesProto2_MultiWordGroupField();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 205:
          $this->group_int32 = $d->readVarint32Signed();
          $this->was_group_int32_set = true;
          break;
        case 206:
          $this->group_uint32 = $d->readVarint32();
          $this->was_group_uint32_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_group_int32_set) {
      $e->writeTag(205, 0);
      $e->writeVarint($this->group_int32);
    }
    if ($this->was_group_uint32_set) {
      $e->writeTag(206, 0);
      $e->writeVarint($this->group_uint32);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasGroupInt32()) {
      $e->writeInt32('group_int32', 'groupInt32', $this->group_int32, false);
    }
    if ($this->hasGroupUint32()) {
      $e->writeInt32('group_uint32', 'groupUint32', $this->group_uint32, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'group_int32': case 'groupInt32':
          $this->group_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_group_int32_set = true;
          break;
        case 'group_uint32': case 'groupUint32':
          $this->group_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          $this->was_group_uint32_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MultiWordGroupField)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasGroupInt32()) {
      $this->setGroupInt32($o->getGroupInt32());
    }
    if ($o->hasGroupUint32()) {
      $this->setGroupUint32($o->getGroupUint32());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MessageSetCorrect implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MessageSetCorrect";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MessageSetCorrect {
    $msg = new TestAllTypesProto2_MessageSetCorrect();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MessageSetCorrect)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MessageSetCorrectExtension1 implements \Protobuf\Message {
  private string $str;
  private bool $was_str_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'str' => string,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'str')) {
      $this->str = $s['str'];
      $this->was_str_set = true;
    } else {
      $this->str = '';
      $this->was_str_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getStr(): string {
    return $this->str;
  }

  public function setStr(string $v): void {
    $this->str = $v;
    $this->was_str_set = true;
  }

  public function hasStr(): bool {
    return $this->was_str_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MessageSetCorrectExtension1";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MessageSetCorrectExtension1 {
    $msg = new TestAllTypesProto2_MessageSetCorrectExtension1();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 25:
          $this->str = $d->readString();
          $this->was_str_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_str_set) {
      $e->writeTag(25, 2);
      $e->writeString($this->str);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasStr()) {
      $e->writeString('str', 'str', $this->str, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'str':
          $this->str = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_str_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MessageSetCorrectExtension1)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasStr()) {
      $this->setStr($o->getStr());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MessageSetCorrectExtension2 implements \Protobuf\Message {
  private int $i;
  private bool $was_i_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'i' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'i')) {
      $this->i = $s['i'];
      $this->was_i_set = true;
    } else {
      $this->i = 0;
      $this->was_i_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getI(): int {
    return $this->i;
  }

  public function setI(int $v): void {
    $this->i = $v;
    $this->was_i_set = true;
  }

  public function hasI(): bool {
    return $this->was_i_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MessageSetCorrectExtension2";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MessageSetCorrectExtension2 {
    $msg = new TestAllTypesProto2_MessageSetCorrectExtension2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 9:
          $this->i = $d->readVarint32Signed();
          $this->was_i_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_i_set) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->i);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasI()) {
      $e->writeInt32('i', 'i', $this->i, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'i':
          $this->i = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_i_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MessageSetCorrectExtension2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasI()) {
      $this->setI($o->getI());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

enum TestAllTypesProto2_ExtensionWithOneof_oneof_field_oneof_t: int {
  NOT_SET = 0;
  a = 1;
  b = 2;
}

interface TestAllTypesProto2_ExtensionWithOneof_oneof_field {
  public function WhichOneof(): TestAllTypesProto2_ExtensionWithOneof_oneof_field_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): TestAllTypesProto2_ExtensionWithOneof_oneof_field;
}

class TestAllTypesProto2_ExtensionWithOneof_oneof_field_NOT_SET implements TestAllTypesProto2_ExtensionWithOneof_oneof_field {
  public function WhichOneof(): TestAllTypesProto2_ExtensionWithOneof_oneof_field_oneof_t {
    return TestAllTypesProto2_ExtensionWithOneof_oneof_field_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): TestAllTypesProto2_ExtensionWithOneof_oneof_field { return $this; }
}

class TestAllTypesProto2_ExtensionWithOneof_oneof_field_a implements TestAllTypesProto2_ExtensionWithOneof_oneof_field {
  public function __construct(public int $a) {}

  public function WhichOneof(): TestAllTypesProto2_ExtensionWithOneof_oneof_field_oneof_t {
    return TestAllTypesProto2_ExtensionWithOneof_oneof_field_oneof_t::a;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(1, 0);;
    $e->writeVarint($this->a);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('a', 'a', $this->a, true);
  }

  public function Copy(): TestAllTypesProto2_ExtensionWithOneof_oneof_field {
    return new TestAllTypesProto2_ExtensionWithOneof_oneof_field_a($this->a);
  }
}

class TestAllTypesProto2_ExtensionWithOneof_oneof_field_b implements TestAllTypesProto2_ExtensionWithOneof_oneof_field {
  public function __construct(public int $b) {}

  public function WhichOneof(): TestAllTypesProto2_ExtensionWithOneof_oneof_field_oneof_t {
    return TestAllTypesProto2_ExtensionWithOneof_oneof_field_oneof_t::b;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(2, 0);;
    $e->writeVarint($this->b);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('b', 'b', $this->b, true);
  }

  public function Copy(): TestAllTypesProto2_ExtensionWithOneof_oneof_field {
    return new TestAllTypesProto2_ExtensionWithOneof_oneof_field_b($this->b);
  }
}

class TestAllTypesProto2_ExtensionWithOneof implements \Protobuf\Message {
  public TestAllTypesProto2_ExtensionWithOneof_oneof_field $oneof_field;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'oneof_field' => TestAllTypesProto2_ExtensionWithOneof_oneof_field,
  ) $s = shape()) {
    $this->oneof_field = $s['oneof_field'] ?? new TestAllTypesProto2_ExtensionWithOneof_oneof_field_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.ExtensionWithOneof";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_ExtensionWithOneof {
    $msg = new TestAllTypesProto2_ExtensionWithOneof();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->oneof_field = new TestAllTypesProto2_ExtensionWithOneof_oneof_field_a($d->readVarint32Signed());
          break;
        case 2:
          $this->oneof_field = new TestAllTypesProto2_ExtensionWithOneof_oneof_field_b($d->readVarint32Signed());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $this->oneof_field->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $this->oneof_field->WriteJsonTo($e);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'a':
          $this->oneof_field = new TestAllTypesProto2_ExtensionWithOneof_oneof_field_a(\Protobuf\Internal\JsonDecoder::readInt32Signed($v));
          break;
        case 'b':
          $this->oneof_field = new TestAllTypesProto2_ExtensionWithOneof_oneof_field_b(\Protobuf\Internal\JsonDecoder::readInt32Signed($v));
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_ExtensionWithOneof)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->oneof_field = $o->oneof_field->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2 implements \Protobuf\Message {
  private int $optional_int32;
  private bool $was_optional_int32_set;
  private int $optional_int64;
  private bool $was_optional_int64_set;
  private int $optional_uint32;
  private bool $was_optional_uint32_set;
  private int $optional_uint64;
  private bool $was_optional_uint64_set;
  private int $optional_sint32;
  private bool $was_optional_sint32_set;
  private int $optional_sint64;
  private bool $was_optional_sint64_set;
  private int $optional_fixed32;
  private bool $was_optional_fixed32_set;
  private int $optional_fixed64;
  private bool $was_optional_fixed64_set;
  private int $optional_sfixed32;
  private bool $was_optional_sfixed32_set;
  private int $optional_sfixed64;
  private bool $was_optional_sfixed64_set;
  private float $optional_float;
  private bool $was_optional_float_set;
  private float $optional_double;
  private bool $was_optional_double_set;
  private bool $optional_bool;
  private bool $was_optional_bool_set;
  private string $optional_string;
  private bool $was_optional_string_set;
  private string $optional_bytes;
  private bool $was_optional_bytes_set;
  private ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $optional_nested_message;
  private bool $was_optional_nested_message_set;
  private ?\protobuf_test_messages\proto2\ForeignMessageProto2 $optional_foreign_message;
  private bool $was_optional_foreign_message_set;
  private \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t $optional_nested_enum;
  private bool $was_optional_nested_enum_set;
  private \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t $optional_foreign_enum;
  private bool $was_optional_foreign_enum_set;
  private string $optional_string_piece;
  private bool $was_optional_string_piece_set;
  private string $optional_cord;
  private bool $was_optional_cord_set;
  private ?\protobuf_test_messages\proto2\TestAllTypesProto2 $recursive_message;
  private bool $was_recursive_message_set;
  public vec<int> $repeated_int32;
  public vec<int> $repeated_int64;
  public vec<int> $repeated_uint32;
  public vec<int> $repeated_uint64;
  public vec<int> $repeated_sint32;
  public vec<int> $repeated_sint64;
  public vec<int> $repeated_fixed32;
  public vec<int> $repeated_fixed64;
  public vec<int> $repeated_sfixed32;
  public vec<int> $repeated_sfixed64;
  public vec<float> $repeated_float;
  public vec<float> $repeated_double;
  public vec<bool> $repeated_bool;
  public vec<string> $repeated_string;
  public vec<string> $repeated_bytes;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage> $repeated_nested_message;
  public vec<\protobuf_test_messages\proto2\ForeignMessageProto2> $repeated_foreign_message;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $repeated_nested_enum;
  public vec<\protobuf_test_messages\proto2\ForeignEnumProto2_enum_t> $repeated_foreign_enum;
  public vec<string> $repeated_string_piece;
  public vec<string> $repeated_cord;
  public vec<int> $packed_int32;
  public vec<int> $packed_int64;
  public vec<int> $packed_uint32;
  public vec<int> $packed_uint64;
  public vec<int> $packed_sint32;
  public vec<int> $packed_sint64;
  public vec<int> $packed_fixed32;
  public vec<int> $packed_fixed64;
  public vec<int> $packed_sfixed32;
  public vec<int> $packed_sfixed64;
  public vec<float> $packed_float;
  public vec<float> $packed_double;
  public vec<bool> $packed_bool;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $packed_nested_enum;
  public vec<int> $unpacked_int32;
  public vec<int> $unpacked_int64;
  public vec<int> $unpacked_uint32;
  public vec<int> $unpacked_uint64;
  public vec<int> $unpacked_sint32;
  public vec<int> $unpacked_sint64;
  public vec<int> $unpacked_fixed32;
  public vec<int> $unpacked_fixed64;
  public vec<int> $unpacked_sfixed32;
  public vec<int> $unpacked_sfixed64;
  public vec<float> $unpacked_float;
  public vec<float> $unpacked_double;
  public vec<bool> $unpacked_bool;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $unpacked_nested_enum;
  public dict<int, int> $map_int32_int32;
  public dict<int, int> $map_int64_int64;
  public dict<int, int> $map_uint32_uint32;
  public dict<int, int> $map_uint64_uint64;
  public dict<int, int> $map_sint32_sint32;
  public dict<int, int> $map_sint64_sint64;
  public dict<int, int> $map_fixed32_fixed32;
  public dict<int, int> $map_fixed64_fixed64;
  public dict<int, int> $map_sfixed32_sfixed32;
  public dict<int, int> $map_sfixed64_sfixed64;
  public dict<int, bool> $map_int32_bool;
  public dict<int, float> $map_int32_float;
  public dict<int, float> $map_int32_double;
  public dict<int, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage> $map_int32_nested_message;
  public dict<\Protobuf\Internal\bool_map_key_t, bool> $map_bool_bool;
  public dict<string, string> $map_string_string;
  public dict<string, string> $map_string_bytes;
  public dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage> $map_string_nested_message;
  public dict<string, \protobuf_test_messages\proto2\ForeignMessageProto2> $map_string_foreign_message;
  public dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $map_string_nested_enum;
  public dict<string, \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t> $map_string_foreign_enum;
  private ?\protobuf_test_messages\proto2\TestAllTypesProto2_Data $data;
  private bool $was_data_set;
  private ?\protobuf_test_messages\proto2\TestAllTypesProto2_MultiWordGroupField $multiwordgroupfield;
  private bool $was_multiwordgroupfield_set;
  private int $default_int32;
  private bool $was_default_int32_set;
  private int $default_int64;
  private bool $was_default_int64_set;
  private int $default_uint32;
  private bool $was_default_uint32_set;
  private int $default_uint64;
  private bool $was_default_uint64_set;
  private int $default_sint32;
  private bool $was_default_sint32_set;
  private int $default_sint64;
  private bool $was_default_sint64_set;
  private int $default_fixed32;
  private bool $was_default_fixed32_set;
  private int $default_fixed64;
  private bool $was_default_fixed64_set;
  private int $default_sfixed32;
  private bool $was_default_sfixed32_set;
  private int $default_sfixed64;
  private bool $was_default_sfixed64_set;
  private float $default_float;
  private bool $was_default_float_set;
  private float $default_double;
  private bool $was_default_double_set;
  private bool $default_bool;
  private bool $was_default_bool_set;
  private string $default_string;
  private bool $was_default_string_set;
  private string $default_bytes;
  private bool $was_default_bytes_set;
  private int $fieldname1;
  private bool $was_fieldname1_set;
  private int $field_name2;
  private bool $was_field_name2_set;
  private int $_field_name3;
  private bool $was__field_name3_set;
  private int $field__name4_;
  private bool $was_field__name4__set;
  private int $field0name5;
  private bool $was_field0name5_set;
  private int $field_0_name6;
  private bool $was_field_0_name6_set;
  private int $fieldName7;
  private bool $was_fieldName7_set;
  private int $FieldName8;
  private bool $was_FieldName8_set;
  private int $field_Name9;
  private bool $was_field_Name9_set;
  private int $Field_Name10;
  private bool $was_Field_Name10_set;
  private int $FIELD_NAME11;
  private bool $was_FIELD_NAME11_set;
  private int $FIELD_name12;
  private bool $was_FIELD_name12_set;
  private int $__field_name13;
  private bool $was___field_name13_set;
  private int $__Field_name14;
  private bool $was___Field_name14_set;
  private int $field__name15;
  private bool $was_field__name15_set;
  private int $field__Name16;
  private bool $was_field__Name16_set;
  private int $field_name17__;
  private bool $was_field_name17___set;
  private int $Field_name18__;
  private bool $was_Field_name18___set;
  private ?\protobuf_test_messages\proto2\TestAllTypesProto2_MessageSetCorrect $message_set_correct;
  private bool $was_message_set_correct_set;
  public TestAllTypesProto2_oneof_field $oneof_field;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'optional_int32' => int,
    ?'optional_int64' => int,
    ?'optional_uint32' => int,
    ?'optional_uint64' => int,
    ?'optional_sint32' => int,
    ?'optional_sint64' => int,
    ?'optional_fixed32' => int,
    ?'optional_fixed64' => int,
    ?'optional_sfixed32' => int,
    ?'optional_sfixed64' => int,
    ?'optional_float' => float,
    ?'optional_double' => float,
    ?'optional_bool' => bool,
    ?'optional_string' => string,
    ?'optional_bytes' => string,
    ?'optional_nested_message' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage,
    ?'optional_foreign_message' => ?\protobuf_test_messages\proto2\ForeignMessageProto2,
    ?'optional_nested_enum' => \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t,
    ?'optional_foreign_enum' => \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t,
    ?'optional_string_piece' => string,
    ?'optional_cord' => string,
    ?'recursive_message' => ?\protobuf_test_messages\proto2\TestAllTypesProto2,
    ?'repeated_int32' => vec<int>,
    ?'repeated_int64' => vec<int>,
    ?'repeated_uint32' => vec<int>,
    ?'repeated_uint64' => vec<int>,
    ?'repeated_sint32' => vec<int>,
    ?'repeated_sint64' => vec<int>,
    ?'repeated_fixed32' => vec<int>,
    ?'repeated_fixed64' => vec<int>,
    ?'repeated_sfixed32' => vec<int>,
    ?'repeated_sfixed64' => vec<int>,
    ?'repeated_float' => vec<float>,
    ?'repeated_double' => vec<float>,
    ?'repeated_bool' => vec<bool>,
    ?'repeated_string' => vec<string>,
    ?'repeated_bytes' => vec<string>,
    ?'repeated_nested_message' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage>,
    ?'repeated_foreign_message' => vec<\protobuf_test_messages\proto2\ForeignMessageProto2>,
    ?'repeated_nested_enum' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'repeated_foreign_enum' => vec<\protobuf_test_messages\proto2\ForeignEnumProto2_enum_t>,
    ?'repeated_string_piece' => vec<string>,
    ?'repeated_cord' => vec<string>,
    ?'packed_int32' => vec<int>,
    ?'packed_int64' => vec<int>,
    ?'packed_uint32' => vec<int>,
    ?'packed_uint64' => vec<int>,
    ?'packed_sint32' => vec<int>,
    ?'packed_sint64' => vec<int>,
    ?'packed_fixed32' => vec<int>,
    ?'packed_fixed64' => vec<int>,
    ?'packed_sfixed32' => vec<int>,
    ?'packed_sfixed64' => vec<int>,
    ?'packed_float' => vec<float>,
    ?'packed_double' => vec<float>,
    ?'packed_bool' => vec<bool>,
    ?'packed_nested_enum' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'unpacked_int32' => vec<int>,
    ?'unpacked_int64' => vec<int>,
    ?'unpacked_uint32' => vec<int>,
    ?'unpacked_uint64' => vec<int>,
    ?'unpacked_sint32' => vec<int>,
    ?'unpacked_sint64' => vec<int>,
    ?'unpacked_fixed32' => vec<int>,
    ?'unpacked_fixed64' => vec<int>,
    ?'unpacked_sfixed32' => vec<int>,
    ?'unpacked_sfixed64' => vec<int>,
    ?'unpacked_float' => vec<float>,
    ?'unpacked_double' => vec<float>,
    ?'unpacked_bool' => vec<bool>,
    ?'unpacked_nested_enum' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'map_int32_int32' => dict<int, int>,
    ?'map_int64_int64' => dict<int, int>,
    ?'map_uint32_uint32' => dict<int, int>,
    ?'map_uint64_uint64' => dict<int, int>,
    ?'map_sint32_sint32' => dict<int, int>,
    ?'map_sint64_sint64' => dict<int, int>,
    ?'map_fixed32_fixed32' => dict<int, int>,
    ?'map_fixed64_fixed64' => dict<int, int>,
    ?'map_sfixed32_sfixed32' => dict<int, int>,
    ?'map_sfixed64_sfixed64' => dict<int, int>,
    ?'map_int32_bool' => dict<int, bool>,
    ?'map_int32_float' => dict<int, float>,
    ?'map_int32_double' => dict<int, float>,
    ?'map_int32_nested_message' => dict<int, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage>,
    ?'map_bool_bool' => dict<\Protobuf\Internal\bool_map_key_t, bool>,
    ?'map_string_string' => dict<string, string>,
    ?'map_string_bytes' => dict<string, string>,
    ?'map_string_nested_message' => dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage>,
    ?'map_string_foreign_message' => dict<string, \protobuf_test_messages\proto2\ForeignMessageProto2>,
    ?'map_string_nested_enum' => dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'map_string_foreign_enum' => dict<string, \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t>,
    ?'data' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_Data,
    ?'multiwordgroupfield' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_MultiWordGroupField,
    ?'default_int32' => int,
    ?'default_int64' => int,
    ?'default_uint32' => int,
    ?'default_uint64' => int,
    ?'default_sint32' => int,
    ?'default_sint64' => int,
    ?'default_fixed32' => int,
    ?'default_fixed64' => int,
    ?'default_sfixed32' => int,
    ?'default_sfixed64' => int,
    ?'default_float' => float,
    ?'default_double' => float,
    ?'default_bool' => bool,
    ?'default_string' => string,
    ?'default_bytes' => string,
    ?'fieldname1' => int,
    ?'field_name2' => int,
    ?'_field_name3' => int,
    ?'field__name4_' => int,
    ?'field0name5' => int,
    ?'field_0_name6' => int,
    ?'fieldName7' => int,
    ?'FieldName8' => int,
    ?'field_Name9' => int,
    ?'Field_Name10' => int,
    ?'FIELD_NAME11' => int,
    ?'FIELD_name12' => int,
    ?'__field_name13' => int,
    ?'__Field_name14' => int,
    ?'field__name15' => int,
    ?'field__Name16' => int,
    ?'field_name17__' => int,
    ?'Field_name18__' => int,
    ?'message_set_correct' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_MessageSetCorrect,
    ?'oneof_field' => TestAllTypesProto2_oneof_field,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'optional_int32')) {
      $this->optional_int32 = $s['optional_int32'];
      $this->was_optional_int32_set = true;
    } else {
      $this->optional_int32 = 0;
      $this->was_optional_int32_set = false;
    }
    if (Shapes::keyExists($s, 'optional_int64')) {
      $this->optional_int64 = $s['optional_int64'];
      $this->was_optional_int64_set = true;
    } else {
      $this->optional_int64 = 0;
      $this->was_optional_int64_set = false;
    }
    if (Shapes::keyExists($s, 'optional_uint32')) {
      $this->optional_uint32 = $s['optional_uint32'];
      $this->was_optional_uint32_set = true;
    } else {
      $this->optional_uint32 = 0;
      $this->was_optional_uint32_set = false;
    }
    if (Shapes::keyExists($s, 'optional_uint64')) {
      $this->optional_uint64 = $s['optional_uint64'];
      $this->was_optional_uint64_set = true;
    } else {
      $this->optional_uint64 = 0;
      $this->was_optional_uint64_set = false;
    }
    if (Shapes::keyExists($s, 'optional_sint32')) {
      $this->optional_sint32 = $s['optional_sint32'];
      $this->was_optional_sint32_set = true;
    } else {
      $this->optional_sint32 = 0;
      $this->was_optional_sint32_set = false;
    }
    if (Shapes::keyExists($s, 'optional_sint64')) {
      $this->optional_sint64 = $s['optional_sint64'];
      $this->was_optional_sint64_set = true;
    } else {
      $this->optional_sint64 = 0;
      $this->was_optional_sint64_set = false;
    }
    if (Shapes::keyExists($s, 'optional_fixed32')) {
      $this->optional_fixed32 = $s['optional_fixed32'];
      $this->was_optional_fixed32_set = true;
    } else {
      $this->optional_fixed32 = 0;
      $this->was_optional_fixed32_set = false;
    }
    if (Shapes::keyExists($s, 'optional_fixed64')) {
      $this->optional_fixed64 = $s['optional_fixed64'];
      $this->was_optional_fixed64_set = true;
    } else {
      $this->optional_fixed64 = 0;
      $this->was_optional_fixed64_set = false;
    }
    if (Shapes::keyExists($s, 'optional_sfixed32')) {
      $this->optional_sfixed32 = $s['optional_sfixed32'];
      $this->was_optional_sfixed32_set = true;
    } else {
      $this->optional_sfixed32 = 0;
      $this->was_optional_sfixed32_set = false;
    }
    if (Shapes::keyExists($s, 'optional_sfixed64')) {
      $this->optional_sfixed64 = $s['optional_sfixed64'];
      $this->was_optional_sfixed64_set = true;
    } else {
      $this->optional_sfixed64 = 0;
      $this->was_optional_sfixed64_set = false;
    }
    if (Shapes::keyExists($s, 'optional_float')) {
      $this->optional_float = $s['optional_float'];
      $this->was_optional_float_set = true;
    } else {
      $this->optional_float = 0.0;
      $this->was_optional_float_set = false;
    }
    if (Shapes::keyExists($s, 'optional_double')) {
      $this->optional_double = $s['optional_double'];
      $this->was_optional_double_set = true;
    } else {
      $this->optional_double = 0.0;
      $this->was_optional_double_set = false;
    }
    if (Shapes::keyExists($s, 'optional_bool')) {
      $this->optional_bool = $s['optional_bool'];
      $this->was_optional_bool_set = true;
    } else {
      $this->optional_bool = false;
      $this->was_optional_bool_set = false;
    }
    if (Shapes::keyExists($s, 'optional_string')) {
      $this->optional_string = $s['optional_string'];
      $this->was_optional_string_set = true;
    } else {
      $this->optional_string = '';
      $this->was_optional_string_set = false;
    }
    if (Shapes::keyExists($s, 'optional_bytes')) {
      $this->optional_bytes = $s['optional_bytes'];
      $this->was_optional_bytes_set = true;
    } else {
      $this->optional_bytes = '';
      $this->was_optional_bytes_set = false;
    }
    if (Shapes::keyExists($s, 'optional_nested_message')) {
      $this->optional_nested_message = $s['optional_nested_message'];
      $this->was_optional_nested_message_set = true;
    } else {
      $this->optional_nested_message = null;
      $this->was_optional_nested_message_set = false;
    }
    if (Shapes::keyExists($s, 'optional_foreign_message')) {
      $this->optional_foreign_message = $s['optional_foreign_message'];
      $this->was_optional_foreign_message_set = true;
    } else {
      $this->optional_foreign_message = null;
      $this->was_optional_foreign_message_set = false;
    }
    if (Shapes::keyExists($s, 'optional_nested_enum')) {
      $this->optional_nested_enum = $s['optional_nested_enum'];
      $this->was_optional_nested_enum_set = true;
    } else {
      $this->optional_nested_enum = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FOO;
      $this->was_optional_nested_enum_set = false;
    }
    if (Shapes::keyExists($s, 'optional_foreign_enum')) {
      $this->optional_foreign_enum = $s['optional_foreign_enum'];
      $this->was_optional_foreign_enum_set = true;
    } else {
      $this->optional_foreign_enum = \protobuf_test_messages\proto2\ForeignEnumProto2::FOREIGN_FOO;
      $this->was_optional_foreign_enum_set = false;
    }
    if (Shapes::keyExists($s, 'optional_string_piece')) {
      $this->optional_string_piece = $s['optional_string_piece'];
      $this->was_optional_string_piece_set = true;
    } else {
      $this->optional_string_piece = '';
      $this->was_optional_string_piece_set = false;
    }
    if (Shapes::keyExists($s, 'optional_cord')) {
      $this->optional_cord = $s['optional_cord'];
      $this->was_optional_cord_set = true;
    } else {
      $this->optional_cord = '';
      $this->was_optional_cord_set = false;
    }
    if (Shapes::keyExists($s, 'recursive_message')) {
      $this->recursive_message = $s['recursive_message'];
      $this->was_recursive_message_set = true;
    } else {
      $this->recursive_message = null;
      $this->was_recursive_message_set = false;
    }
    $this->repeated_int32 = $s['repeated_int32'] ?? vec[];
    $this->repeated_int64 = $s['repeated_int64'] ?? vec[];
    $this->repeated_uint32 = $s['repeated_uint32'] ?? vec[];
    $this->repeated_uint64 = $s['repeated_uint64'] ?? vec[];
    $this->repeated_sint32 = $s['repeated_sint32'] ?? vec[];
    $this->repeated_sint64 = $s['repeated_sint64'] ?? vec[];
    $this->repeated_fixed32 = $s['repeated_fixed32'] ?? vec[];
    $this->repeated_fixed64 = $s['repeated_fixed64'] ?? vec[];
    $this->repeated_sfixed32 = $s['repeated_sfixed32'] ?? vec[];
    $this->repeated_sfixed64 = $s['repeated_sfixed64'] ?? vec[];
    $this->repeated_float = $s['repeated_float'] ?? vec[];
    $this->repeated_double = $s['repeated_double'] ?? vec[];
    $this->repeated_bool = $s['repeated_bool'] ?? vec[];
    $this->repeated_string = $s['repeated_string'] ?? vec[];
    $this->repeated_bytes = $s['repeated_bytes'] ?? vec[];
    $this->repeated_nested_message = $s['repeated_nested_message'] ?? vec[];
    $this->repeated_foreign_message = $s['repeated_foreign_message'] ?? vec[];
    $this->repeated_nested_enum = $s['repeated_nested_enum'] ?? vec[];
    $this->repeated_foreign_enum = $s['repeated_foreign_enum'] ?? vec[];
    $this->repeated_string_piece = $s['repeated_string_piece'] ?? vec[];
    $this->repeated_cord = $s['repeated_cord'] ?? vec[];
    $this->packed_int32 = $s['packed_int32'] ?? vec[];
    $this->packed_int64 = $s['packed_int64'] ?? vec[];
    $this->packed_uint32 = $s['packed_uint32'] ?? vec[];
    $this->packed_uint64 = $s['packed_uint64'] ?? vec[];
    $this->packed_sint32 = $s['packed_sint32'] ?? vec[];
    $this->packed_sint64 = $s['packed_sint64'] ?? vec[];
    $this->packed_fixed32 = $s['packed_fixed32'] ?? vec[];
    $this->packed_fixed64 = $s['packed_fixed64'] ?? vec[];
    $this->packed_sfixed32 = $s['packed_sfixed32'] ?? vec[];
    $this->packed_sfixed64 = $s['packed_sfixed64'] ?? vec[];
    $this->packed_float = $s['packed_float'] ?? vec[];
    $this->packed_double = $s['packed_double'] ?? vec[];
    $this->packed_bool = $s['packed_bool'] ?? vec[];
    $this->packed_nested_enum = $s['packed_nested_enum'] ?? vec[];
    $this->unpacked_int32 = $s['unpacked_int32'] ?? vec[];
    $this->unpacked_int64 = $s['unpacked_int64'] ?? vec[];
    $this->unpacked_uint32 = $s['unpacked_uint32'] ?? vec[];
    $this->unpacked_uint64 = $s['unpacked_uint64'] ?? vec[];
    $this->unpacked_sint32 = $s['unpacked_sint32'] ?? vec[];
    $this->unpacked_sint64 = $s['unpacked_sint64'] ?? vec[];
    $this->unpacked_fixed32 = $s['unpacked_fixed32'] ?? vec[];
    $this->unpacked_fixed64 = $s['unpacked_fixed64'] ?? vec[];
    $this->unpacked_sfixed32 = $s['unpacked_sfixed32'] ?? vec[];
    $this->unpacked_sfixed64 = $s['unpacked_sfixed64'] ?? vec[];
    $this->unpacked_float = $s['unpacked_float'] ?? vec[];
    $this->unpacked_double = $s['unpacked_double'] ?? vec[];
    $this->unpacked_bool = $s['unpacked_bool'] ?? vec[];
    $this->unpacked_nested_enum = $s['unpacked_nested_enum'] ?? vec[];
    $this->map_int32_int32 = $s['map_int32_int32'] ?? dict[];
    $this->map_int64_int64 = $s['map_int64_int64'] ?? dict[];
    $this->map_uint32_uint32 = $s['map_uint32_uint32'] ?? dict[];
    $this->map_uint64_uint64 = $s['map_uint64_uint64'] ?? dict[];
    $this->map_sint32_sint32 = $s['map_sint32_sint32'] ?? dict[];
    $this->map_sint64_sint64 = $s['map_sint64_sint64'] ?? dict[];
    $this->map_fixed32_fixed32 = $s['map_fixed32_fixed32'] ?? dict[];
    $this->map_fixed64_fixed64 = $s['map_fixed64_fixed64'] ?? dict[];
    $this->map_sfixed32_sfixed32 = $s['map_sfixed32_sfixed32'] ?? dict[];
    $this->map_sfixed64_sfixed64 = $s['map_sfixed64_sfixed64'] ?? dict[];
    $this->map_int32_bool = $s['map_int32_bool'] ?? dict[];
    $this->map_int32_float = $s['map_int32_float'] ?? dict[];
    $this->map_int32_double = $s['map_int32_double'] ?? dict[];
    $this->map_int32_nested_message = $s['map_int32_nested_message'] ?? dict[];
    $this->map_bool_bool = $s['map_bool_bool'] ?? dict[];
    $this->map_string_string = $s['map_string_string'] ?? dict[];
    $this->map_string_bytes = $s['map_string_bytes'] ?? dict[];
    $this->map_string_nested_message = $s['map_string_nested_message'] ?? dict[];
    $this->map_string_foreign_message = $s['map_string_foreign_message'] ?? dict[];
    $this->map_string_nested_enum = $s['map_string_nested_enum'] ?? dict[];
    $this->map_string_foreign_enum = $s['map_string_foreign_enum'] ?? dict[];
    if (Shapes::keyExists($s, 'data')) {
      $this->data = $s['data'];
      $this->was_data_set = true;
    } else {
      $this->data = null;
      $this->was_data_set = false;
    }
    if (Shapes::keyExists($s, 'multiwordgroupfield')) {
      $this->multiwordgroupfield = $s['multiwordgroupfield'];
      $this->was_multiwordgroupfield_set = true;
    } else {
      $this->multiwordgroupfield = null;
      $this->was_multiwordgroupfield_set = false;
    }
    if (Shapes::keyExists($s, 'default_int32')) {
      $this->default_int32 = $s['default_int32'];
      $this->was_default_int32_set = true;
    } else {
      $this->default_int32 = -123456789;
      $this->was_default_int32_set = false;
    }
    if (Shapes::keyExists($s, 'default_int64')) {
      $this->default_int64 = $s['default_int64'];
      $this->was_default_int64_set = true;
    } else {
      $this->default_int64 = -9123456789123456789;
      $this->was_default_int64_set = false;
    }
    if (Shapes::keyExists($s, 'default_uint32')) {
      $this->default_uint32 = $s['default_uint32'];
      $this->was_default_uint32_set = true;
    } else {
      $this->default_uint32 = 2123456789;
      $this->was_default_uint32_set = false;
    }
    if (Shapes::keyExists($s, 'default_uint64')) {
      $this->default_uint64 = $s['default_uint64'];
      $this->was_default_uint64_set = true;
    } else {
      $this->default_uint64 = -8323287284586094827;
      $this->was_default_uint64_set = false;
    }
    if (Shapes::keyExists($s, 'default_sint32')) {
      $this->default_sint32 = $s['default_sint32'];
      $this->was_default_sint32_set = true;
    } else {
      $this->default_sint32 = -123456789;
      $this->was_default_sint32_set = false;
    }
    if (Shapes::keyExists($s, 'default_sint64')) {
      $this->default_sint64 = $s['default_sint64'];
      $this->was_default_sint64_set = true;
    } else {
      $this->default_sint64 = -9123456789123456789;
      $this->was_default_sint64_set = false;
    }
    if (Shapes::keyExists($s, 'default_fixed32')) {
      $this->default_fixed32 = $s['default_fixed32'];
      $this->was_default_fixed32_set = true;
    } else {
      $this->default_fixed32 = 2123456789;
      $this->was_default_fixed32_set = false;
    }
    if (Shapes::keyExists($s, 'default_fixed64')) {
      $this->default_fixed64 = $s['default_fixed64'];
      $this->was_default_fixed64_set = true;
    } else {
      $this->default_fixed64 = -8323287284586094827;
      $this->was_default_fixed64_set = false;
    }
    if (Shapes::keyExists($s, 'default_sfixed32')) {
      $this->default_sfixed32 = $s['default_sfixed32'];
      $this->was_default_sfixed32_set = true;
    } else {
      $this->default_sfixed32 = -123456789;
      $this->was_default_sfixed32_set = false;
    }
    if (Shapes::keyExists($s, 'default_sfixed64')) {
      $this->default_sfixed64 = $s['default_sfixed64'];
      $this->was_default_sfixed64_set = true;
    } else {
      $this->default_sfixed64 = -9123456789123456789;
      $this->was_default_sfixed64_set = false;
    }
    if (Shapes::keyExists($s, 'default_float')) {
      $this->default_float = $s['default_float'];
      $this->was_default_float_set = true;
    } else {
      $this->default_float = (float)9e+09;
      $this->was_default_float_set = false;
    }
    if (Shapes::keyExists($s, 'default_double')) {
      $this->default_double = $s['default_double'];
      $this->was_default_double_set = true;
    } else {
      $this->default_double = (float)7e+22;
      $this->was_default_double_set = false;
    }
    if (Shapes::keyExists($s, 'default_bool')) {
      $this->default_bool = $s['default_bool'];
      $this->was_default_bool_set = true;
    } else {
      $this->default_bool = true;
      $this->was_default_bool_set = false;
    }
    if (Shapes::keyExists($s, 'default_string')) {
      $this->default_string = $s['default_string'];
      $this->was_default_string_set = true;
    } else {
      $this->default_string = 'Rosebud';
      $this->was_default_string_set = false;
    }
    if (Shapes::keyExists($s, 'default_bytes')) {
      $this->default_bytes = $s['default_bytes'];
      $this->was_default_bytes_set = true;
    } else {
      $this->default_bytes = \stripcslashes('joshua');
      $this->was_default_bytes_set = false;
    }
    if (Shapes::keyExists($s, 'fieldname1')) {
      $this->fieldname1 = $s['fieldname1'];
      $this->was_fieldname1_set = true;
    } else {
      $this->fieldname1 = 0;
      $this->was_fieldname1_set = false;
    }
    if (Shapes::keyExists($s, 'field_name2')) {
      $this->field_name2 = $s['field_name2'];
      $this->was_field_name2_set = true;
    } else {
      $this->field_name2 = 0;
      $this->was_field_name2_set = false;
    }
    if (Shapes::keyExists($s, '_field_name3')) {
      $this->_field_name3 = $s['_field_name3'];
      $this->was__field_name3_set = true;
    } else {
      $this->_field_name3 = 0;
      $this->was__field_name3_set = false;
    }
    if (Shapes::keyExists($s, 'field__name4_')) {
      $this->field__name4_ = $s['field__name4_'];
      $this->was_field__name4__set = true;
    } else {
      $this->field__name4_ = 0;
      $this->was_field__name4__set = false;
    }
    if (Shapes::keyExists($s, 'field0name5')) {
      $this->field0name5 = $s['field0name5'];
      $this->was_field0name5_set = true;
    } else {
      $this->field0name5 = 0;
      $this->was_field0name5_set = false;
    }
    if (Shapes::keyExists($s, 'field_0_name6')) {
      $this->field_0_name6 = $s['field_0_name6'];
      $this->was_field_0_name6_set = true;
    } else {
      $this->field_0_name6 = 0;
      $this->was_field_0_name6_set = false;
    }
    if (Shapes::keyExists($s, 'fieldName7')) {
      $this->fieldName7 = $s['fieldName7'];
      $this->was_fieldName7_set = true;
    } else {
      $this->fieldName7 = 0;
      $this->was_fieldName7_set = false;
    }
    if (Shapes::keyExists($s, 'FieldName8')) {
      $this->FieldName8 = $s['FieldName8'];
      $this->was_FieldName8_set = true;
    } else {
      $this->FieldName8 = 0;
      $this->was_FieldName8_set = false;
    }
    if (Shapes::keyExists($s, 'field_Name9')) {
      $this->field_Name9 = $s['field_Name9'];
      $this->was_field_Name9_set = true;
    } else {
      $this->field_Name9 = 0;
      $this->was_field_Name9_set = false;
    }
    if (Shapes::keyExists($s, 'Field_Name10')) {
      $this->Field_Name10 = $s['Field_Name10'];
      $this->was_Field_Name10_set = true;
    } else {
      $this->Field_Name10 = 0;
      $this->was_Field_Name10_set = false;
    }
    if (Shapes::keyExists($s, 'FIELD_NAME11')) {
      $this->FIELD_NAME11 = $s['FIELD_NAME11'];
      $this->was_FIELD_NAME11_set = true;
    } else {
      $this->FIELD_NAME11 = 0;
      $this->was_FIELD_NAME11_set = false;
    }
    if (Shapes::keyExists($s, 'FIELD_name12')) {
      $this->FIELD_name12 = $s['FIELD_name12'];
      $this->was_FIELD_name12_set = true;
    } else {
      $this->FIELD_name12 = 0;
      $this->was_FIELD_name12_set = false;
    }
    if (Shapes::keyExists($s, '__field_name13')) {
      $this->__field_name13 = $s['__field_name13'];
      $this->was___field_name13_set = true;
    } else {
      $this->__field_name13 = 0;
      $this->was___field_name13_set = false;
    }
    if (Shapes::keyExists($s, '__Field_name14')) {
      $this->__Field_name14 = $s['__Field_name14'];
      $this->was___Field_name14_set = true;
    } else {
      $this->__Field_name14 = 0;
      $this->was___Field_name14_set = false;
    }
    if (Shapes::keyExists($s, 'field__name15')) {
      $this->field__name15 = $s['field__name15'];
      $this->was_field__name15_set = true;
    } else {
      $this->field__name15 = 0;
      $this->was_field__name15_set = false;
    }
    if (Shapes::keyExists($s, 'field__Name16')) {
      $this->field__Name16 = $s['field__Name16'];
      $this->was_field__Name16_set = true;
    } else {
      $this->field__Name16 = 0;
      $this->was_field__Name16_set = false;
    }
    if (Shapes::keyExists($s, 'field_name17__')) {
      $this->field_name17__ = $s['field_name17__'];
      $this->was_field_name17___set = true;
    } else {
      $this->field_name17__ = 0;
      $this->was_field_name17___set = false;
    }
    if (Shapes::keyExists($s, 'Field_name18__')) {
      $this->Field_name18__ = $s['Field_name18__'];
      $this->was_Field_name18___set = true;
    } else {
      $this->Field_name18__ = 0;
      $this->was_Field_name18___set = false;
    }
    if (Shapes::keyExists($s, 'message_set_correct')) {
      $this->message_set_correct = $s['message_set_correct'];
      $this->was_message_set_correct_set = true;
    } else {
      $this->message_set_correct = null;
      $this->was_message_set_correct_set = false;
    }
    $this->oneof_field = $s['oneof_field'] ?? new TestAllTypesProto2_oneof_field_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function getOptionalInt32(): int {
    return $this->optional_int32;
  }

  public function setOptionalInt32(int $v): void {
    $this->optional_int32 = $v;
    $this->was_optional_int32_set = true;
  }

  public function hasOptionalInt32(): bool {
    return $this->was_optional_int32_set;
  }

  public function getOptionalInt64(): int {
    return $this->optional_int64;
  }

  public function setOptionalInt64(int $v): void {
    $this->optional_int64 = $v;
    $this->was_optional_int64_set = true;
  }

  public function hasOptionalInt64(): bool {
    return $this->was_optional_int64_set;
  }

  public function getOptionalUint32(): int {
    return $this->optional_uint32;
  }

  public function setOptionalUint32(int $v): void {
    $this->optional_uint32 = $v;
    $this->was_optional_uint32_set = true;
  }

  public function hasOptionalUint32(): bool {
    return $this->was_optional_uint32_set;
  }

  public function getOptionalUint64(): int {
    return $this->optional_uint64;
  }

  public function setOptionalUint64(int $v): void {
    $this->optional_uint64 = $v;
    $this->was_optional_uint64_set = true;
  }

  public function hasOptionalUint64(): bool {
    return $this->was_optional_uint64_set;
  }

  public function getOptionalSint32(): int {
    return $this->optional_sint32;
  }

  public function setOptionalSint32(int $v): void {
    $this->optional_sint32 = $v;
    $this->was_optional_sint32_set = true;
  }

  public function hasOptionalSint32(): bool {
    return $this->was_optional_sint32_set;
  }

  public function getOptionalSint64(): int {
    return $this->optional_sint64;
  }

  public function setOptionalSint64(int $v): void {
    $this->optional_sint64 = $v;
    $this->was_optional_sint64_set = true;
  }

  public function hasOptionalSint64(): bool {
    return $this->was_optional_sint64_set;
  }

  public function getOptionalFixed32(): int {
    return $this->optional_fixed32;
  }

  public function setOptionalFixed32(int $v): void {
    $this->optional_fixed32 = $v;
    $this->was_optional_fixed32_set = true;
  }

  public function hasOptionalFixed32(): bool {
    return $this->was_optional_fixed32_set;
  }

  public function getOptionalFixed64(): int {
    return $this->optional_fixed64;
  }

  public function setOptionalFixed64(int $v): void {
    $this->optional_fixed64 = $v;
    $this->was_optional_fixed64_set = true;
  }

  public function hasOptionalFixed64(): bool {
    return $this->was_optional_fixed64_set;
  }

  public function getOptionalSfixed32(): int {
    return $this->optional_sfixed32;
  }

  public function setOptionalSfixed32(int $v): void {
    $this->optional_sfixed32 = $v;
    $this->was_optional_sfixed32_set = true;
  }

  public function hasOptionalSfixed32(): bool {
    return $this->was_optional_sfixed32_set;
  }

  public function getOptionalSfixed64(): int {
    return $this->optional_sfixed64;
  }

  public function setOptionalSfixed64(int $v): void {
    $this->optional_sfixed64 = $v;
    $this->was_optional_sfixed64_set = true;
  }

  public function hasOptionalSfixed64(): bool {
    return $this->was_optional_sfixed64_set;
  }

  public function getOptionalFloat(): float {
    return $this->optional_float;
  }

  public function setOptionalFloat(float $v): void {
    $this->optional_float = $v;
    $this->was_optional_float_set = true;
  }

  public function hasOptionalFloat(): bool {
    return $this->was_optional_float_set;
  }

  public function getOptionalDouble(): float {
    return $this->optional_double;
  }

  public function setOptionalDouble(float $v): void {
    $this->optional_double = $v;
    $this->was_optional_double_set = true;
  }

  public function hasOptionalDouble(): bool {
    return $this->was_optional_double_set;
  }

  public function getOptionalBool(): bool {
    return $this->optional_bool;
  }

  public function setOptionalBool(bool $v): void {
    $this->optional_bool = $v;
    $this->was_optional_bool_set = true;
  }

  public function hasOptionalBool(): bool {
    return $this->was_optional_bool_set;
  }

  public function getOptionalString(): string {
    return $this->optional_string;
  }

  public function setOptionalString(string $v): void {
    $this->optional_string = $v;
    $this->was_optional_string_set = true;
  }

  public function hasOptionalString(): bool {
    return $this->was_optional_string_set;
  }

  public function getOptionalBytes(): string {
    return $this->optional_bytes;
  }

  public function setOptionalBytes(string $v): void {
    $this->optional_bytes = $v;
    $this->was_optional_bytes_set = true;
  }

  public function hasOptionalBytes(): bool {
    return $this->was_optional_bytes_set;
  }

  public function getOptionalNestedMessage(): ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage {
    return $this->optional_nested_message;
  }

  public function setOptionalNestedMessage(?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $v): void {
    $this->optional_nested_message = $v;
    $this->was_optional_nested_message_set = true;
  }

  public function hasOptionalNestedMessage(): bool {
    return $this->was_optional_nested_message_set;
  }

  public function getOptionalForeignMessage(): ?\protobuf_test_messages\proto2\ForeignMessageProto2 {
    return $this->optional_foreign_message;
  }

  public function setOptionalForeignMessage(?\protobuf_test_messages\proto2\ForeignMessageProto2 $v): void {
    $this->optional_foreign_message = $v;
    $this->was_optional_foreign_message_set = true;
  }

  public function hasOptionalForeignMessage(): bool {
    return $this->was_optional_foreign_message_set;
  }

  public function getOptionalNestedEnum(): \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t {
    return $this->optional_nested_enum;
  }

  public function setOptionalNestedEnum(\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t $v): void {
    $this->optional_nested_enum = $v;
    $this->was_optional_nested_enum_set = true;
  }

  public function hasOptionalNestedEnum(): bool {
    return $this->was_optional_nested_enum_set;
  }

  public function getOptionalForeignEnum(): \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t {
    return $this->optional_foreign_enum;
  }

  public function setOptionalForeignEnum(\protobuf_test_messages\proto2\ForeignEnumProto2_enum_t $v): void {
    $this->optional_foreign_enum = $v;
    $this->was_optional_foreign_enum_set = true;
  }

  public function hasOptionalForeignEnum(): bool {
    return $this->was_optional_foreign_enum_set;
  }

  public function getOptionalStringPiece(): string {
    return $this->optional_string_piece;
  }

  public function setOptionalStringPiece(string $v): void {
    $this->optional_string_piece = $v;
    $this->was_optional_string_piece_set = true;
  }

  public function hasOptionalStringPiece(): bool {
    return $this->was_optional_string_piece_set;
  }

  public function getOptionalCord(): string {
    return $this->optional_cord;
  }

  public function setOptionalCord(string $v): void {
    $this->optional_cord = $v;
    $this->was_optional_cord_set = true;
  }

  public function hasOptionalCord(): bool {
    return $this->was_optional_cord_set;
  }

  public function getRecursiveMessage(): ?\protobuf_test_messages\proto2\TestAllTypesProto2 {
    return $this->recursive_message;
  }

  public function setRecursiveMessage(?\protobuf_test_messages\proto2\TestAllTypesProto2 $v): void {
    $this->recursive_message = $v;
    $this->was_recursive_message_set = true;
  }

  public function hasRecursiveMessage(): bool {
    return $this->was_recursive_message_set;
  }

  public function getData(): ?\protobuf_test_messages\proto2\TestAllTypesProto2_Data {
    return $this->data;
  }

  public function setData(?\protobuf_test_messages\proto2\TestAllTypesProto2_Data $v): void {
    $this->data = $v;
    $this->was_data_set = true;
  }

  public function hasData(): bool {
    return $this->was_data_set;
  }

  public function getMultiwordgroupfield(): ?\protobuf_test_messages\proto2\TestAllTypesProto2_MultiWordGroupField {
    return $this->multiwordgroupfield;
  }

  public function setMultiwordgroupfield(?\protobuf_test_messages\proto2\TestAllTypesProto2_MultiWordGroupField $v): void {
    $this->multiwordgroupfield = $v;
    $this->was_multiwordgroupfield_set = true;
  }

  public function hasMultiwordgroupfield(): bool {
    return $this->was_multiwordgroupfield_set;
  }

  public function getDefaultInt32(): int {
    return $this->default_int32;
  }

  public function setDefaultInt32(int $v): void {
    $this->default_int32 = $v;
    $this->was_default_int32_set = true;
  }

  public function hasDefaultInt32(): bool {
    return $this->was_default_int32_set;
  }

  public function getDefaultInt64(): int {
    return $this->default_int64;
  }

  public function setDefaultInt64(int $v): void {
    $this->default_int64 = $v;
    $this->was_default_int64_set = true;
  }

  public function hasDefaultInt64(): bool {
    return $this->was_default_int64_set;
  }

  public function getDefaultUint32(): int {
    return $this->default_uint32;
  }

  public function setDefaultUint32(int $v): void {
    $this->default_uint32 = $v;
    $this->was_default_uint32_set = true;
  }

  public function hasDefaultUint32(): bool {
    return $this->was_default_uint32_set;
  }

  public function getDefaultUint64(): int {
    return $this->default_uint64;
  }

  public function setDefaultUint64(int $v): void {
    $this->default_uint64 = $v;
    $this->was_default_uint64_set = true;
  }

  public function hasDefaultUint64(): bool {
    return $this->was_default_uint64_set;
  }

  public function getDefaultSint32(): int {
    return $this->default_sint32;
  }

  public function setDefaultSint32(int $v): void {
    $this->default_sint32 = $v;
    $this->was_default_sint32_set = true;
  }

  public function hasDefaultSint32(): bool {
    return $this->was_default_sint32_set;
  }

  public function getDefaultSint64(): int {
    return $this->default_sint64;
  }

  public function setDefaultSint64(int $v): void {
    $this->default_sint64 = $v;
    $this->was_default_sint64_set = true;
  }

  public function hasDefaultSint64(): bool {
    return $this->was_default_sint64_set;
  }

  public function getDefaultFixed32(): int {
    return $this->default_fixed32;
  }

  public function setDefaultFixed32(int $v): void {
    $this->default_fixed32 = $v;
    $this->was_default_fixed32_set = true;
  }

  public function hasDefaultFixed32(): bool {
    return $this->was_default_fixed32_set;
  }

  public function getDefaultFixed64(): int {
    return $this->default_fixed64;
  }

  public function setDefaultFixed64(int $v): void {
    $this->default_fixed64 = $v;
    $this->was_default_fixed64_set = true;
  }

  public function hasDefaultFixed64(): bool {
    return $this->was_default_fixed64_set;
  }

  public function getDefaultSfixed32(): int {
    return $this->default_sfixed32;
  }

  public function setDefaultSfixed32(int $v): void {
    $this->default_sfixed32 = $v;
    $this->was_default_sfixed32_set = true;
  }

  public function hasDefaultSfixed32(): bool {
    return $this->was_default_sfixed32_set;
  }

  public function getDefaultSfixed64(): int {
    return $this->default_sfixed64;
  }

  public function setDefaultSfixed64(int $v): void {
    $this->default_sfixed64 = $v;
    $this->was_default_sfixed64_set = true;
  }

  public function hasDefaultSfixed64(): bool {
    return $this->was_default_sfixed64_set;
  }

  public function getDefaultFloat(): float {
    return $this->default_float;
  }

  public function setDefaultFloat(float $v): void {
    $this->default_float = $v;
    $this->was_default_float_set = true;
  }

  public function hasDefaultFloat(): bool {
    return $this->was_default_float_set;
  }

  public function getDefaultDouble(): float {
    return $this->default_double;
  }

  public function setDefaultDouble(float $v): void {
    $this->default_double = $v;
    $this->was_default_double_set = true;
  }

  public function hasDefaultDouble(): bool {
    return $this->was_default_double_set;
  }

  public function getDefaultBool(): bool {
    return $this->default_bool;
  }

  public function setDefaultBool(bool $v): void {
    $this->default_bool = $v;
    $this->was_default_bool_set = true;
  }

  public function hasDefaultBool(): bool {
    return $this->was_default_bool_set;
  }

  public function getDefaultString(): string {
    return $this->default_string;
  }

  public function setDefaultString(string $v): void {
    $this->default_string = $v;
    $this->was_default_string_set = true;
  }

  public function hasDefaultString(): bool {
    return $this->was_default_string_set;
  }

  public function getDefaultBytes(): string {
    return $this->default_bytes;
  }

  public function setDefaultBytes(string $v): void {
    $this->default_bytes = $v;
    $this->was_default_bytes_set = true;
  }

  public function hasDefaultBytes(): bool {
    return $this->was_default_bytes_set;
  }

  public function getFieldname1(): int {
    return $this->fieldname1;
  }

  public function setFieldname1(int $v): void {
    $this->fieldname1 = $v;
    $this->was_fieldname1_set = true;
  }

  public function hasFieldname1(): bool {
    return $this->was_fieldname1_set;
  }

  public function getFieldName2(): int {
    return $this->field_name2;
  }

  public function setFieldName2(int $v): void {
    $this->field_name2 = $v;
    $this->was_field_name2_set = true;
  }

  public function hasFieldName2(): bool {
    return $this->was_field_name2_set;
  }

  public function getFieldName3(): int {
    return $this->_field_name3;
  }

  public function setFieldName3(int $v): void {
    $this->_field_name3 = $v;
    $this->was__field_name3_set = true;
  }

  public function hasFieldName3(): bool {
    return $this->was__field_name3_set;
  }

  public function getFieldName4(): int {
    return $this->field__name4_;
  }

  public function setFieldName4(int $v): void {
    $this->field__name4_ = $v;
    $this->was_field__name4__set = true;
  }

  public function hasFieldName4(): bool {
    return $this->was_field__name4__set;
  }

  public function getField0name5(): int {
    return $this->field0name5;
  }

  public function setField0name5(int $v): void {
    $this->field0name5 = $v;
    $this->was_field0name5_set = true;
  }

  public function hasField0name5(): bool {
    return $this->was_field0name5_set;
  }

  public function getField0Name6(): int {
    return $this->field_0_name6;
  }

  public function setField0Name6(int $v): void {
    $this->field_0_name6 = $v;
    $this->was_field_0_name6_set = true;
  }

  public function hasField0Name6(): bool {
    return $this->was_field_0_name6_set;
  }

  public function getFieldName7(): int {
    return $this->fieldName7;
  }

  public function setFieldName7(int $v): void {
    $this->fieldName7 = $v;
    $this->was_fieldName7_set = true;
  }

  public function hasFieldName7(): bool {
    return $this->was_fieldName7_set;
  }

  public function getFieldName8(): int {
    return $this->FieldName8;
  }

  public function setFieldName8(int $v): void {
    $this->FieldName8 = $v;
    $this->was_FieldName8_set = true;
  }

  public function hasFieldName8(): bool {
    return $this->was_FieldName8_set;
  }

  public function getFieldName9(): int {
    return $this->field_Name9;
  }

  public function setFieldName9(int $v): void {
    $this->field_Name9 = $v;
    $this->was_field_Name9_set = true;
  }

  public function hasFieldName9(): bool {
    return $this->was_field_Name9_set;
  }

  public function getFieldName10(): int {
    return $this->Field_Name10;
  }

  public function setFieldName10(int $v): void {
    $this->Field_Name10 = $v;
    $this->was_Field_Name10_set = true;
  }

  public function hasFieldName10(): bool {
    return $this->was_Field_Name10_set;
  }

  public function getFIELDNAME11(): int {
    return $this->FIELD_NAME11;
  }

  public function setFIELDNAME11(int $v): void {
    $this->FIELD_NAME11 = $v;
    $this->was_FIELD_NAME11_set = true;
  }

  public function hasFIELDNAME11(): bool {
    return $this->was_FIELD_NAME11_set;
  }

  public function getFIELDName12(): int {
    return $this->FIELD_name12;
  }

  public function setFIELDName12(int $v): void {
    $this->FIELD_name12 = $v;
    $this->was_FIELD_name12_set = true;
  }

  public function hasFIELDName12(): bool {
    return $this->was_FIELD_name12_set;
  }

  public function getFieldName13(): int {
    return $this->__field_name13;
  }

  public function setFieldName13(int $v): void {
    $this->__field_name13 = $v;
    $this->was___field_name13_set = true;
  }

  public function hasFieldName13(): bool {
    return $this->was___field_name13_set;
  }

  public function getFieldName14(): int {
    return $this->__Field_name14;
  }

  public function setFieldName14(int $v): void {
    $this->__Field_name14 = $v;
    $this->was___Field_name14_set = true;
  }

  public function hasFieldName14(): bool {
    return $this->was___Field_name14_set;
  }

  public function getFieldName15(): int {
    return $this->field__name15;
  }

  public function setFieldName15(int $v): void {
    $this->field__name15 = $v;
    $this->was_field__name15_set = true;
  }

  public function hasFieldName15(): bool {
    return $this->was_field__name15_set;
  }

  public function getFieldName16(): int {
    return $this->field__Name16;
  }

  public function setFieldName16(int $v): void {
    $this->field__Name16 = $v;
    $this->was_field__Name16_set = true;
  }

  public function hasFieldName16(): bool {
    return $this->was_field__Name16_set;
  }

  public function getFieldName17(): int {
    return $this->field_name17__;
  }

  public function setFieldName17(int $v): void {
    $this->field_name17__ = $v;
    $this->was_field_name17___set = true;
  }

  public function hasFieldName17(): bool {
    return $this->was_field_name17___set;
  }

  public function getFieldName18(): int {
    return $this->Field_name18__;
  }

  public function setFieldName18(int $v): void {
    $this->Field_name18__ = $v;
    $this->was_Field_name18___set = true;
  }

  public function hasFieldName18(): bool {
    return $this->was_Field_name18___set;
  }

  public function getMessageSetCorrect(): ?\protobuf_test_messages\proto2\TestAllTypesProto2_MessageSetCorrect {
    return $this->message_set_correct;
  }

  public function setMessageSetCorrect(?\protobuf_test_messages\proto2\TestAllTypesProto2_MessageSetCorrect $v): void {
    $this->message_set_correct = $v;
    $this->was_message_set_correct_set = true;
  }

  public function hasMessageSetCorrect(): bool {
    return $this->was_message_set_correct_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2 {
    $msg = new TestAllTypesProto2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->optional_int32 = $d->readVarint32Signed();
          $this->was_optional_int32_set = true;
          break;
        case 2:
          $this->optional_int64 = $d->readVarint();
          $this->was_optional_int64_set = true;
          break;
        case 3:
          $this->optional_uint32 = $d->readVarint32();
          $this->was_optional_uint32_set = true;
          break;
        case 4:
          $this->optional_uint64 = $d->readVarint();
          $this->was_optional_uint64_set = true;
          break;
        case 5:
          $this->optional_sint32 = $d->readVarintZigZag32();
          $this->was_optional_sint32_set = true;
          break;
        case 6:
          $this->optional_sint64 = $d->readVarintZigZag64();
          $this->was_optional_sint64_set = true;
          break;
        case 7:
          $this->optional_fixed32 = $d->readLittleEndianInt32Unsigned();
          $this->was_optional_fixed32_set = true;
          break;
        case 8:
          $this->optional_fixed64 = $d->readLittleEndianInt64();
          $this->was_optional_fixed64_set = true;
          break;
        case 9:
          $this->optional_sfixed32 = $d->readLittleEndianInt32Signed();
          $this->was_optional_sfixed32_set = true;
          break;
        case 10:
          $this->optional_sfixed64 = $d->readLittleEndianInt64();
          $this->was_optional_sfixed64_set = true;
          break;
        case 11:
          $this->optional_float = $d->readFloat();
          $this->was_optional_float_set = true;
          break;
        case 12:
          $this->optional_double = $d->readDouble();
          $this->was_optional_double_set = true;
          break;
        case 13:
          $this->optional_bool = $d->readBool();
          $this->was_optional_bool_set = true;
          break;
        case 14:
          $this->optional_string = $d->readString();
          $this->was_optional_string_set = true;
          break;
        case 15:
          $this->optional_bytes = $d->readString();
          $this->was_optional_bytes_set = true;
          break;
        case 18:
          if ($this->optional_nested_message is null) {
            $this->optional_nested_message = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
            $this->was_optional_nested_message_set = true;
          }
          $this->optional_nested_message->MergeFrom($d->readDecoder());
          break;
        case 19:
          if ($this->optional_foreign_message is null) {
            $this->optional_foreign_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
            $this->was_optional_foreign_message_set = true;
          }
          $this->optional_foreign_message->MergeFrom($d->readDecoder());
          break;
        case 21:
          $this->optional_nested_enum = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          $this->was_optional_nested_enum_set = true;
          break;
        case 22:
          $this->optional_foreign_enum = \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($d->readVarint());
          $this->was_optional_foreign_enum_set = true;
          break;
        case 24:
          $this->optional_string_piece = $d->readString();
          $this->was_optional_string_piece_set = true;
          break;
        case 25:
          $this->optional_cord = $d->readString();
          $this->was_optional_cord_set = true;
          break;
        case 27:
          if ($this->recursive_message is null) {
            $this->recursive_message = new \protobuf_test_messages\proto2\TestAllTypesProto2();
            $this->was_recursive_message_set = true;
          }
          $this->recursive_message->MergeFrom($d->readDecoder());
          break;
        case 31:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->repeated_int32 []= $d->readVarint32Signed();
          }
          break;
        case 32:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int64 []= $packed->readVarint();
            }
          } else {
            $this->repeated_int64 []= $d->readVarint();
          }
          break;
        case 33:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->repeated_uint32 []= $d->readVarint32();
          }
          break;
        case 34:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_uint64 []= $packed->readVarint();
            }
          } else {
            $this->repeated_uint64 []= $d->readVarint();
          }
          break;
        case 35:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->repeated_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 36:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->repeated_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 37:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->repeated_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 38:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->repeated_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 39:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->repeated_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 40:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->repeated_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 41:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_float []= $packed->readFloat();
            }
          } else {
            $this->repeated_float []= $d->readFloat();
          }
          break;
        case 42:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_double []= $packed->readDouble();
            }
          } else {
            $this->repeated_double []= $d->readDouble();
          }
          break;
        case 43:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_bool []= $packed->readBool();
            }
          } else {
            $this->repeated_bool []= $d->readBool();
          }
          break;
        case 44:
          $this->repeated_string []= $d->readString();
          break;
        case 45:
          $this->repeated_bytes []= $d->readString();
          break;
        case 48:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_nested_message []= $obj;
          break;
        case 49:
          $obj = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_foreign_message []= $obj;
          break;
        case 51:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->repeated_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 52:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_foreign_enum []= \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($packed->readVarint());
            }
          } else {
            $this->repeated_foreign_enum []= \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($d->readVarint());
          }
          break;
        case 54:
          $this->repeated_string_piece []= $d->readString();
          break;
        case 55:
          $this->repeated_cord []= $d->readString();
          break;
        case 56:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32Int32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_int32[$obj->getKey()] = $obj->getValue();
          break;
        case 57:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt64Int64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int64_int64[$obj->getKey()] = $obj->getValue();
          break;
        case 58:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint32Uint32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_uint32_uint32[$obj->getKey()] = $obj->getValue();
          break;
        case 59:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint64Uint64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_uint64_uint64[$obj->getKey()] = $obj->getValue();
          break;
        case 60:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint32Sint32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sint32_sint32[$obj->getKey()] = $obj->getValue();
          break;
        case 61:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint64Sint64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sint64_sint64[$obj->getKey()] = $obj->getValue();
          break;
        case 62:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed32Fixed32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_fixed32_fixed32[$obj->getKey()] = $obj->getValue();
          break;
        case 63:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed64Fixed64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_fixed64_fixed64[$obj->getKey()] = $obj->getValue();
          break;
        case 64:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed32Sfixed32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sfixed32_sfixed32[$obj->getKey()] = $obj->getValue();
          break;
        case 65:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed64Sfixed64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sfixed64_sfixed64[$obj->getKey()] = $obj->getValue();
          break;
        case 66:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32FloatEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_float[$obj->getKey()] = $obj->getValue();
          break;
        case 67:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32DoubleEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_double[$obj->getKey()] = $obj->getValue();
          break;
        case 68:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapBoolBoolEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_bool_bool[\Protobuf\BoolMapKey::FromBool($obj->getKey())] = $obj->getValue();
          break;
        case 69:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringStringEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_string[$obj->getKey()] = $obj->getValue();
          break;
        case 70:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringBytesEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_bytes[$obj->getKey()] = $obj->getValue();
          break;
        case 71:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedMessageEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_nested_message[$obj->getKey()] = $obj->getValue() ?? new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          break;
        case 72:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignMessageEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_foreign_message[$obj->getKey()] = $obj->getValue() ?? new \protobuf_test_messages\proto2\ForeignMessageProto2();
          break;
        case 73:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedEnumEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_nested_enum[$obj->getKey()] = $obj->getValue();
          break;
        case 74:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignEnumEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_foreign_enum[$obj->getKey()] = $obj->getValue();
          break;
        case 75:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->packed_int32 []= $d->readVarint32Signed();
          }
          break;
        case 76:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_int64 []= $packed->readVarint();
            }
          } else {
            $this->packed_int64 []= $d->readVarint();
          }
          break;
        case 77:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->packed_uint32 []= $d->readVarint32();
          }
          break;
        case 78:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_uint64 []= $packed->readVarint();
            }
          } else {
            $this->packed_uint64 []= $d->readVarint();
          }
          break;
        case 79:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->packed_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 80:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->packed_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 81:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->packed_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 82:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->packed_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 83:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->packed_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 84:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->packed_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 85:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_float []= $packed->readFloat();
            }
          } else {
            $this->packed_float []= $d->readFloat();
          }
          break;
        case 86:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_double []= $packed->readDouble();
            }
          } else {
            $this->packed_double []= $d->readDouble();
          }
          break;
        case 87:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_bool []= $packed->readBool();
            }
          } else {
            $this->packed_bool []= $d->readBool();
          }
          break;
        case 88:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->packed_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 89:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->unpacked_int32 []= $d->readVarint32Signed();
          }
          break;
        case 90:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_int64 []= $packed->readVarint();
            }
          } else {
            $this->unpacked_int64 []= $d->readVarint();
          }
          break;
        case 91:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->unpacked_uint32 []= $d->readVarint32();
          }
          break;
        case 92:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_uint64 []= $packed->readVarint();
            }
          } else {
            $this->unpacked_uint64 []= $d->readVarint();
          }
          break;
        case 93:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->unpacked_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 94:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->unpacked_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 95:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->unpacked_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 96:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->unpacked_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 97:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->unpacked_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 98:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->unpacked_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 99:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_float []= $packed->readFloat();
            }
          } else {
            $this->unpacked_float []= $d->readFloat();
          }
          break;
        case 100:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_double []= $packed->readDouble();
            }
          } else {
            $this->unpacked_double []= $d->readDouble();
          }
          break;
        case 101:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_bool []= $packed->readBool();
            }
          } else {
            $this->unpacked_bool []= $d->readBool();
          }
          break;
        case 102:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->unpacked_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 103:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32NestedMessageEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_nested_message[$obj->getKey()] = $obj->getValue() ?? new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          break;
        case 104:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32BoolEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_bool[$obj->getKey()] = $obj->getValue();
          break;
        case 111:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_uint32($d->readVarint32());
          break;
        case 112:
          if ($this->oneof_field->WhichOneof() == TestAllTypesProto2_oneof_field_oneof_t::oneof_nested_message) {
            ($this->oneof_field as TestAllTypesProto2_oneof_field_oneof_nested_message)->oneof_nested_message->MergeFrom($d->readDecoder());
          } else {
            $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
            $obj->MergeFrom($d->readDecoder());
            $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_nested_message($obj);
          }
          break;
        case 113:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_string($d->readString());
          break;
        case 114:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_bytes($d->readString());
          break;
        case 115:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_bool($d->readBool());
          break;
        case 116:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_uint64($d->readVarint());
          break;
        case 117:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_float($d->readFloat());
          break;
        case 118:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_double($d->readDouble());
          break;
        case 119:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_enum(\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint()));
          break;
        case 201:
          if ($this->data is null) {
            $this->data = new \protobuf_test_messages\proto2\TestAllTypesProto2_Data();
            $this->was_data_set = true;
          }
          $this->data->MergeFrom($d->readDecoder());
          break;
        case 204:
          if ($this->multiwordgroupfield is null) {
            $this->multiwordgroupfield = new \protobuf_test_messages\proto2\TestAllTypesProto2_MultiWordGroupField();
            $this->was_multiwordgroupfield_set = true;
          }
          $this->multiwordgroupfield->MergeFrom($d->readDecoder());
          break;
        case 241:
          $this->default_int32 = $d->readVarint32Signed();
          $this->was_default_int32_set = true;
          break;
        case 242:
          $this->default_int64 = $d->readVarint();
          $this->was_default_int64_set = true;
          break;
        case 243:
          $this->default_uint32 = $d->readVarint32();
          $this->was_default_uint32_set = true;
          break;
        case 244:
          $this->default_uint64 = $d->readVarint();
          $this->was_default_uint64_set = true;
          break;
        case 245:
          $this->default_sint32 = $d->readVarintZigZag32();
          $this->was_default_sint32_set = true;
          break;
        case 246:
          $this->default_sint64 = $d->readVarintZigZag64();
          $this->was_default_sint64_set = true;
          break;
        case 247:
          $this->default_fixed32 = $d->readLittleEndianInt32Unsigned();
          $this->was_default_fixed32_set = true;
          break;
        case 248:
          $this->default_fixed64 = $d->readLittleEndianInt64();
          $this->was_default_fixed64_set = true;
          break;
        case 249:
          $this->default_sfixed32 = $d->readLittleEndianInt32Signed();
          $this->was_default_sfixed32_set = true;
          break;
        case 250:
          $this->default_sfixed64 = $d->readLittleEndianInt64();
          $this->was_default_sfixed64_set = true;
          break;
        case 251:
          $this->default_float = $d->readFloat();
          $this->was_default_float_set = true;
          break;
        case 252:
          $this->default_double = $d->readDouble();
          $this->was_default_double_set = true;
          break;
        case 253:
          $this->default_bool = $d->readBool();
          $this->was_default_bool_set = true;
          break;
        case 254:
          $this->default_string = $d->readString();
          $this->was_default_string_set = true;
          break;
        case 255:
          $this->default_bytes = $d->readString();
          $this->was_default_bytes_set = true;
          break;
        case 401:
          $this->fieldname1 = $d->readVarint32Signed();
          $this->was_fieldname1_set = true;
          break;
        case 402:
          $this->field_name2 = $d->readVarint32Signed();
          $this->was_field_name2_set = true;
          break;
        case 403:
          $this->_field_name3 = $d->readVarint32Signed();
          $this->was__field_name3_set = true;
          break;
        case 404:
          $this->field__name4_ = $d->readVarint32Signed();
          $this->was_field__name4__set = true;
          break;
        case 405:
          $this->field0name5 = $d->readVarint32Signed();
          $this->was_field0name5_set = true;
          break;
        case 406:
          $this->field_0_name6 = $d->readVarint32Signed();
          $this->was_field_0_name6_set = true;
          break;
        case 407:
          $this->fieldName7 = $d->readVarint32Signed();
          $this->was_fieldName7_set = true;
          break;
        case 408:
          $this->FieldName8 = $d->readVarint32Signed();
          $this->was_FieldName8_set = true;
          break;
        case 409:
          $this->field_Name9 = $d->readVarint32Signed();
          $this->was_field_Name9_set = true;
          break;
        case 410:
          $this->Field_Name10 = $d->readVarint32Signed();
          $this->was_Field_Name10_set = true;
          break;
        case 411:
          $this->FIELD_NAME11 = $d->readVarint32Signed();
          $this->was_FIELD_NAME11_set = true;
          break;
        case 412:
          $this->FIELD_name12 = $d->readVarint32Signed();
          $this->was_FIELD_name12_set = true;
          break;
        case 413:
          $this->__field_name13 = $d->readVarint32Signed();
          $this->was___field_name13_set = true;
          break;
        case 414:
          $this->__Field_name14 = $d->readVarint32Signed();
          $this->was___Field_name14_set = true;
          break;
        case 415:
          $this->field__name15 = $d->readVarint32Signed();
          $this->was_field__name15_set = true;
          break;
        case 416:
          $this->field__Name16 = $d->readVarint32Signed();
          $this->was_field__Name16_set = true;
          break;
        case 417:
          $this->field_name17__ = $d->readVarint32Signed();
          $this->was_field_name17___set = true;
          break;
        case 418:
          $this->Field_name18__ = $d->readVarint32Signed();
          $this->was_Field_name18___set = true;
          break;
        case 500:
          if ($this->message_set_correct is null) {
            $this->message_set_correct = new \protobuf_test_messages\proto2\TestAllTypesProto2_MessageSetCorrect();
            $this->was_message_set_correct_set = true;
          }
          $this->message_set_correct->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_optional_int32_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->optional_int32);
    }
    if ($this->was_optional_int64_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->optional_int64);
    }
    if ($this->was_optional_uint32_set) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->optional_uint32);
    }
    if ($this->was_optional_uint64_set) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->optional_uint64);
    }
    if ($this->was_optional_sint32_set) {
      $e->writeTag(5, 0);
      $e->writeVarintZigZag32($this->optional_sint32);
    }
    if ($this->was_optional_sint64_set) {
      $e->writeTag(6, 0);
      $e->writeVarintZigZag64($this->optional_sint64);
    }
    if ($this->was_optional_fixed32_set) {
      $e->writeTag(7, 5);
      $e->writeLittleEndianInt32Unsigned($this->optional_fixed32);
    }
    if ($this->was_optional_fixed64_set) {
      $e->writeTag(8, 1);
      $e->writeLittleEndianInt64($this->optional_fixed64);
    }
    if ($this->was_optional_sfixed32_set) {
      $e->writeTag(9, 5);
      $e->writeLittleEndianInt32Signed($this->optional_sfixed32);
    }
    if ($this->was_optional_sfixed64_set) {
      $e->writeTag(10, 1);
      $e->writeLittleEndianInt64($this->optional_sfixed64);
    }
    if ($this->was_optional_float_set) {
      $e->writeTag(11, 5);
      $e->writeFloat($this->optional_float);
    }
    if ($this->was_optional_double_set) {
      $e->writeTag(12, 1);
      $e->writeDouble($this->optional_double);
    }
    if ($this->was_optional_bool_set) {
      $e->writeTag(13, 0);
      $e->writeBool($this->optional_bool);
    }
    if ($this->was_optional_string_set) {
      $e->writeTag(14, 2);
      $e->writeString($this->optional_string);
    }
    if ($this->was_optional_bytes_set) {
      $e->writeTag(15, 2);
      $e->writeString($this->optional_bytes);
    }
    $msg = $this->optional_nested_message;
    if ($msg != null) {
      if ($this->was_optional_nested_message_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 18);
      }
    }
    $msg = $this->optional_foreign_message;
    if ($msg != null) {
      if ($this->was_optional_foreign_message_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 19);
      }
    }
    if ($this->was_optional_nested_enum_set) {
      $e->writeTag(21, 0);
      $e->writeVarint($this->optional_nested_enum);
    }
    if ($this->was_optional_foreign_enum_set) {
      $e->writeTag(22, 0);
      $e->writeVarint($this->optional_foreign_enum);
    }
    if ($this->was_optional_string_piece_set) {
      $e->writeTag(24, 2);
      $e->writeString($this->optional_string_piece);
    }
    if ($this->was_optional_cord_set) {
      $e->writeTag(25, 2);
      $e->writeString($this->optional_cord);
    }
    $msg = $this->recursive_message;
    if ($msg != null) {
      if ($this->was_recursive_message_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 27);
      }
    }
    foreach ($this->repeated_int32 as $elem) {
      $e->writeTag(31, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_int64 as $elem) {
      $e->writeTag(32, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_uint32 as $elem) {
      $e->writeTag(33, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_uint64 as $elem) {
      $e->writeTag(34, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_sint32 as $elem) {
      $e->writeTag(35, 0);
      $e->writeVarintZigZag32($elem);
    }
    foreach ($this->repeated_sint64 as $elem) {
      $e->writeTag(36, 0);
      $e->writeVarintZigZag64($elem);
    }
    foreach ($this->repeated_fixed32 as $elem) {
      $e->writeTag(37, 5);
      $e->writeLittleEndianInt32Unsigned($elem);
    }
    foreach ($this->repeated_fixed64 as $elem) {
      $e->writeTag(38, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->repeated_sfixed32 as $elem) {
      $e->writeTag(39, 5);
      $e->writeLittleEndianInt32Signed($elem);
    }
    foreach ($this->repeated_sfixed64 as $elem) {
      $e->writeTag(40, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->repeated_float as $elem) {
      $e->writeTag(41, 5);
      $e->writeFloat($elem);
    }
    foreach ($this->repeated_double as $elem) {
      $e->writeTag(42, 1);
      $e->writeDouble($elem);
    }
    foreach ($this->repeated_bool as $elem) {
      $e->writeTag(43, 0);
      $e->writeBool($elem);
    }
    foreach ($this->repeated_string as $elem) {
      $e->writeTag(44, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_bytes as $elem) {
      $e->writeTag(45, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_nested_message as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 48);
    }
    foreach ($this->repeated_foreign_message as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 49);
    }
    foreach ($this->repeated_nested_enum as $elem) {
      $e->writeTag(51, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_foreign_enum as $elem) {
      $e->writeTag(52, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_string_piece as $elem) {
      $e->writeTag(54, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_cord as $elem) {
      $e->writeTag(55, 2);
      $e->writeString($elem);
    }
    foreach ($this->map_int32_int32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32Int32Entry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 56);
    }
    foreach ($this->map_int64_int64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt64Int64Entry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 57);
    }
    foreach ($this->map_uint32_uint32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint32Uint32Entry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 58);
    }
    foreach ($this->map_uint64_uint64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint64Uint64Entry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 59);
    }
    foreach ($this->map_sint32_sint32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint32Sint32Entry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 60);
    }
    foreach ($this->map_sint64_sint64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint64Sint64Entry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 61);
    }
    foreach ($this->map_fixed32_fixed32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed32Fixed32Entry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 62);
    }
    foreach ($this->map_fixed64_fixed64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed64Fixed64Entry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 63);
    }
    foreach ($this->map_sfixed32_sfixed32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed32Sfixed32Entry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 64);
    }
    foreach ($this->map_sfixed64_sfixed64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed64Sfixed64Entry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 65);
    }
    foreach ($this->map_int32_float as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32FloatEntry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 66);
    }
    foreach ($this->map_int32_double as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32DoubleEntry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 67);
    }
    foreach ($this->map_bool_bool as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapBoolBoolEntry();
      $obj->setKey(\Protobuf\BoolMapKey::ToBool($k));
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 68);
    }
    foreach ($this->map_string_string as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringStringEntry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 69);
    }
    foreach ($this->map_string_bytes as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringBytesEntry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 70);
    }
    foreach ($this->map_string_nested_message as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedMessageEntry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 71);
    }
    foreach ($this->map_string_foreign_message as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignMessageEntry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 72);
    }
    foreach ($this->map_string_nested_enum as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedEnumEntry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 73);
    }
    foreach ($this->map_string_foreign_enum as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignEnumEntry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 74);
    }
    if (\count($this->packed_int32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_int32 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 75);
    }
    if (\count($this->packed_int64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_int64 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 76);
    }
    if (\count($this->packed_uint32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_uint32 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 77);
    }
    if (\count($this->packed_uint64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_uint64 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 78);
    }
    if (\count($this->packed_sint32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sint32 as $elem) {
        $packed->writeVarintZigZag32($elem);
      }
      $e->writeEncoder($packed, 79);
    }
    if (\count($this->packed_sint64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sint64 as $elem) {
        $packed->writeVarintZigZag64($elem);
      }
      $e->writeEncoder($packed, 80);
    }
    if (\count($this->packed_fixed32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_fixed32 as $elem) {
        $packed->writeLittleEndianInt32Unsigned($elem);
      }
      $e->writeEncoder($packed, 81);
    }
    if (\count($this->packed_fixed64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_fixed64 as $elem) {
        $packed->writeLittleEndianInt64($elem);
      }
      $e->writeEncoder($packed, 82);
    }
    if (\count($this->packed_sfixed32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sfixed32 as $elem) {
        $packed->writeLittleEndianInt32Signed($elem);
      }
      $e->writeEncoder($packed, 83);
    }
    if (\count($this->packed_sfixed64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sfixed64 as $elem) {
        $packed->writeLittleEndianInt64($elem);
      }
      $e->writeEncoder($packed, 84);
    }
    if (\count($this->packed_float) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_float as $elem) {
        $packed->writeFloat($elem);
      }
      $e->writeEncoder($packed, 85);
    }
    if (\count($this->packed_double) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_double as $elem) {
        $packed->writeDouble($elem);
      }
      $e->writeEncoder($packed, 86);
    }
    if (\count($this->packed_bool) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_bool as $elem) {
        $packed->writeBool($elem);
      }
      $e->writeEncoder($packed, 87);
    }
    if (\count($this->packed_nested_enum) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_nested_enum as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 88);
    }
    foreach ($this->unpacked_int32 as $elem) {
      $e->writeTag(89, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_int64 as $elem) {
      $e->writeTag(90, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_uint32 as $elem) {
      $e->writeTag(91, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_uint64 as $elem) {
      $e->writeTag(92, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_sint32 as $elem) {
      $e->writeTag(93, 0);
      $e->writeVarintZigZag32($elem);
    }
    foreach ($this->unpacked_sint64 as $elem) {
      $e->writeTag(94, 0);
      $e->writeVarintZigZag64($elem);
    }
    foreach ($this->unpacked_fixed32 as $elem) {
      $e->writeTag(95, 5);
      $e->writeLittleEndianInt32Unsigned($elem);
    }
    foreach ($this->unpacked_fixed64 as $elem) {
      $e->writeTag(96, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->unpacked_sfixed32 as $elem) {
      $e->writeTag(97, 5);
      $e->writeLittleEndianInt32Signed($elem);
    }
    foreach ($this->unpacked_sfixed64 as $elem) {
      $e->writeTag(98, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->unpacked_float as $elem) {
      $e->writeTag(99, 5);
      $e->writeFloat($elem);
    }
    foreach ($this->unpacked_double as $elem) {
      $e->writeTag(100, 1);
      $e->writeDouble($elem);
    }
    foreach ($this->unpacked_bool as $elem) {
      $e->writeTag(101, 0);
      $e->writeBool($elem);
    }
    foreach ($this->unpacked_nested_enum as $elem) {
      $e->writeTag(102, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->map_int32_nested_message as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32NestedMessageEntry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 103);
    }
    foreach ($this->map_int32_bool as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32BoolEntry();
      $obj->setKey($k);
      $obj->setValue($v);
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 104);
    }
    $msg = $this->data;
    if ($msg != null) {
      if ($this->was_data_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 201);
      }
    }
    $msg = $this->multiwordgroupfield;
    if ($msg != null) {
      if ($this->was_multiwordgroupfield_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 204);
      }
    }
    if ($this->was_default_int32_set) {
      $e->writeTag(241, 0);
      $e->writeVarint($this->default_int32);
    }
    if ($this->was_default_int64_set) {
      $e->writeTag(242, 0);
      $e->writeVarint($this->default_int64);
    }
    if ($this->was_default_uint32_set) {
      $e->writeTag(243, 0);
      $e->writeVarint($this->default_uint32);
    }
    if ($this->was_default_uint64_set) {
      $e->writeTag(244, 0);
      $e->writeVarint($this->default_uint64);
    }
    if ($this->was_default_sint32_set) {
      $e->writeTag(245, 0);
      $e->writeVarintZigZag32($this->default_sint32);
    }
    if ($this->was_default_sint64_set) {
      $e->writeTag(246, 0);
      $e->writeVarintZigZag64($this->default_sint64);
    }
    if ($this->was_default_fixed32_set) {
      $e->writeTag(247, 5);
      $e->writeLittleEndianInt32Unsigned($this->default_fixed32);
    }
    if ($this->was_default_fixed64_set) {
      $e->writeTag(248, 1);
      $e->writeLittleEndianInt64($this->default_fixed64);
    }
    if ($this->was_default_sfixed32_set) {
      $e->writeTag(249, 5);
      $e->writeLittleEndianInt32Signed($this->default_sfixed32);
    }
    if ($this->was_default_sfixed64_set) {
      $e->writeTag(250, 1);
      $e->writeLittleEndianInt64($this->default_sfixed64);
    }
    if ($this->was_default_float_set) {
      $e->writeTag(251, 5);
      $e->writeFloat($this->default_float);
    }
    if ($this->was_default_double_set) {
      $e->writeTag(252, 1);
      $e->writeDouble($this->default_double);
    }
    if ($this->was_default_bool_set) {
      $e->writeTag(253, 0);
      $e->writeBool($this->default_bool);
    }
    if ($this->was_default_string_set) {
      $e->writeTag(254, 2);
      $e->writeString($this->default_string);
    }
    if ($this->was_default_bytes_set) {
      $e->writeTag(255, 2);
      $e->writeString($this->default_bytes);
    }
    if ($this->was_fieldname1_set) {
      $e->writeTag(401, 0);
      $e->writeVarint($this->fieldname1);
    }
    if ($this->was_field_name2_set) {
      $e->writeTag(402, 0);
      $e->writeVarint($this->field_name2);
    }
    if ($this->was__field_name3_set) {
      $e->writeTag(403, 0);
      $e->writeVarint($this->_field_name3);
    }
    if ($this->was_field__name4__set) {
      $e->writeTag(404, 0);
      $e->writeVarint($this->field__name4_);
    }
    if ($this->was_field0name5_set) {
      $e->writeTag(405, 0);
      $e->writeVarint($this->field0name5);
    }
    if ($this->was_field_0_name6_set) {
      $e->writeTag(406, 0);
      $e->writeVarint($this->field_0_name6);
    }
    if ($this->was_fieldName7_set) {
      $e->writeTag(407, 0);
      $e->writeVarint($this->fieldName7);
    }
    if ($this->was_FieldName8_set) {
      $e->writeTag(408, 0);
      $e->writeVarint($this->FieldName8);
    }
    if ($this->was_field_Name9_set) {
      $e->writeTag(409, 0);
      $e->writeVarint($this->field_Name9);
    }
    if ($this->was_Field_Name10_set) {
      $e->writeTag(410, 0);
      $e->writeVarint($this->Field_Name10);
    }
    if ($this->was_FIELD_NAME11_set) {
      $e->writeTag(411, 0);
      $e->writeVarint($this->FIELD_NAME11);
    }
    if ($this->was_FIELD_name12_set) {
      $e->writeTag(412, 0);
      $e->writeVarint($this->FIELD_name12);
    }
    if ($this->was___field_name13_set) {
      $e->writeTag(413, 0);
      $e->writeVarint($this->__field_name13);
    }
    if ($this->was___Field_name14_set) {
      $e->writeTag(414, 0);
      $e->writeVarint($this->__Field_name14);
    }
    if ($this->was_field__name15_set) {
      $e->writeTag(415, 0);
      $e->writeVarint($this->field__name15);
    }
    if ($this->was_field__Name16_set) {
      $e->writeTag(416, 0);
      $e->writeVarint($this->field__Name16);
    }
    if ($this->was_field_name17___set) {
      $e->writeTag(417, 0);
      $e->writeVarint($this->field_name17__);
    }
    if ($this->was_Field_name18___set) {
      $e->writeTag(418, 0);
      $e->writeVarint($this->Field_name18__);
    }
    $msg = $this->message_set_correct;
    if ($msg != null) {
      if ($this->was_message_set_correct_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 500);
      }
    }
    $this->oneof_field->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasOptionalInt32()) {
      $e->writeInt32('optional_int32', 'optionalInt32', $this->optional_int32, false);
    }
    if ($this->hasOptionalInt64()) {
      $e->writeInt64Signed('optional_int64', 'optionalInt64', $this->optional_int64, false);
    }
    if ($this->hasOptionalUint32()) {
      $e->writeInt32('optional_uint32', 'optionalUint32', $this->optional_uint32, false);
    }
    if ($this->hasOptionalUint64()) {
      $e->writeInt64Unsigned('optional_uint64', 'optionalUint64', $this->optional_uint64, false);
    }
    if ($this->hasOptionalSint32()) {
      $e->writeInt32('optional_sint32', 'optionalSint32', $this->optional_sint32, false);
    }
    if ($this->hasOptionalSint64()) {
      $e->writeInt64Signed('optional_sint64', 'optionalSint64', $this->optional_sint64, false);
    }
    if ($this->hasOptionalFixed32()) {
      $e->writeInt32('optional_fixed32', 'optionalFixed32', $this->optional_fixed32, false);
    }
    if ($this->hasOptionalFixed64()) {
      $e->writeInt64Unsigned('optional_fixed64', 'optionalFixed64', $this->optional_fixed64, false);
    }
    if ($this->hasOptionalSfixed32()) {
      $e->writeInt32('optional_sfixed32', 'optionalSfixed32', $this->optional_sfixed32, false);
    }
    if ($this->hasOptionalSfixed64()) {
      $e->writeInt64Signed('optional_sfixed64', 'optionalSfixed64', $this->optional_sfixed64, false);
    }
    if ($this->hasOptionalFloat()) {
      $e->writeFloat('optional_float', 'optionalFloat', $this->optional_float, false);
    }
    if ($this->hasOptionalDouble()) {
      $e->writeFloat('optional_double', 'optionalDouble', $this->optional_double, false);
    }
    if ($this->hasOptionalBool()) {
      $e->writeBool('optional_bool', 'optionalBool', $this->optional_bool, false);
    }
    if ($this->hasOptionalString()) {
      $e->writeString('optional_string', 'optionalString', $this->optional_string, false);
    }
    if ($this->hasOptionalBytes()) {
      $e->writeBytes('optional_bytes', 'optionalBytes', $this->optional_bytes, false);
    }
    if ($this->hasOptionalNestedMessage()) {
      $e->writeMessage('optional_nested_message', 'optionalNestedMessage', $this->optional_nested_message, false);
    }
    if ($this->hasOptionalForeignMessage()) {
      $e->writeMessage('optional_foreign_message', 'optionalForeignMessage', $this->optional_foreign_message, false);
    }
    if ($this->hasOptionalNestedEnum()) {
      $e->writeEnum('optional_nested_enum', 'optionalNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->optional_nested_enum, false);
    }
    if ($this->hasOptionalForeignEnum()) {
      $e->writeEnum('optional_foreign_enum', 'optionalForeignEnum', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->optional_foreign_enum, false);
    }
    if ($this->hasOptionalStringPiece()) {
      $e->writeString('optional_string_piece', 'optionalStringPiece', $this->optional_string_piece, false);
    }
    if ($this->hasOptionalCord()) {
      $e->writeString('optional_cord', 'optionalCord', $this->optional_cord, false);
    }
    if ($this->hasRecursiveMessage()) {
      $e->writeMessage('recursive_message', 'recursiveMessage', $this->recursive_message, false);
    }
    $e->writePrimitiveList('repeated_int32', 'repeatedInt32', $this->repeated_int32);
    $e->writeInt64SignedList('repeated_int64', 'repeatedInt64', $this->repeated_int64);
    $e->writePrimitiveList('repeated_uint32', 'repeatedUint32', $this->repeated_uint32);
    $e->writeInt64UnsignedList('repeated_uint64', 'repeatedUint64', $this->repeated_uint64);
    $e->writePrimitiveList('repeated_sint32', 'repeatedSint32', $this->repeated_sint32);
    $e->writeInt64SignedList('repeated_sint64', 'repeatedSint64', $this->repeated_sint64);
    $e->writePrimitiveList('repeated_fixed32', 'repeatedFixed32', $this->repeated_fixed32);
    $e->writeInt64UnsignedList('repeated_fixed64', 'repeatedFixed64', $this->repeated_fixed64);
    $e->writePrimitiveList('repeated_sfixed32', 'repeatedSfixed32', $this->repeated_sfixed32);
    $e->writeInt64SignedList('repeated_sfixed64', 'repeatedSfixed64', $this->repeated_sfixed64);
    $e->writeFloatList('repeated_float', 'repeatedFloat', $this->repeated_float);
    $e->writeFloatList('repeated_double', 'repeatedDouble', $this->repeated_double);
    $e->writePrimitiveList('repeated_bool', 'repeatedBool', $this->repeated_bool);
    $e->writePrimitiveList('repeated_string', 'repeatedString', $this->repeated_string);
    $e->writeBytesList('repeated_bytes', 'repeatedBytes', $this->repeated_bytes);
    $e->writeMessageList('repeated_nested_message', 'repeatedNestedMessage', $this->repeated_nested_message);
    $e->writeMessageList('repeated_foreign_message', 'repeatedForeignMessage', $this->repeated_foreign_message);
    $e->writeEnumList('repeated_nested_enum', 'repeatedNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->repeated_nested_enum);
    $e->writeEnumList('repeated_foreign_enum', 'repeatedForeignEnum', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->repeated_foreign_enum);
    $e->writePrimitiveList('repeated_string_piece', 'repeatedStringPiece', $this->repeated_string_piece);
    $e->writePrimitiveList('repeated_cord', 'repeatedCord', $this->repeated_cord);
    $e->writePrimitiveMap('map_int32_int32', 'mapInt32Int32', $this->map_int32_int32);
    $e->writeInt64SignedMap('map_int64_int64', 'mapInt64Int64', $this->map_int64_int64);
    $e->writePrimitiveMap('map_uint32_uint32', 'mapUint32Uint32', $this->map_uint32_uint32);
    $e->writeInt64UnsignedMap('map_uint64_uint64', 'mapUint64Uint64', $this->map_uint64_uint64);
    $e->writePrimitiveMap('map_sint32_sint32', 'mapSint32Sint32', $this->map_sint32_sint32);
    $e->writeInt64SignedMap('map_sint64_sint64', 'mapSint64Sint64', $this->map_sint64_sint64);
    $e->writePrimitiveMap('map_fixed32_fixed32', 'mapFixed32Fixed32', $this->map_fixed32_fixed32);
    $e->writeInt64UnsignedMap('map_fixed64_fixed64', 'mapFixed64Fixed64', $this->map_fixed64_fixed64);
    $e->writePrimitiveMap('map_sfixed32_sfixed32', 'mapSfixed32Sfixed32', $this->map_sfixed32_sfixed32);
    $e->writeInt64SignedMap('map_sfixed64_sfixed64', 'mapSfixed64Sfixed64', $this->map_sfixed64_sfixed64);
    $e->writeFloatMap('map_int32_float', 'mapInt32Float', $this->map_int32_float);
    $e->writeFloatMap('map_int32_double', 'mapInt32Double', $this->map_int32_double);
    $e->writePrimitiveMap('map_bool_bool', 'mapBoolBool', $this->map_bool_bool);
    $e->writePrimitiveMap('map_string_string', 'mapStringString', $this->map_string_string);
    $e->writeBytesMap('map_string_bytes', 'mapStringBytes', $this->map_string_bytes);
    $e->writeMessageMap('map_string_nested_message', 'mapStringNestedMessage', $this->map_string_nested_message);
    $e->writeMessageMap('map_string_foreign_message', 'mapStringForeignMessage', $this->map_string_foreign_message);
    $e->writeEnumMap('map_string_nested_enum', 'mapStringNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->map_string_nested_enum);
    $e->writeEnumMap('map_string_foreign_enum', 'mapStringForeignEnum', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->map_string_foreign_enum);
    $e->writePrimitiveList('packed_int32', 'packedInt32', $this->packed_int32);
    $e->writeInt64SignedList('packed_int64', 'packedInt64', $this->packed_int64);
    $e->writePrimitiveList('packed_uint32', 'packedUint32', $this->packed_uint32);
    $e->writeInt64UnsignedList('packed_uint64', 'packedUint64', $this->packed_uint64);
    $e->writePrimitiveList('packed_sint32', 'packedSint32', $this->packed_sint32);
    $e->writeInt64SignedList('packed_sint64', 'packedSint64', $this->packed_sint64);
    $e->writePrimitiveList('packed_fixed32', 'packedFixed32', $this->packed_fixed32);
    $e->writeInt64UnsignedList('packed_fixed64', 'packedFixed64', $this->packed_fixed64);
    $e->writePrimitiveList('packed_sfixed32', 'packedSfixed32', $this->packed_sfixed32);
    $e->writeInt64SignedList('packed_sfixed64', 'packedSfixed64', $this->packed_sfixed64);
    $e->writeFloatList('packed_float', 'packedFloat', $this->packed_float);
    $e->writeFloatList('packed_double', 'packedDouble', $this->packed_double);
    $e->writePrimitiveList('packed_bool', 'packedBool', $this->packed_bool);
    $e->writeEnumList('packed_nested_enum', 'packedNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->packed_nested_enum);
    $e->writePrimitiveList('unpacked_int32', 'unpackedInt32', $this->unpacked_int32);
    $e->writeInt64SignedList('unpacked_int64', 'unpackedInt64', $this->unpacked_int64);
    $e->writePrimitiveList('unpacked_uint32', 'unpackedUint32', $this->unpacked_uint32);
    $e->writeInt64UnsignedList('unpacked_uint64', 'unpackedUint64', $this->unpacked_uint64);
    $e->writePrimitiveList('unpacked_sint32', 'unpackedSint32', $this->unpacked_sint32);
    $e->writeInt64SignedList('unpacked_sint64', 'unpackedSint64', $this->unpacked_sint64);
    $e->writePrimitiveList('unpacked_fixed32', 'unpackedFixed32', $this->unpacked_fixed32);
    $e->writeInt64UnsignedList('unpacked_fixed64', 'unpackedFixed64', $this->unpacked_fixed64);
    $e->writePrimitiveList('unpacked_sfixed32', 'unpackedSfixed32', $this->unpacked_sfixed32);
    $e->writeInt64SignedList('unpacked_sfixed64', 'unpackedSfixed64', $this->unpacked_sfixed64);
    $e->writeFloatList('unpacked_float', 'unpackedFloat', $this->unpacked_float);
    $e->writeFloatList('unpacked_double', 'unpackedDouble', $this->unpacked_double);
    $e->writePrimitiveList('unpacked_bool', 'unpackedBool', $this->unpacked_bool);
    $e->writeEnumList('unpacked_nested_enum', 'unpackedNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->unpacked_nested_enum);
    $e->writeMessageMap('map_int32_nested_message', 'mapInt32NestedMessage', $this->map_int32_nested_message);
    $e->writePrimitiveMap('map_int32_bool', 'mapInt32Bool', $this->map_int32_bool);
    if ($this->hasData()) {
      $e->writeMessage('data', 'data', $this->data, false);
    }
    if ($this->hasMultiwordgroupfield()) {
      $e->writeMessage('multiwordgroupfield', 'multiwordgroupfield', $this->multiwordgroupfield, false);
    }
    if ($this->hasDefaultInt32()) {
      $e->writeInt32('default_int32', 'defaultInt32', $this->default_int32, false);
    }
    if ($this->hasDefaultInt64()) {
      $e->writeInt64Signed('default_int64', 'defaultInt64', $this->default_int64, false);
    }
    if ($this->hasDefaultUint32()) {
      $e->writeInt32('default_uint32', 'defaultUint32', $this->default_uint32, false);
    }
    if ($this->hasDefaultUint64()) {
      $e->writeInt64Unsigned('default_uint64', 'defaultUint64', $this->default_uint64, false);
    }
    if ($this->hasDefaultSint32()) {
      $e->writeInt32('default_sint32', 'defaultSint32', $this->default_sint32, false);
    }
    if ($this->hasDefaultSint64()) {
      $e->writeInt64Signed('default_sint64', 'defaultSint64', $this->default_sint64, false);
    }
    if ($this->hasDefaultFixed32()) {
      $e->writeInt32('default_fixed32', 'defaultFixed32', $this->default_fixed32, false);
    }
    if ($this->hasDefaultFixed64()) {
      $e->writeInt64Unsigned('default_fixed64', 'defaultFixed64', $this->default_fixed64, false);
    }
    if ($this->hasDefaultSfixed32()) {
      $e->writeInt32('default_sfixed32', 'defaultSfixed32', $this->default_sfixed32, false);
    }
    if ($this->hasDefaultSfixed64()) {
      $e->writeInt64Signed('default_sfixed64', 'defaultSfixed64', $this->default_sfixed64, false);
    }
    if ($this->hasDefaultFloat()) {
      $e->writeFloat('default_float', 'defaultFloat', $this->default_float, false);
    }
    if ($this->hasDefaultDouble()) {
      $e->writeFloat('default_double', 'defaultDouble', $this->default_double, false);
    }
    if ($this->hasDefaultBool()) {
      $e->writeBool('default_bool', 'defaultBool', $this->default_bool, false);
    }
    if ($this->hasDefaultString()) {
      $e->writeString('default_string', 'defaultString', $this->default_string, false);
    }
    if ($this->hasDefaultBytes()) {
      $e->writeBytes('default_bytes', 'defaultBytes', $this->default_bytes, false);
    }
    if ($this->hasFieldname1()) {
      $e->writeInt32('fieldname1', 'fieldname1', $this->fieldname1, false);
    }
    if ($this->hasFieldName2()) {
      $e->writeInt32('field_name2', 'fieldName2', $this->field_name2, false);
    }
    if ($this->hasFieldName3()) {
      $e->writeInt32('_field_name3', 'FieldName3', $this->_field_name3, false);
    }
    if ($this->hasFieldName4()) {
      $e->writeInt32('field__name4_', 'fieldName4', $this->field__name4_, false);
    }
    if ($this->hasField0name5()) {
      $e->writeInt32('field0name5', 'field0name5', $this->field0name5, false);
    }
    if ($this->hasField0Name6()) {
      $e->writeInt32('field_0_name6', 'field0Name6', $this->field_0_name6, false);
    }
    if ($this->hasFieldName7()) {
      $e->writeInt32('fieldName7', 'fieldName7', $this->fieldName7, false);
    }
    if ($this->hasFieldName8()) {
      $e->writeInt32('FieldName8', 'FieldName8', $this->FieldName8, false);
    }
    if ($this->hasFieldName9()) {
      $e->writeInt32('field_Name9', 'fieldName9', $this->field_Name9, false);
    }
    if ($this->hasFieldName10()) {
      $e->writeInt32('Field_Name10', 'FieldName10', $this->Field_Name10, false);
    }
    if ($this->hasFIELDNAME11()) {
      $e->writeInt32('FIELD_NAME11', 'FIELDNAME11', $this->FIELD_NAME11, false);
    }
    if ($this->hasFIELDName12()) {
      $e->writeInt32('FIELD_name12', 'FIELDName12', $this->FIELD_name12, false);
    }
    if ($this->hasFieldName13()) {
      $e->writeInt32('__field_name13', 'FieldName13', $this->__field_name13, false);
    }
    if ($this->hasFieldName14()) {
      $e->writeInt32('__Field_name14', 'FieldName14', $this->__Field_name14, false);
    }
    if ($this->hasFieldName15()) {
      $e->writeInt32('field__name15', 'fieldName15', $this->field__name15, false);
    }
    if ($this->hasFieldName16()) {
      $e->writeInt32('field__Name16', 'fieldName16', $this->field__Name16, false);
    }
    if ($this->hasFieldName17()) {
      $e->writeInt32('field_name17__', 'fieldName17', $this->field_name17__, false);
    }
    if ($this->hasFieldName18()) {
      $e->writeInt32('Field_name18__', 'FieldName18', $this->Field_name18__, false);
    }
    if ($this->hasMessageSetCorrect()) {
      $e->writeMessage('message_set_correct', 'messageSetCorrect', $this->message_set_correct, false);
    }
    $this->oneof_field->WriteJsonTo($e);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'optional_int32': case 'optionalInt32':
          $this->optional_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_optional_int32_set = true;
          break;
        case 'optional_int64': case 'optionalInt64':
          $this->optional_int64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_optional_int64_set = true;
          break;
        case 'optional_uint32': case 'optionalUint32':
          $this->optional_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          $this->was_optional_uint32_set = true;
          break;
        case 'optional_uint64': case 'optionalUint64':
          $this->optional_uint64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          $this->was_optional_uint64_set = true;
          break;
        case 'optional_sint32': case 'optionalSint32':
          $this->optional_sint32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_optional_sint32_set = true;
          break;
        case 'optional_sint64': case 'optionalSint64':
          $this->optional_sint64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_optional_sint64_set = true;
          break;
        case 'optional_fixed32': case 'optionalFixed32':
          $this->optional_fixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_optional_fixed32_set = true;
          break;
        case 'optional_fixed64': case 'optionalFixed64':
          $this->optional_fixed64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          $this->was_optional_fixed64_set = true;
          break;
        case 'optional_sfixed32': case 'optionalSfixed32':
          $this->optional_sfixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_optional_sfixed32_set = true;
          break;
        case 'optional_sfixed64': case 'optionalSfixed64':
          $this->optional_sfixed64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_optional_sfixed64_set = true;
          break;
        case 'optional_float': case 'optionalFloat':
          $this->optional_float = \Protobuf\Internal\JsonDecoder::readFloat($v);
          $this->was_optional_float_set = true;
          break;
        case 'optional_double': case 'optionalDouble':
          $this->optional_double = \Protobuf\Internal\JsonDecoder::readFloat($v);
          $this->was_optional_double_set = true;
          break;
        case 'optional_bool': case 'optionalBool':
          $this->optional_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_optional_bool_set = true;
          break;
        case 'optional_string': case 'optionalString':
          $this->optional_string = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_optional_string_set = true;
          break;
        case 'optional_bytes': case 'optionalBytes':
          $this->optional_bytes = \Protobuf\Internal\JsonDecoder::readBytes($v);
          $this->was_optional_bytes_set = true;
          break;
        case 'optional_nested_message': case 'optionalNestedMessage':
          if ($v is null) break;
          if ($this->optional_nested_message is null) {
            $this->optional_nested_message = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
            $this->was_optional_nested_message_set = true;
          }
          $this->optional_nested_message->MergeJsonFrom($v);
          break;
        case 'optional_foreign_message': case 'optionalForeignMessage':
          if ($v is null) break;
          if ($this->optional_foreign_message is null) {
            $this->optional_foreign_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
            $this->was_optional_foreign_message_set = true;
          }
          $this->optional_foreign_message->MergeJsonFrom($v);
          break;
        case 'optional_nested_enum': case 'optionalNestedEnum':
          $this->optional_nested_enum = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v);
          $this->was_optional_nested_enum_set = true;
          break;
        case 'optional_foreign_enum': case 'optionalForeignEnum':
          $this->optional_foreign_enum = \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($v);
          $this->was_optional_foreign_enum_set = true;
          break;
        case 'optional_string_piece': case 'optionalStringPiece':
          $this->optional_string_piece = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_optional_string_piece_set = true;
          break;
        case 'optional_cord': case 'optionalCord':
          $this->optional_cord = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_optional_cord_set = true;
          break;
        case 'recursive_message': case 'recursiveMessage':
          if ($v is null) break;
          if ($this->recursive_message is null) {
            $this->recursive_message = new \protobuf_test_messages\proto2\TestAllTypesProto2();
            $this->was_recursive_message_set = true;
          }
          $this->recursive_message->MergeJsonFrom($v);
          break;
        case 'repeated_int32': case 'repeatedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_int64': case 'repeatedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_uint32': case 'repeatedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'repeated_uint64': case 'repeatedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'repeated_sint32': case 'repeatedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_sint64': case 'repeatedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_fixed32': case 'repeatedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_fixed64': case 'repeatedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'repeated_sfixed32': case 'repeatedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_sfixed64': case 'repeatedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_float': case 'repeatedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'repeated_double': case 'repeatedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'repeated_bool': case 'repeatedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'repeated_string': case 'repeatedString':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_string []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'repeated_bytes': case 'repeatedBytes':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_bytes []= \Protobuf\Internal\JsonDecoder::readBytes($vv);
          }
          break;
        case 'repeated_nested_message': case 'repeatedNestedMessage':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
            $obj->MergeJsonFrom($vv);
            $this->repeated_nested_message []= $obj;
          }
          break;
        case 'repeated_foreign_message': case 'repeatedForeignMessage':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \protobuf_test_messages\proto2\ForeignMessageProto2();
            $obj->MergeJsonFrom($vv);
            $this->repeated_foreign_message []= $obj;
          }
          break;
        case 'repeated_nested_enum': case 'repeatedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($vv);
          }
          break;
        case 'repeated_foreign_enum': case 'repeatedForeignEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_foreign_enum []= \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($vv);
          }
          break;
        case 'repeated_string_piece': case 'repeatedStringPiece':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_string_piece []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'repeated_cord': case 'repeatedCord':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_cord []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'map_int32_int32': case 'mapInt32Int32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_int32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_int64_int64': case 'mapInt64Int64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int64_int64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_uint32_uint32': case 'mapUint32Uint32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_uint32_uint32[\Protobuf\Internal\JsonDecoder::readInt32Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
            }
          }
          break;
        case 'map_uint64_uint64': case 'mapUint64Uint64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_uint64_uint64[\Protobuf\Internal\JsonDecoder::readInt64Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
            }
          }
          break;
        case 'map_sint32_sint32': case 'mapSint32Sint32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sint32_sint32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_sint64_sint64': case 'mapSint64Sint64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sint64_sint64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_fixed32_fixed32': case 'mapFixed32Fixed32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_fixed32_fixed32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_fixed64_fixed64': case 'mapFixed64Fixed64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_fixed64_fixed64[\Protobuf\Internal\JsonDecoder::readInt64Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
            }
          }
          break;
        case 'map_sfixed32_sfixed32': case 'mapSfixed32Sfixed32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sfixed32_sfixed32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_sfixed64_sfixed64': case 'mapSfixed64Sfixed64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sfixed64_sfixed64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_int32_float': case 'mapInt32Float':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_float[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readFloat($v);
            }
          }
          break;
        case 'map_int32_double': case 'mapInt32Double':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_double[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readFloat($v);
            }
          }
          break;
        case 'map_bool_bool': case 'mapBoolBool':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_bool_bool[\Protobuf\Internal\JsonDecoder::readBoolMapKey($k)] = \Protobuf\Internal\JsonDecoder::readBool($v);
            }
          }
          break;
        case 'map_string_string': case 'mapStringString':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_string[\Protobuf\Internal\JsonDecoder::readString($k)] = \Protobuf\Internal\JsonDecoder::readString($v);
            }
          }
          break;
        case 'map_string_bytes': case 'mapStringBytes':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_bytes[\Protobuf\Internal\JsonDecoder::readString($k)] = \Protobuf\Internal\JsonDecoder::readBytes($v);
            }
          }
          break;
        case 'map_string_nested_message': case 'mapStringNestedMessage':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
              $obj->MergeJsonFrom($v);
              $this->map_string_nested_message[\Protobuf\Internal\JsonDecoder::readString($k)] = $obj;
            }
          }
          break;
        case 'map_string_foreign_message': case 'mapStringForeignMessage':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $obj = new \protobuf_test_messages\proto2\ForeignMessageProto2();
              $obj->MergeJsonFrom($v);
              $this->map_string_foreign_message[\Protobuf\Internal\JsonDecoder::readString($k)] = $obj;
            }
          }
          break;
        case 'map_string_nested_enum': case 'mapStringNestedEnum':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_nested_enum[\Protobuf\Internal\JsonDecoder::readString($k)] = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v);
            }
          }
          break;
        case 'map_string_foreign_enum': case 'mapStringForeignEnum':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_foreign_enum[\Protobuf\Internal\JsonDecoder::readString($k)] = \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($v);
            }
          }
          break;
        case 'packed_int32': case 'packedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_int64': case 'packedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_uint32': case 'packedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'packed_uint64': case 'packedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'packed_sint32': case 'packedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_sint64': case 'packedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_fixed32': case 'packedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_fixed64': case 'packedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'packed_sfixed32': case 'packedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_sfixed64': case 'packedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_float': case 'packedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'packed_double': case 'packedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'packed_bool': case 'packedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'packed_nested_enum': case 'packedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($vv);
          }
          break;
        case 'unpacked_int32': case 'unpackedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_int64': case 'unpackedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_uint32': case 'unpackedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'unpacked_uint64': case 'unpackedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'unpacked_sint32': case 'unpackedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_sint64': case 'unpackedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_fixed32': case 'unpackedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_fixed64': case 'unpackedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'unpacked_sfixed32': case 'unpackedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_sfixed64': case 'unpackedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_float': case 'unpackedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'unpacked_double': case 'unpackedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'unpacked_bool': case 'unpackedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'unpacked_nested_enum': case 'unpackedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($vv);
          }
          break;
        case 'map_int32_nested_message': case 'mapInt32NestedMessage':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
              $obj->MergeJsonFrom($v);
              $this->map_int32_nested_message[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = $obj;
            }
          }
          break;
        case 'map_int32_bool': case 'mapInt32Bool':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_bool[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readBool($v);
            }
          }
          break;
        case 'oneof_uint32': case 'oneofUint32':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_uint32(\Protobuf\Internal\JsonDecoder::readInt32Unsigned($v));
          break;
        case 'oneof_nested_message': case 'oneofNestedMessage':
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $obj->MergeJsonFrom($v);
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_nested_message($obj);
          break;
        case 'oneof_string': case 'oneofString':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_string(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'oneof_bytes': case 'oneofBytes':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_bytes(\Protobuf\Internal\JsonDecoder::readBytes($v));
          break;
        case 'oneof_bool': case 'oneofBool':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_bool(\Protobuf\Internal\JsonDecoder::readBool($v));
          break;
        case 'oneof_uint64': case 'oneofUint64':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_uint64(\Protobuf\Internal\JsonDecoder::readInt64Unsigned($v));
          break;
        case 'oneof_float': case 'oneofFloat':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_float(\Protobuf\Internal\JsonDecoder::readFloat($v));
          break;
        case 'oneof_double': case 'oneofDouble':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_double(\Protobuf\Internal\JsonDecoder::readFloat($v));
          break;
        case 'oneof_enum': case 'oneofEnum':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_enum(\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v));
          break;
        case 'data':
          if ($v is null) break;
          if ($this->data is null) {
            $this->data = new \protobuf_test_messages\proto2\TestAllTypesProto2_Data();
            $this->was_data_set = true;
          }
          $this->data->MergeJsonFrom($v);
          break;
        case 'multiwordgroupfield':
          if ($v is null) break;
          if ($this->multiwordgroupfield is null) {
            $this->multiwordgroupfield = new \protobuf_test_messages\proto2\TestAllTypesProto2_MultiWordGroupField();
            $this->was_multiwordgroupfield_set = true;
          }
          $this->multiwordgroupfield->MergeJsonFrom($v);
          break;
        case 'default_int32': case 'defaultInt32':
          $this->default_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_default_int32_set = true;
          break;
        case 'default_int64': case 'defaultInt64':
          $this->default_int64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_default_int64_set = true;
          break;
        case 'default_uint32': case 'defaultUint32':
          $this->default_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          $this->was_default_uint32_set = true;
          break;
        case 'default_uint64': case 'defaultUint64':
          $this->default_uint64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          $this->was_default_uint64_set = true;
          break;
        case 'default_sint32': case 'defaultSint32':
          $this->default_sint32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_default_sint32_set = true;
          break;
        case 'default_sint64': case 'defaultSint64':
          $this->default_sint64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_default_sint64_set = true;
          break;
        case 'default_fixed32': case 'defaultFixed32':
          $this->default_fixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_default_fixed32_set = true;
          break;
        case 'default_fixed64': case 'defaultFixed64':
          $this->default_fixed64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          $this->was_default_fixed64_set = true;
          break;
        case 'default_sfixed32': case 'defaultSfixed32':
          $this->default_sfixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_default_sfixed32_set = true;
          break;
        case 'default_sfixed64': case 'defaultSfixed64':
          $this->default_sfixed64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          $this->was_default_sfixed64_set = true;
          break;
        case 'default_float': case 'defaultFloat':
          $this->default_float = \Protobuf\Internal\JsonDecoder::readFloat($v);
          $this->was_default_float_set = true;
          break;
        case 'default_double': case 'defaultDouble':
          $this->default_double = \Protobuf\Internal\JsonDecoder::readFloat($v);
          $this->was_default_double_set = true;
          break;
        case 'default_bool': case 'defaultBool':
          $this->default_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_default_bool_set = true;
          break;
        case 'default_string': case 'defaultString':
          $this->default_string = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_default_string_set = true;
          break;
        case 'default_bytes': case 'defaultBytes':
          $this->default_bytes = \Protobuf\Internal\JsonDecoder::readBytes($v);
          $this->was_default_bytes_set = true;
          break;
        case 'fieldname1':
          $this->fieldname1 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_fieldname1_set = true;
          break;
        case 'field_name2': case 'fieldName2':
          $this->field_name2 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_field_name2_set = true;
          break;
        case '_field_name3': case 'FieldName3':
          $this->_field_name3 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was__field_name3_set = true;
          break;
        case 'field__name4_': case 'fieldName4':
          $this->field__name4_ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_field__name4__set = true;
          break;
        case 'field0name5':
          $this->field0name5 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_field0name5_set = true;
          break;
        case 'field_0_name6': case 'field0Name6':
          $this->field_0_name6 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_field_0_name6_set = true;
          break;
        case 'fieldName7':
          $this->fieldName7 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_fieldName7_set = true;
          break;
        case 'FieldName8':
          $this->FieldName8 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_FieldName8_set = true;
          break;
        case 'field_Name9': case 'fieldName9':
          $this->field_Name9 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_field_Name9_set = true;
          break;
        case 'Field_Name10': case 'FieldName10':
          $this->Field_Name10 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_Field_Name10_set = true;
          break;
        case 'FIELD_NAME11': case 'FIELDNAME11':
          $this->FIELD_NAME11 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_FIELD_NAME11_set = true;
          break;
        case 'FIELD_name12': case 'FIELDName12':
          $this->FIELD_name12 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_FIELD_name12_set = true;
          break;
        case '__field_name13': case 'FieldName13':
          $this->__field_name13 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was___field_name13_set = true;
          break;
        case '__Field_name14': case 'FieldName14':
          $this->__Field_name14 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was___Field_name14_set = true;
          break;
        case 'field__name15': case 'fieldName15':
          $this->field__name15 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_field__name15_set = true;
          break;
        case 'field__Name16': case 'fieldName16':
          $this->field__Name16 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_field__Name16_set = true;
          break;
        case 'field_name17__': case 'fieldName17':
          $this->field_name17__ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_field_name17___set = true;
          break;
        case 'Field_name18__': case 'FieldName18':
          $this->Field_name18__ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_Field_name18___set = true;
          break;
        case 'message_set_correct': case 'messageSetCorrect':
          if ($v is null) break;
          if ($this->message_set_correct is null) {
            $this->message_set_correct = new \protobuf_test_messages\proto2\TestAllTypesProto2_MessageSetCorrect();
            $this->was_message_set_correct_set = true;
          }
          $this->message_set_correct->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasOptionalInt32()) {
      $this->setOptionalInt32($o->getOptionalInt32());
    }
    if ($o->hasOptionalInt64()) {
      $this->setOptionalInt64($o->getOptionalInt64());
    }
    if ($o->hasOptionalUint32()) {
      $this->setOptionalUint32($o->getOptionalUint32());
    }
    if ($o->hasOptionalUint64()) {
      $this->setOptionalUint64($o->getOptionalUint64());
    }
    if ($o->hasOptionalSint32()) {
      $this->setOptionalSint32($o->getOptionalSint32());
    }
    if ($o->hasOptionalSint64()) {
      $this->setOptionalSint64($o->getOptionalSint64());
    }
    if ($o->hasOptionalFixed32()) {
      $this->setOptionalFixed32($o->getOptionalFixed32());
    }
    if ($o->hasOptionalFixed64()) {
      $this->setOptionalFixed64($o->getOptionalFixed64());
    }
    if ($o->hasOptionalSfixed32()) {
      $this->setOptionalSfixed32($o->getOptionalSfixed32());
    }
    if ($o->hasOptionalSfixed64()) {
      $this->setOptionalSfixed64($o->getOptionalSfixed64());
    }
    if ($o->hasOptionalFloat()) {
      $this->setOptionalFloat($o->getOptionalFloat());
    }
    if ($o->hasOptionalDouble()) {
      $this->setOptionalDouble($o->getOptionalDouble());
    }
    if ($o->hasOptionalBool()) {
      $this->setOptionalBool($o->getOptionalBool());
    }
    if ($o->hasOptionalString()) {
      $this->setOptionalString($o->getOptionalString());
    }
    if ($o->hasOptionalBytes()) {
      $this->setOptionalBytes($o->getOptionalBytes());
    }
    $tmp = $o->optional_nested_message;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->setOptionalNestedMessage($nv);
    } else if ($o->hasOptionalNestedMessage()) {
      $this->setOptionalNestedMessage(null);
    }
    $tmp = $o->optional_foreign_message;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($tmp);
      $this->setOptionalForeignMessage($nv);
    } else if ($o->hasOptionalForeignMessage()) {
      $this->setOptionalForeignMessage(null);
    }
    if ($o->hasOptionalNestedEnum()) {
      $this->setOptionalNestedEnum($o->getOptionalNestedEnum());
    }
    if ($o->hasOptionalForeignEnum()) {
      $this->setOptionalForeignEnum($o->getOptionalForeignEnum());
    }
    if ($o->hasOptionalStringPiece()) {
      $this->setOptionalStringPiece($o->getOptionalStringPiece());
    }
    if ($o->hasOptionalCord()) {
      $this->setOptionalCord($o->getOptionalCord());
    }
    $tmp = $o->recursive_message;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2();
      $nv->CopyFrom($tmp);
      $this->setRecursiveMessage($nv);
    } else if ($o->hasRecursiveMessage()) {
      $this->setRecursiveMessage(null);
    }
    $this->repeated_int32 = $o->repeated_int32;
    $this->repeated_int64 = $o->repeated_int64;
    $this->repeated_uint32 = $o->repeated_uint32;
    $this->repeated_uint64 = $o->repeated_uint64;
    $this->repeated_sint32 = $o->repeated_sint32;
    $this->repeated_sint64 = $o->repeated_sint64;
    $this->repeated_fixed32 = $o->repeated_fixed32;
    $this->repeated_fixed64 = $o->repeated_fixed64;
    $this->repeated_sfixed32 = $o->repeated_sfixed32;
    $this->repeated_sfixed64 = $o->repeated_sfixed64;
    $this->repeated_float = $o->repeated_float;
    $this->repeated_double = $o->repeated_double;
    $this->repeated_bool = $o->repeated_bool;
    $this->repeated_string = $o->repeated_string;
    $this->repeated_bytes = $o->repeated_bytes;
    foreach ($o->repeated_nested_message as $v) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($v);
      $this->repeated_nested_message []= $nv;
    }
    foreach ($o->repeated_foreign_message as $v) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($v);
      $this->repeated_foreign_message []= $nv;
    }
    $this->repeated_nested_enum = $o->repeated_nested_enum;
    $this->repeated_foreign_enum = $o->repeated_foreign_enum;
    $this->repeated_string_piece = $o->repeated_string_piece;
    $this->repeated_cord = $o->repeated_cord;
    $this->map_int32_int32 = $o->map_int32_int32;
    $this->map_int64_int64 = $o->map_int64_int64;
    $this->map_uint32_uint32 = $o->map_uint32_uint32;
    $this->map_uint64_uint64 = $o->map_uint64_uint64;
    $this->map_sint32_sint32 = $o->map_sint32_sint32;
    $this->map_sint64_sint64 = $o->map_sint64_sint64;
    $this->map_fixed32_fixed32 = $o->map_fixed32_fixed32;
    $this->map_fixed64_fixed64 = $o->map_fixed64_fixed64;
    $this->map_sfixed32_sfixed32 = $o->map_sfixed32_sfixed32;
    $this->map_sfixed64_sfixed64 = $o->map_sfixed64_sfixed64;
    $this->map_int32_float = $o->map_int32_float;
    $this->map_int32_double = $o->map_int32_double;
    $this->map_bool_bool = $o->map_bool_bool;
    $this->map_string_string = $o->map_string_string;
    $this->map_string_bytes = $o->map_string_bytes;
    foreach ($o->map_string_nested_message as $k => $v) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($v);
      $this->map_string_nested_message[$k] = $nv;
    }
    foreach ($o->map_string_foreign_message as $k => $v) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($v);
      $this->map_string_foreign_message[$k] = $nv;
    }
    $this->map_string_nested_enum = $o->map_string_nested_enum;
    $this->map_string_foreign_enum = $o->map_string_foreign_enum;
    $this->packed_int32 = $o->packed_int32;
    $this->packed_int64 = $o->packed_int64;
    $this->packed_uint32 = $o->packed_uint32;
    $this->packed_uint64 = $o->packed_uint64;
    $this->packed_sint32 = $o->packed_sint32;
    $this->packed_sint64 = $o->packed_sint64;
    $this->packed_fixed32 = $o->packed_fixed32;
    $this->packed_fixed64 = $o->packed_fixed64;
    $this->packed_sfixed32 = $o->packed_sfixed32;
    $this->packed_sfixed64 = $o->packed_sfixed64;
    $this->packed_float = $o->packed_float;
    $this->packed_double = $o->packed_double;
    $this->packed_bool = $o->packed_bool;
    $this->packed_nested_enum = $o->packed_nested_enum;
    $this->unpacked_int32 = $o->unpacked_int32;
    $this->unpacked_int64 = $o->unpacked_int64;
    $this->unpacked_uint32 = $o->unpacked_uint32;
    $this->unpacked_uint64 = $o->unpacked_uint64;
    $this->unpacked_sint32 = $o->unpacked_sint32;
    $this->unpacked_sint64 = $o->unpacked_sint64;
    $this->unpacked_fixed32 = $o->unpacked_fixed32;
    $this->unpacked_fixed64 = $o->unpacked_fixed64;
    $this->unpacked_sfixed32 = $o->unpacked_sfixed32;
    $this->unpacked_sfixed64 = $o->unpacked_sfixed64;
    $this->unpacked_float = $o->unpacked_float;
    $this->unpacked_double = $o->unpacked_double;
    $this->unpacked_bool = $o->unpacked_bool;
    $this->unpacked_nested_enum = $o->unpacked_nested_enum;
    foreach ($o->map_int32_nested_message as $k => $v) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($v);
      $this->map_int32_nested_message[$k] = $nv;
    }
    $this->map_int32_bool = $o->map_int32_bool;
    $tmp = $o->data;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_Data();
      $nv->CopyFrom($tmp);
      $this->setData($nv);
    } else if ($o->hasData()) {
      $this->setData(null);
    }
    $tmp = $o->multiwordgroupfield;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_MultiWordGroupField();
      $nv->CopyFrom($tmp);
      $this->setMultiwordgroupfield($nv);
    } else if ($o->hasMultiwordgroupfield()) {
      $this->setMultiwordgroupfield(null);
    }
    if ($o->hasDefaultInt32()) {
      $this->setDefaultInt32($o->getDefaultInt32());
    }
    if ($o->hasDefaultInt64()) {
      $this->setDefaultInt64($o->getDefaultInt64());
    }
    if ($o->hasDefaultUint32()) {
      $this->setDefaultUint32($o->getDefaultUint32());
    }
    if ($o->hasDefaultUint64()) {
      $this->setDefaultUint64($o->getDefaultUint64());
    }
    if ($o->hasDefaultSint32()) {
      $this->setDefaultSint32($o->getDefaultSint32());
    }
    if ($o->hasDefaultSint64()) {
      $this->setDefaultSint64($o->getDefaultSint64());
    }
    if ($o->hasDefaultFixed32()) {
      $this->setDefaultFixed32($o->getDefaultFixed32());
    }
    if ($o->hasDefaultFixed64()) {
      $this->setDefaultFixed64($o->getDefaultFixed64());
    }
    if ($o->hasDefaultSfixed32()) {
      $this->setDefaultSfixed32($o->getDefaultSfixed32());
    }
    if ($o->hasDefaultSfixed64()) {
      $this->setDefaultSfixed64($o->getDefaultSfixed64());
    }
    if ($o->hasDefaultFloat()) {
      $this->setDefaultFloat($o->getDefaultFloat());
    }
    if ($o->hasDefaultDouble()) {
      $this->setDefaultDouble($o->getDefaultDouble());
    }
    if ($o->hasDefaultBool()) {
      $this->setDefaultBool($o->getDefaultBool());
    }
    if ($o->hasDefaultString()) {
      $this->setDefaultString($o->getDefaultString());
    }
    if ($o->hasDefaultBytes()) {
      $this->setDefaultBytes($o->getDefaultBytes());
    }
    if ($o->hasFieldname1()) {
      $this->setFieldname1($o->getFieldname1());
    }
    if ($o->hasFieldName2()) {
      $this->setFieldName2($o->getFieldName2());
    }
    if ($o->hasFieldName3()) {
      $this->setFieldName3($o->getFieldName3());
    }
    if ($o->hasFieldName4()) {
      $this->setFieldName4($o->getFieldName4());
    }
    if ($o->hasField0name5()) {
      $this->setField0name5($o->getField0name5());
    }
    if ($o->hasField0Name6()) {
      $this->setField0Name6($o->getField0Name6());
    }
    if ($o->hasFieldName7()) {
      $this->setFieldName7($o->getFieldName7());
    }
    if ($o->hasFieldName8()) {
      $this->setFieldName8($o->getFieldName8());
    }
    if ($o->hasFieldName9()) {
      $this->setFieldName9($o->getFieldName9());
    }
    if ($o->hasFieldName10()) {
      $this->setFieldName10($o->getFieldName10());
    }
    if ($o->hasFIELDNAME11()) {
      $this->setFIELDNAME11($o->getFIELDNAME11());
    }
    if ($o->hasFIELDName12()) {
      $this->setFIELDName12($o->getFIELDName12());
    }
    if ($o->hasFieldName13()) {
      $this->setFieldName13($o->getFieldName13());
    }
    if ($o->hasFieldName14()) {
      $this->setFieldName14($o->getFieldName14());
    }
    if ($o->hasFieldName15()) {
      $this->setFieldName15($o->getFieldName15());
    }
    if ($o->hasFieldName16()) {
      $this->setFieldName16($o->getFieldName16());
    }
    if ($o->hasFieldName17()) {
      $this->setFieldName17($o->getFieldName17());
    }
    if ($o->hasFieldName18()) {
      $this->setFieldName18($o->getFieldName18());
    }
    $tmp = $o->message_set_correct;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_MessageSetCorrect();
      $nv->CopyFrom($tmp);
      $this->setMessageSetCorrect($nv);
    } else if ($o->hasMessageSetCorrect()) {
      $this->setMessageSetCorrect(null);
    }
    $this->oneof_field = $o->oneof_field->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ForeignMessageProto2 implements \Protobuf\Message {
  private int $c;
  private bool $was_c_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'c' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'c')) {
      $this->c = $s['c'];
      $this->was_c_set = true;
    } else {
      $this->c = 0;
      $this->was_c_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getC(): int {
    return $this->c;
  }

  public function setC(int $v): void {
    $this->c = $v;
    $this->was_c_set = true;
  }

  public function hasC(): bool {
    return $this->was_c_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.ForeignMessageProto2";
  }

  public static function ParseFrom(string $input): ?ForeignMessageProto2 {
    $msg = new ForeignMessageProto2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->c = $d->readVarint32Signed();
          $this->was_c_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_c_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->c);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasC()) {
      $e->writeInt32('c', 'c', $this->c, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'c':
          $this->c = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_c_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ForeignMessageProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasC()) {
      $this->setC($o->getC());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class GroupField implements \Protobuf\Message {
  private int $group_int32;
  private bool $was_group_int32_set;
  private int $group_uint32;
  private bool $was_group_uint32_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'group_int32' => int,
    ?'group_uint32' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'group_int32')) {
      $this->group_int32 = $s['group_int32'];
      $this->was_group_int32_set = true;
    } else {
      $this->group_int32 = 0;
      $this->was_group_int32_set = false;
    }
    if (Shapes::keyExists($s, 'group_uint32')) {
      $this->group_uint32 = $s['group_uint32'];
      $this->was_group_uint32_set = true;
    } else {
      $this->group_uint32 = 0;
      $this->was_group_uint32_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getGroupInt32(): int {
    return $this->group_int32;
  }

  public function setGroupInt32(int $v): void {
    $this->group_int32 = $v;
    $this->was_group_int32_set = true;
  }

  public function hasGroupInt32(): bool {
    return $this->was_group_int32_set;
  }

  public function getGroupUint32(): int {
    return $this->group_uint32;
  }

  public function setGroupUint32(int $v): void {
    $this->group_uint32 = $v;
    $this->was_group_uint32_set = true;
  }

  public function hasGroupUint32(): bool {
    return $this->was_group_uint32_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.GroupField";
  }

  public static function ParseFrom(string $input): ?GroupField {
    $msg = new GroupField();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 122:
          $this->group_int32 = $d->readVarint32Signed();
          $this->was_group_int32_set = true;
          break;
        case 123:
          $this->group_uint32 = $d->readVarint32();
          $this->was_group_uint32_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_group_int32_set) {
      $e->writeTag(122, 0);
      $e->writeVarint($this->group_int32);
    }
    if ($this->was_group_uint32_set) {
      $e->writeTag(123, 0);
      $e->writeVarint($this->group_uint32);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasGroupInt32()) {
      $e->writeInt32('group_int32', 'groupInt32', $this->group_int32, false);
    }
    if ($this->hasGroupUint32()) {
      $e->writeInt32('group_uint32', 'groupUint32', $this->group_uint32, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'group_int32': case 'groupInt32':
          $this->group_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_group_int32_set = true;
          break;
        case 'group_uint32': case 'groupUint32':
          $this->group_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          $this->was_group_uint32_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is GroupField)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasGroupInt32()) {
      $this->setGroupInt32($o->getGroupInt32());
    }
    if ($o->hasGroupUint32()) {
      $this->setGroupUint32($o->getGroupUint32());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UnknownToTestAllTypes_OptionalGroup implements \Protobuf\Message {
  private int $a;
  private bool $was_a_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'a' => int,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'a')) {
      $this->a = $s['a'];
      $this->was_a_set = true;
    } else {
      $this->a = 0;
      $this->was_a_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getA(): int {
    return $this->a;
  }

  public function setA(int $v): void {
    $this->a = $v;
    $this->was_a_set = true;
  }

  public function hasA(): bool {
    return $this->was_a_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.UnknownToTestAllTypes.OptionalGroup";
  }

  public static function ParseFrom(string $input): ?UnknownToTestAllTypes_OptionalGroup {
    $msg = new UnknownToTestAllTypes_OptionalGroup();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->a = $d->readVarint32Signed();
          $this->was_a_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_a_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->a);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasA()) {
      $e->writeInt32('a', 'a', $this->a, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'a':
          $this->a = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_a_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UnknownToTestAllTypes_OptionalGroup)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasA()) {
      $this->setA($o->getA());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UnknownToTestAllTypes implements \Protobuf\Message {
  private int $optional_int32;
  private bool $was_optional_int32_set;
  private string $optional_string;
  private bool $was_optional_string_set;
  private ?\protobuf_test_messages\proto2\ForeignMessageProto2 $nested_message;
  private bool $was_nested_message_set;
  private ?\protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup $optionalgroup;
  private bool $was_optionalgroup_set;
  private bool $optional_bool;
  private bool $was_optional_bool_set;
  public vec<int> $repeated_int32;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'optional_int32' => int,
    ?'optional_string' => string,
    ?'nested_message' => ?\protobuf_test_messages\proto2\ForeignMessageProto2,
    ?'optionalgroup' => ?\protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup,
    ?'optional_bool' => bool,
    ?'repeated_int32' => vec<int>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'optional_int32')) {
      $this->optional_int32 = $s['optional_int32'];
      $this->was_optional_int32_set = true;
    } else {
      $this->optional_int32 = 0;
      $this->was_optional_int32_set = false;
    }
    if (Shapes::keyExists($s, 'optional_string')) {
      $this->optional_string = $s['optional_string'];
      $this->was_optional_string_set = true;
    } else {
      $this->optional_string = '';
      $this->was_optional_string_set = false;
    }
    if (Shapes::keyExists($s, 'nested_message')) {
      $this->nested_message = $s['nested_message'];
      $this->was_nested_message_set = true;
    } else {
      $this->nested_message = null;
      $this->was_nested_message_set = false;
    }
    if (Shapes::keyExists($s, 'optionalgroup')) {
      $this->optionalgroup = $s['optionalgroup'];
      $this->was_optionalgroup_set = true;
    } else {
      $this->optionalgroup = null;
      $this->was_optionalgroup_set = false;
    }
    if (Shapes::keyExists($s, 'optional_bool')) {
      $this->optional_bool = $s['optional_bool'];
      $this->was_optional_bool_set = true;
    } else {
      $this->optional_bool = false;
      $this->was_optional_bool_set = false;
    }
    $this->repeated_int32 = $s['repeated_int32'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getOptionalInt32(): int {
    return $this->optional_int32;
  }

  public function setOptionalInt32(int $v): void {
    $this->optional_int32 = $v;
    $this->was_optional_int32_set = true;
  }

  public function hasOptionalInt32(): bool {
    return $this->was_optional_int32_set;
  }

  public function getOptionalString(): string {
    return $this->optional_string;
  }

  public function setOptionalString(string $v): void {
    $this->optional_string = $v;
    $this->was_optional_string_set = true;
  }

  public function hasOptionalString(): bool {
    return $this->was_optional_string_set;
  }

  public function getNestedMessage(): ?\protobuf_test_messages\proto2\ForeignMessageProto2 {
    return $this->nested_message;
  }

  public function setNestedMessage(?\protobuf_test_messages\proto2\ForeignMessageProto2 $v): void {
    $this->nested_message = $v;
    $this->was_nested_message_set = true;
  }

  public function hasNestedMessage(): bool {
    return $this->was_nested_message_set;
  }

  public function getOptionalgroup(): ?\protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup {
    return $this->optionalgroup;
  }

  public function setOptionalgroup(?\protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup $v): void {
    $this->optionalgroup = $v;
    $this->was_optionalgroup_set = true;
  }

  public function hasOptionalgroup(): bool {
    return $this->was_optionalgroup_set;
  }

  public function getOptionalBool(): bool {
    return $this->optional_bool;
  }

  public function setOptionalBool(bool $v): void {
    $this->optional_bool = $v;
    $this->was_optional_bool_set = true;
  }

  public function hasOptionalBool(): bool {
    return $this->was_optional_bool_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.UnknownToTestAllTypes";
  }

  public static function ParseFrom(string $input): ?UnknownToTestAllTypes {
    $msg = new UnknownToTestAllTypes();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1001:
          $this->optional_int32 = $d->readVarint32Signed();
          $this->was_optional_int32_set = true;
          break;
        case 1002:
          $this->optional_string = $d->readString();
          $this->was_optional_string_set = true;
          break;
        case 1003:
          if ($this->nested_message is null) {
            $this->nested_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
            $this->was_nested_message_set = true;
          }
          $this->nested_message->MergeFrom($d->readDecoder());
          break;
        case 1004:
          if ($this->optionalgroup is null) {
            $this->optionalgroup = new \protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup();
            $this->was_optionalgroup_set = true;
          }
          $this->optionalgroup->MergeFrom($d->readDecoder());
          break;
        case 1006:
          $this->optional_bool = $d->readBool();
          $this->was_optional_bool_set = true;
          break;
        case 1011:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->repeated_int32 []= $d->readVarint32Signed();
          }
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_optional_int32_set) {
      $e->writeTag(1001, 0);
      $e->writeVarint($this->optional_int32);
    }
    if ($this->was_optional_string_set) {
      $e->writeTag(1002, 2);
      $e->writeString($this->optional_string);
    }
    $msg = $this->nested_message;
    if ($msg != null) {
      if ($this->was_nested_message_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 1003);
      }
    }
    $msg = $this->optionalgroup;
    if ($msg != null) {
      if ($this->was_optionalgroup_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 1004);
      }
    }
    if ($this->was_optional_bool_set) {
      $e->writeTag(1006, 0);
      $e->writeBool($this->optional_bool);
    }
    foreach ($this->repeated_int32 as $elem) {
      $e->writeTag(1011, 0);
      $e->writeVarint($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasOptionalInt32()) {
      $e->writeInt32('optional_int32', 'optionalInt32', $this->optional_int32, false);
    }
    if ($this->hasOptionalString()) {
      $e->writeString('optional_string', 'optionalString', $this->optional_string, false);
    }
    if ($this->hasNestedMessage()) {
      $e->writeMessage('nested_message', 'nestedMessage', $this->nested_message, false);
    }
    if ($this->hasOptionalgroup()) {
      $e->writeMessage('optionalgroup', 'optionalgroup', $this->optionalgroup, false);
    }
    if ($this->hasOptionalBool()) {
      $e->writeBool('optional_bool', 'optionalBool', $this->optional_bool, false);
    }
    $e->writePrimitiveList('repeated_int32', 'repeatedInt32', $this->repeated_int32);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'optional_int32': case 'optionalInt32':
          $this->optional_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_optional_int32_set = true;
          break;
        case 'optional_string': case 'optionalString':
          $this->optional_string = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_optional_string_set = true;
          break;
        case 'nested_message': case 'nestedMessage':
          if ($v is null) break;
          if ($this->nested_message is null) {
            $this->nested_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
            $this->was_nested_message_set = true;
          }
          $this->nested_message->MergeJsonFrom($v);
          break;
        case 'optionalgroup':
          if ($v is null) break;
          if ($this->optionalgroup is null) {
            $this->optionalgroup = new \protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup();
            $this->was_optionalgroup_set = true;
          }
          $this->optionalgroup->MergeJsonFrom($v);
          break;
        case 'optional_bool': case 'optionalBool':
          $this->optional_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_optional_bool_set = true;
          break;
        case 'repeated_int32': case 'repeatedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UnknownToTestAllTypes)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasOptionalInt32()) {
      $this->setOptionalInt32($o->getOptionalInt32());
    }
    if ($o->hasOptionalString()) {
      $this->setOptionalString($o->getOptionalString());
    }
    $tmp = $o->nested_message;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($tmp);
      $this->setNestedMessage($nv);
    } else if ($o->hasNestedMessage()) {
      $this->setNestedMessage(null);
    }
    $tmp = $o->optionalgroup;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup();
      $nv->CopyFrom($tmp);
      $this->setOptionalgroup($nv);
    } else if ($o->hasOptionalgroup()) {
      $this->setOptionalgroup(null);
    }
    if ($o->hasOptionalBool()) {
      $this->setOptionalBool($o->getOptionalBool());
    }
    $this->repeated_int32 = $o->repeated_int32;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class NullHypothesisProto2 implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.NullHypothesisProto2";
  }

  public static function ParseFrom(string $input): ?NullHypothesisProto2 {
    $msg = new NullHypothesisProto2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is NullHypothesisProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype EnumOnlyProto2_Bool_enum_t as int = int;
abstract class EnumOnlyProto2_Bool {
  const EnumOnlyProto2_Bool_enum_t kFalse = 0;
  const EnumOnlyProto2_Bool_enum_t kTrue = 1;
  private static dict<int, string> $itos = dict[
    0 => 'kFalse',
    1 => 'kTrue',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'kFalse' => 0,
    'kTrue' => 1,
  ];
  public static function FromMixed(mixed $m): EnumOnlyProto2_Bool_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): EnumOnlyProto2_Bool_enum_t {
    return $i;
  }
}

class EnumOnlyProto2 implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.EnumOnlyProto2";
  }

  public static function ParseFrom(string $input): ?EnumOnlyProto2 {
    $msg = new EnumOnlyProto2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumOnlyProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class OneStringProto2 implements \Protobuf\Message {
  private string $data;
  private bool $was_data_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'data' => string,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'data')) {
      $this->data = $s['data'];
      $this->was_data_set = true;
    } else {
      $this->data = '';
      $this->was_data_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getData(): string {
    return $this->data;
  }

  public function setData(string $v): void {
    $this->data = $v;
    $this->was_data_set = true;
  }

  public function hasData(): bool {
    return $this->was_data_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.OneStringProto2";
  }

  public static function ParseFrom(string $input): ?OneStringProto2 {
    $msg = new OneStringProto2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->data = $d->readString();
          $this->was_data_set = true;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_data_set) {
      $e->writeTag(1, 2);
      $e->writeString($this->data);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasData()) {
      $e->writeString('data', 'data', $this->data, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'data':
          $this->data = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_data_set = true;
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is OneStringProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasData()) {
      $this->setData($o->getData());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ProtoWithKeywords implements \Protobuf\Message {
  private int $inline;
  private bool $was_inline_set;
  private string $concept;
  private bool $was_concept_set;
  public vec<string> $requires;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'inline' => int,
    ?'concept' => string,
    ?'requires' => vec<string>,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'inline')) {
      $this->inline = $s['inline'];
      $this->was_inline_set = true;
    } else {
      $this->inline = 0;
      $this->was_inline_set = false;
    }
    if (Shapes::keyExists($s, 'concept')) {
      $this->concept = $s['concept'];
      $this->was_concept_set = true;
    } else {
      $this->concept = '';
      $this->was_concept_set = false;
    }
    $this->requires = $s['requires'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function getInline(): int {
    return $this->inline;
  }

  public function setInline(int $v): void {
    $this->inline = $v;
    $this->was_inline_set = true;
  }

  public function hasInline(): bool {
    return $this->was_inline_set;
  }

  public function getConcept(): string {
    return $this->concept;
  }

  public function setConcept(string $v): void {
    $this->concept = $v;
    $this->was_concept_set = true;
  }

  public function hasConcept(): bool {
    return $this->was_concept_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.ProtoWithKeywords";
  }

  public static function ParseFrom(string $input): ?ProtoWithKeywords {
    $msg = new ProtoWithKeywords();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->inline = $d->readVarint32Signed();
          $this->was_inline_set = true;
          break;
        case 2:
          $this->concept = $d->readString();
          $this->was_concept_set = true;
          break;
        case 3:
          $this->requires []= $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_inline_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->inline);
    }
    if ($this->was_concept_set) {
      $e->writeTag(2, 2);
      $e->writeString($this->concept);
    }
    foreach ($this->requires as $elem) {
      $e->writeTag(3, 2);
      $e->writeString($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasInline()) {
      $e->writeInt32('inline', 'inline', $this->inline, false);
    }
    if ($this->hasConcept()) {
      $e->writeString('concept', 'concept', $this->concept, false);
    }
    $e->writePrimitiveList('requires', 'requires', $this->requires);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'inline':
          $this->inline = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          $this->was_inline_set = true;
          break;
        case 'concept':
          $this->concept = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_concept_set = true;
          break;
        case 'requires':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->requires []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ProtoWithKeywords)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasInline()) {
      $this->setInline($o->getInline());
    }
    if ($o->hasConcept()) {
      $this->setConcept($o->getConcept());
    }
    $this->requires = $o->requires;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype TestAllRequiredTypesProto2_NestedEnum_enum_t as int = int;
abstract class TestAllRequiredTypesProto2_NestedEnum {
  const TestAllRequiredTypesProto2_NestedEnum_enum_t FOO = 0;
  const TestAllRequiredTypesProto2_NestedEnum_enum_t BAR = 1;
  const TestAllRequiredTypesProto2_NestedEnum_enum_t BAZ = 2;
  const TestAllRequiredTypesProto2_NestedEnum_enum_t NEG = -1;
  private static dict<int, string> $itos = dict[
    0 => 'FOO',
    1 => 'BAR',
    2 => 'BAZ',
    -1 => 'NEG',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FOO' => 0,
    'BAR' => 1,
    'BAZ' => 2,
    'NEG' => -1,
  ];
  public static function FromMixed(mixed $m): TestAllRequiredTypesProto2_NestedEnum_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): TestAllRequiredTypesProto2_NestedEnum_enum_t {
    return $i;
  }
}

class TestAllRequiredTypesProto2_NestedMessage implements \Protobuf\Message {
  public int $a;
  public ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2 $corecursive;
  private ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2 $optional_corecursive;
  private bool $was_optional_corecursive_set;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'a' => int,
    ?'corecursive' => ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2,
    ?'optional_corecursive' => ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2,
  ) $s = shape()) {
    $this->a = $s['a'] ?? 0;
    $this->corecursive = $s['corecursive'] ?? null;
    if (Shapes::keyExists($s, 'optional_corecursive')) {
      $this->optional_corecursive = $s['optional_corecursive'];
      $this->was_optional_corecursive_set = true;
    } else {
      $this->optional_corecursive = null;
      $this->was_optional_corecursive_set = false;
    }
    $this->XXX_unrecognized = '';
  }

  public function getOptionalCorecursive(): ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2 {
    return $this->optional_corecursive;
  }

  public function setOptionalCorecursive(?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2 $v): void {
    $this->optional_corecursive = $v;
    $this->was_optional_corecursive_set = true;
  }

  public function hasOptionalCorecursive(): bool {
    return $this->was_optional_corecursive_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllRequiredTypesProto2.NestedMessage";
  }

  public static function ParseFrom(string $input): ?TestAllRequiredTypesProto2_NestedMessage {
    $msg = new TestAllRequiredTypesProto2_NestedMessage();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->a = $d->readVarint32Signed();
          break;
        case 2:
          if ($this->corecursive is null) {
            $this->corecursive = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
          }
          $this->corecursive->MergeFrom($d->readDecoder());
          break;
        case 3:
          if ($this->optional_corecursive is null) {
            $this->optional_corecursive = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
            $this->was_optional_corecursive_set = true;
          }
          $this->optional_corecursive->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->a !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->a);
    }
    $msg = $this->corecursive;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $msg = $this->optional_corecursive;
    if ($msg != null) {
      if ($this->was_optional_corecursive_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 3);
      }
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('a', 'a', $this->a, false);
    $e->writeMessage('corecursive', 'corecursive', $this->corecursive, false);
    if ($this->hasOptionalCorecursive()) {
      $e->writeMessage('optional_corecursive', 'optionalCorecursive', $this->optional_corecursive, false);
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'a':
          $this->a = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'corecursive':
          if ($v is null) break;
          if ($this->corecursive is null) {
            $this->corecursive = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
          }
          $this->corecursive->MergeJsonFrom($v);
          break;
        case 'optional_corecursive': case 'optionalCorecursive':
          if ($v is null) break;
          if ($this->optional_corecursive is null) {
            $this->optional_corecursive = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
            $this->was_optional_corecursive_set = true;
          }
          $this->optional_corecursive->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllRequiredTypesProto2_NestedMessage)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->a = $o->a;
    $tmp = $o->corecursive;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
      $nv->CopyFrom($tmp);
      $this->corecursive = $nv;
    }
    $tmp = $o->optional_corecursive;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
      $nv->CopyFrom($tmp);
      $this->setOptionalCorecursive($nv);
    } else if ($o->hasOptionalCorecursive()) {
      $this->setOptionalCorecursive(null);
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllRequiredTypesProto2_Data implements \Protobuf\Message {
  public int $group_int32;
  public int $group_uint32;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'group_int32' => int,
    ?'group_uint32' => int,
  ) $s = shape()) {
    $this->group_int32 = $s['group_int32'] ?? 0;
    $this->group_uint32 = $s['group_uint32'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllRequiredTypesProto2.Data";
  }

  public static function ParseFrom(string $input): ?TestAllRequiredTypesProto2_Data {
    $msg = new TestAllRequiredTypesProto2_Data();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 202:
          $this->group_int32 = $d->readVarint32Signed();
          break;
        case 203:
          $this->group_uint32 = $d->readVarint32();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->group_int32 !== 0) {
      $e->writeTag(202, 0);
      $e->writeVarint($this->group_int32);
    }
    if ($this->group_uint32 !== 0) {
      $e->writeTag(203, 0);
      $e->writeVarint($this->group_uint32);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('group_int32', 'groupInt32', $this->group_int32, false);
    $e->writeInt32('group_uint32', 'groupUint32', $this->group_uint32, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'group_int32': case 'groupInt32':
          $this->group_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'group_uint32': case 'groupUint32':
          $this->group_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllRequiredTypesProto2_Data)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->group_int32 = $o->group_int32;
    $this->group_uint32 = $o->group_uint32;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllRequiredTypesProto2_MessageSetCorrect implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllRequiredTypesProto2.MessageSetCorrect";
  }

  public static function ParseFrom(string $input): ?TestAllRequiredTypesProto2_MessageSetCorrect {
    $msg = new TestAllRequiredTypesProto2_MessageSetCorrect();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllRequiredTypesProto2_MessageSetCorrect)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllRequiredTypesProto2_MessageSetCorrectExtension1 implements \Protobuf\Message {
  public string $str;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'str' => string,
  ) $s = shape()) {
    $this->str = $s['str'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllRequiredTypesProto2.MessageSetCorrectExtension1";
  }

  public static function ParseFrom(string $input): ?TestAllRequiredTypesProto2_MessageSetCorrectExtension1 {
    $msg = new TestAllRequiredTypesProto2_MessageSetCorrectExtension1();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 25:
          $this->str = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->str !== '') {
      $e->writeTag(25, 2);
      $e->writeString($this->str);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('str', 'str', $this->str, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'str':
          $this->str = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllRequiredTypesProto2_MessageSetCorrectExtension1)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->str = $o->str;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllRequiredTypesProto2_MessageSetCorrectExtension2 implements \Protobuf\Message {
  public int $i;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'i' => int,
  ) $s = shape()) {
    $this->i = $s['i'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllRequiredTypesProto2.MessageSetCorrectExtension2";
  }

  public static function ParseFrom(string $input): ?TestAllRequiredTypesProto2_MessageSetCorrectExtension2 {
    $msg = new TestAllRequiredTypesProto2_MessageSetCorrectExtension2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 9:
          $this->i = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->i !== 0) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->i);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('i', 'i', $this->i, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'i':
          $this->i = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllRequiredTypesProto2_MessageSetCorrectExtension2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->i = $o->i;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllRequiredTypesProto2 implements \Protobuf\Message {
  public int $required_int32;
  public int $required_int64;
  public int $required_uint32;
  public int $required_uint64;
  public int $required_sint32;
  public int $required_sint64;
  public int $required_fixed32;
  public int $required_fixed64;
  public int $required_sfixed32;
  public int $required_sfixed64;
  public float $required_float;
  public float $required_double;
  public bool $required_bool;
  public string $required_string;
  public string $required_bytes;
  public ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedMessage $required_nested_message;
  public ?\protobuf_test_messages\proto2\ForeignMessageProto2 $required_foreign_message;
  public \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedEnum_enum_t $required_nested_enum;
  public \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t $required_foreign_enum;
  public string $required_string_piece;
  public string $required_cord;
  public ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2 $recursive_message;
  private ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2 $optional_recursive_message;
  private bool $was_optional_recursive_message_set;
  public ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2_Data $data;
  public int $default_int32;
  public int $default_int64;
  public int $default_uint32;
  public int $default_uint64;
  public int $default_sint32;
  public int $default_sint64;
  public int $default_fixed32;
  public int $default_fixed64;
  public int $default_sfixed32;
  public int $default_sfixed64;
  public float $default_float;
  public float $default_double;
  public bool $default_bool;
  public string $default_string;
  public string $default_bytes;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'required_int32' => int,
    ?'required_int64' => int,
    ?'required_uint32' => int,
    ?'required_uint64' => int,
    ?'required_sint32' => int,
    ?'required_sint64' => int,
    ?'required_fixed32' => int,
    ?'required_fixed64' => int,
    ?'required_sfixed32' => int,
    ?'required_sfixed64' => int,
    ?'required_float' => float,
    ?'required_double' => float,
    ?'required_bool' => bool,
    ?'required_string' => string,
    ?'required_bytes' => string,
    ?'required_nested_message' => ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedMessage,
    ?'required_foreign_message' => ?\protobuf_test_messages\proto2\ForeignMessageProto2,
    ?'required_nested_enum' => \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedEnum_enum_t,
    ?'required_foreign_enum' => \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t,
    ?'required_string_piece' => string,
    ?'required_cord' => string,
    ?'recursive_message' => ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2,
    ?'optional_recursive_message' => ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2,
    ?'data' => ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2_Data,
    ?'default_int32' => int,
    ?'default_int64' => int,
    ?'default_uint32' => int,
    ?'default_uint64' => int,
    ?'default_sint32' => int,
    ?'default_sint64' => int,
    ?'default_fixed32' => int,
    ?'default_fixed64' => int,
    ?'default_sfixed32' => int,
    ?'default_sfixed64' => int,
    ?'default_float' => float,
    ?'default_double' => float,
    ?'default_bool' => bool,
    ?'default_string' => string,
    ?'default_bytes' => string,
  ) $s = shape()) {
    $this->required_int32 = $s['required_int32'] ?? 0;
    $this->required_int64 = $s['required_int64'] ?? 0;
    $this->required_uint32 = $s['required_uint32'] ?? 0;
    $this->required_uint64 = $s['required_uint64'] ?? 0;
    $this->required_sint32 = $s['required_sint32'] ?? 0;
    $this->required_sint64 = $s['required_sint64'] ?? 0;
    $this->required_fixed32 = $s['required_fixed32'] ?? 0;
    $this->required_fixed64 = $s['required_fixed64'] ?? 0;
    $this->required_sfixed32 = $s['required_sfixed32'] ?? 0;
    $this->required_sfixed64 = $s['required_sfixed64'] ?? 0;
    $this->required_float = $s['required_float'] ?? 0.0;
    $this->required_double = $s['required_double'] ?? 0.0;
    $this->required_bool = $s['required_bool'] ?? false;
    $this->required_string = $s['required_string'] ?? '';
    $this->required_bytes = $s['required_bytes'] ?? '';
    $this->required_nested_message = $s['required_nested_message'] ?? null;
    $this->required_foreign_message = $s['required_foreign_message'] ?? null;
    $this->required_nested_enum = $s['required_nested_enum'] ?? \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedEnum::FOO;
    $this->required_foreign_enum = $s['required_foreign_enum'] ?? \protobuf_test_messages\proto2\ForeignEnumProto2::FOREIGN_FOO;
    $this->required_string_piece = $s['required_string_piece'] ?? '';
    $this->required_cord = $s['required_cord'] ?? '';
    $this->recursive_message = $s['recursive_message'] ?? null;
    if (Shapes::keyExists($s, 'optional_recursive_message')) {
      $this->optional_recursive_message = $s['optional_recursive_message'];
      $this->was_optional_recursive_message_set = true;
    } else {
      $this->optional_recursive_message = null;
      $this->was_optional_recursive_message_set = false;
    }
    $this->data = $s['data'] ?? null;
    $this->default_int32 = $s['default_int32'] ?? -123456789;
    $this->default_int64 = $s['default_int64'] ?? -9123456789123456789;
    $this->default_uint32 = $s['default_uint32'] ?? 2123456789;
    $this->default_uint64 = $s['default_uint64'] ?? -8323287284586094827;
    $this->default_sint32 = $s['default_sint32'] ?? -123456789;
    $this->default_sint64 = $s['default_sint64'] ?? -9123456789123456789;
    $this->default_fixed32 = $s['default_fixed32'] ?? 2123456789;
    $this->default_fixed64 = $s['default_fixed64'] ?? -8323287284586094827;
    $this->default_sfixed32 = $s['default_sfixed32'] ?? -123456789;
    $this->default_sfixed64 = $s['default_sfixed64'] ?? -9123456789123456789;
    $this->default_float = $s['default_float'] ?? (float)9e+09;
    $this->default_double = $s['default_double'] ?? (float)7e+22;
    $this->default_bool = $s['default_bool'] ?? true;
    $this->default_string = $s['default_string'] ?? 'Rosebud';
    $this->default_bytes = $s['default_bytes'] ?? \stripcslashes('joshua');
    $this->XXX_unrecognized = '';
  }

  public function getOptionalRecursiveMessage(): ?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2 {
    return $this->optional_recursive_message;
  }

  public function setOptionalRecursiveMessage(?\protobuf_test_messages\proto2\TestAllRequiredTypesProto2 $v): void {
    $this->optional_recursive_message = $v;
    $this->was_optional_recursive_message_set = true;
  }

  public function hasOptionalRecursiveMessage(): bool {
    return $this->was_optional_recursive_message_set;
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllRequiredTypesProto2";
  }

  public static function ParseFrom(string $input): ?TestAllRequiredTypesProto2 {
    $msg = new TestAllRequiredTypesProto2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->required_int32 = $d->readVarint32Signed();
          break;
        case 2:
          $this->required_int64 = $d->readVarint();
          break;
        case 3:
          $this->required_uint32 = $d->readVarint32();
          break;
        case 4:
          $this->required_uint64 = $d->readVarint();
          break;
        case 5:
          $this->required_sint32 = $d->readVarintZigZag32();
          break;
        case 6:
          $this->required_sint64 = $d->readVarintZigZag64();
          break;
        case 7:
          $this->required_fixed32 = $d->readLittleEndianInt32Unsigned();
          break;
        case 8:
          $this->required_fixed64 = $d->readLittleEndianInt64();
          break;
        case 9:
          $this->required_sfixed32 = $d->readLittleEndianInt32Signed();
          break;
        case 10:
          $this->required_sfixed64 = $d->readLittleEndianInt64();
          break;
        case 11:
          $this->required_float = $d->readFloat();
          break;
        case 12:
          $this->required_double = $d->readDouble();
          break;
        case 13:
          $this->required_bool = $d->readBool();
          break;
        case 14:
          $this->required_string = $d->readString();
          break;
        case 15:
          $this->required_bytes = $d->readString();
          break;
        case 18:
          if ($this->required_nested_message is null) {
            $this->required_nested_message = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedMessage();
          }
          $this->required_nested_message->MergeFrom($d->readDecoder());
          break;
        case 19:
          if ($this->required_foreign_message is null) {
            $this->required_foreign_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          }
          $this->required_foreign_message->MergeFrom($d->readDecoder());
          break;
        case 21:
          $this->required_nested_enum = \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedEnum::FromInt($d->readVarint());
          break;
        case 22:
          $this->required_foreign_enum = \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($d->readVarint());
          break;
        case 24:
          $this->required_string_piece = $d->readString();
          break;
        case 25:
          $this->required_cord = $d->readString();
          break;
        case 27:
          if ($this->recursive_message is null) {
            $this->recursive_message = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
          }
          $this->recursive_message->MergeFrom($d->readDecoder());
          break;
        case 28:
          if ($this->optional_recursive_message is null) {
            $this->optional_recursive_message = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
            $this->was_optional_recursive_message_set = true;
          }
          $this->optional_recursive_message->MergeFrom($d->readDecoder());
          break;
        case 201:
          if ($this->data is null) {
            $this->data = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_Data();
          }
          $this->data->MergeFrom($d->readDecoder());
          break;
        case 241:
          $this->default_int32 = $d->readVarint32Signed();
          break;
        case 242:
          $this->default_int64 = $d->readVarint();
          break;
        case 243:
          $this->default_uint32 = $d->readVarint32();
          break;
        case 244:
          $this->default_uint64 = $d->readVarint();
          break;
        case 245:
          $this->default_sint32 = $d->readVarintZigZag32();
          break;
        case 246:
          $this->default_sint64 = $d->readVarintZigZag64();
          break;
        case 247:
          $this->default_fixed32 = $d->readLittleEndianInt32Unsigned();
          break;
        case 248:
          $this->default_fixed64 = $d->readLittleEndianInt64();
          break;
        case 249:
          $this->default_sfixed32 = $d->readLittleEndianInt32Signed();
          break;
        case 250:
          $this->default_sfixed64 = $d->readLittleEndianInt64();
          break;
        case 251:
          $this->default_float = $d->readFloat();
          break;
        case 252:
          $this->default_double = $d->readDouble();
          break;
        case 253:
          $this->default_bool = $d->readBool();
          break;
        case 254:
          $this->default_string = $d->readString();
          break;
        case 255:
          $this->default_bytes = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->required_int32 !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->required_int32);
    }
    if ($this->required_int64 !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->required_int64);
    }
    if ($this->required_uint32 !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->required_uint32);
    }
    if ($this->required_uint64 !== 0) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->required_uint64);
    }
    if ($this->required_sint32 !== 0) {
      $e->writeTag(5, 0);
      $e->writeVarintZigZag32($this->required_sint32);
    }
    if ($this->required_sint64 !== 0) {
      $e->writeTag(6, 0);
      $e->writeVarintZigZag64($this->required_sint64);
    }
    if ($this->required_fixed32 !== 0) {
      $e->writeTag(7, 5);
      $e->writeLittleEndianInt32Unsigned($this->required_fixed32);
    }
    if ($this->required_fixed64 !== 0) {
      $e->writeTag(8, 1);
      $e->writeLittleEndianInt64($this->required_fixed64);
    }
    if ($this->required_sfixed32 !== 0) {
      $e->writeTag(9, 5);
      $e->writeLittleEndianInt32Signed($this->required_sfixed32);
    }
    if ($this->required_sfixed64 !== 0) {
      $e->writeTag(10, 1);
      $e->writeLittleEndianInt64($this->required_sfixed64);
    }
    if ($this->required_float !== 0.0) {
      $e->writeTag(11, 5);
      $e->writeFloat($this->required_float);
    }
    if ($this->required_double !== 0.0) {
      $e->writeTag(12, 1);
      $e->writeDouble($this->required_double);
    }
    if ($this->required_bool !== false) {
      $e->writeTag(13, 0);
      $e->writeBool($this->required_bool);
    }
    if ($this->required_string !== '') {
      $e->writeTag(14, 2);
      $e->writeString($this->required_string);
    }
    if ($this->required_bytes !== '') {
      $e->writeTag(15, 2);
      $e->writeString($this->required_bytes);
    }
    $msg = $this->required_nested_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 18);
    }
    $msg = $this->required_foreign_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 19);
    }
    if ($this->required_nested_enum !== \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedEnum::FOO) {
      $e->writeTag(21, 0);
      $e->writeVarint($this->required_nested_enum);
    }
    if ($this->required_foreign_enum !== \protobuf_test_messages\proto2\ForeignEnumProto2::FOREIGN_FOO) {
      $e->writeTag(22, 0);
      $e->writeVarint($this->required_foreign_enum);
    }
    if ($this->required_string_piece !== '') {
      $e->writeTag(24, 2);
      $e->writeString($this->required_string_piece);
    }
    if ($this->required_cord !== '') {
      $e->writeTag(25, 2);
      $e->writeString($this->required_cord);
    }
    $msg = $this->recursive_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 27);
    }
    $msg = $this->optional_recursive_message;
    if ($msg != null) {
      if ($this->was_optional_recursive_message_set) {
        $nested = new \Protobuf\Internal\Encoder();
        $msg->WriteTo($nested);
        $e->writeEncoder($nested, 28);
      }
    }
    $msg = $this->data;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 201);
    }
    if ($this->default_int32 !== -123456789) {
      $e->writeTag(241, 0);
      $e->writeVarint($this->default_int32);
    }
    if ($this->default_int64 !== -9123456789123456789) {
      $e->writeTag(242, 0);
      $e->writeVarint($this->default_int64);
    }
    if ($this->default_uint32 !== 2123456789) {
      $e->writeTag(243, 0);
      $e->writeVarint($this->default_uint32);
    }
    if ($this->default_uint64 !== -8323287284586094827) {
      $e->writeTag(244, 0);
      $e->writeVarint($this->default_uint64);
    }
    if ($this->default_sint32 !== -123456789) {
      $e->writeTag(245, 0);
      $e->writeVarintZigZag32($this->default_sint32);
    }
    if ($this->default_sint64 !== -9123456789123456789) {
      $e->writeTag(246, 0);
      $e->writeVarintZigZag64($this->default_sint64);
    }
    if ($this->default_fixed32 !== 2123456789) {
      $e->writeTag(247, 5);
      $e->writeLittleEndianInt32Unsigned($this->default_fixed32);
    }
    if ($this->default_fixed64 !== -8323287284586094827) {
      $e->writeTag(248, 1);
      $e->writeLittleEndianInt64($this->default_fixed64);
    }
    if ($this->default_sfixed32 !== -123456789) {
      $e->writeTag(249, 5);
      $e->writeLittleEndianInt32Signed($this->default_sfixed32);
    }
    if ($this->default_sfixed64 !== -9123456789123456789) {
      $e->writeTag(250, 1);
      $e->writeLittleEndianInt64($this->default_sfixed64);
    }
    if ($this->default_float !== (float)9e+09) {
      $e->writeTag(251, 5);
      $e->writeFloat($this->default_float);
    }
    if ($this->default_double !== (float)7e+22) {
      $e->writeTag(252, 1);
      $e->writeDouble($this->default_double);
    }
    if ($this->default_bool !== true) {
      $e->writeTag(253, 0);
      $e->writeBool($this->default_bool);
    }
    if ($this->default_string !== 'Rosebud') {
      $e->writeTag(254, 2);
      $e->writeString($this->default_string);
    }
    if ($this->default_bytes !== \stripcslashes('joshua')) {
      $e->writeTag(255, 2);
      $e->writeString($this->default_bytes);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('required_int32', 'requiredInt32', $this->required_int32, false);
    $e->writeInt64Signed('required_int64', 'requiredInt64', $this->required_int64, false);
    $e->writeInt32('required_uint32', 'requiredUint32', $this->required_uint32, false);
    $e->writeInt64Unsigned('required_uint64', 'requiredUint64', $this->required_uint64, false);
    $e->writeInt32('required_sint32', 'requiredSint32', $this->required_sint32, false);
    $e->writeInt64Signed('required_sint64', 'requiredSint64', $this->required_sint64, false);
    $e->writeInt32('required_fixed32', 'requiredFixed32', $this->required_fixed32, false);
    $e->writeInt64Unsigned('required_fixed64', 'requiredFixed64', $this->required_fixed64, false);
    $e->writeInt32('required_sfixed32', 'requiredSfixed32', $this->required_sfixed32, false);
    $e->writeInt64Signed('required_sfixed64', 'requiredSfixed64', $this->required_sfixed64, false);
    $e->writeFloat('required_float', 'requiredFloat', $this->required_float, false);
    $e->writeFloat('required_double', 'requiredDouble', $this->required_double, false);
    $e->writeBool('required_bool', 'requiredBool', $this->required_bool, false);
    $e->writeString('required_string', 'requiredString', $this->required_string, false);
    $e->writeBytes('required_bytes', 'requiredBytes', $this->required_bytes, false);
    $e->writeMessage('required_nested_message', 'requiredNestedMessage', $this->required_nested_message, false);
    $e->writeMessage('required_foreign_message', 'requiredForeignMessage', $this->required_foreign_message, false);
    $e->writeEnum('required_nested_enum', 'requiredNestedEnum', \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedEnum::ToStringDict(), $this->required_nested_enum, false);
    $e->writeEnum('required_foreign_enum', 'requiredForeignEnum', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->required_foreign_enum, false);
    $e->writeString('required_string_piece', 'requiredStringPiece', $this->required_string_piece, false);
    $e->writeString('required_cord', 'requiredCord', $this->required_cord, false);
    $e->writeMessage('recursive_message', 'recursiveMessage', $this->recursive_message, false);
    if ($this->hasOptionalRecursiveMessage()) {
      $e->writeMessage('optional_recursive_message', 'optionalRecursiveMessage', $this->optional_recursive_message, false);
    }
    $e->writeMessage('data', 'data', $this->data, false);
    $e->writeInt32('default_int32', 'defaultInt32', $this->default_int32, false);
    $e->writeInt64Signed('default_int64', 'defaultInt64', $this->default_int64, false);
    $e->writeInt32('default_uint32', 'defaultUint32', $this->default_uint32, false);
    $e->writeInt64Unsigned('default_uint64', 'defaultUint64', $this->default_uint64, false);
    $e->writeInt32('default_sint32', 'defaultSint32', $this->default_sint32, false);
    $e->writeInt64Signed('default_sint64', 'defaultSint64', $this->default_sint64, false);
    $e->writeInt32('default_fixed32', 'defaultFixed32', $this->default_fixed32, false);
    $e->writeInt64Unsigned('default_fixed64', 'defaultFixed64', $this->default_fixed64, false);
    $e->writeInt32('default_sfixed32', 'defaultSfixed32', $this->default_sfixed32, false);
    $e->writeInt64Signed('default_sfixed64', 'defaultSfixed64', $this->default_sfixed64, false);
    $e->writeFloat('default_float', 'defaultFloat', $this->default_float, false);
    $e->writeFloat('default_double', 'defaultDouble', $this->default_double, false);
    $e->writeBool('default_bool', 'defaultBool', $this->default_bool, false);
    $e->writeString('default_string', 'defaultString', $this->default_string, false);
    $e->writeBytes('default_bytes', 'defaultBytes', $this->default_bytes, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'required_int32': case 'requiredInt32':
          $this->required_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'required_int64': case 'requiredInt64':
          $this->required_int64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'required_uint32': case 'requiredUint32':
          $this->required_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        case 'required_uint64': case 'requiredUint64':
          $this->required_uint64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'required_sint32': case 'requiredSint32':
          $this->required_sint32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'required_sint64': case 'requiredSint64':
          $this->required_sint64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'required_fixed32': case 'requiredFixed32':
          $this->required_fixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'required_fixed64': case 'requiredFixed64':
          $this->required_fixed64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'required_sfixed32': case 'requiredSfixed32':
          $this->required_sfixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'required_sfixed64': case 'requiredSfixed64':
          $this->required_sfixed64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'required_float': case 'requiredFloat':
          $this->required_float = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'required_double': case 'requiredDouble':
          $this->required_double = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'required_bool': case 'requiredBool':
          $this->required_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'required_string': case 'requiredString':
          $this->required_string = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'required_bytes': case 'requiredBytes':
          $this->required_bytes = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        case 'required_nested_message': case 'requiredNestedMessage':
          if ($v is null) break;
          if ($this->required_nested_message is null) {
            $this->required_nested_message = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedMessage();
          }
          $this->required_nested_message->MergeJsonFrom($v);
          break;
        case 'required_foreign_message': case 'requiredForeignMessage':
          if ($v is null) break;
          if ($this->required_foreign_message is null) {
            $this->required_foreign_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          }
          $this->required_foreign_message->MergeJsonFrom($v);
          break;
        case 'required_nested_enum': case 'requiredNestedEnum':
          $this->required_nested_enum = \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedEnum::FromMixed($v);
          break;
        case 'required_foreign_enum': case 'requiredForeignEnum':
          $this->required_foreign_enum = \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($v);
          break;
        case 'required_string_piece': case 'requiredStringPiece':
          $this->required_string_piece = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'required_cord': case 'requiredCord':
          $this->required_cord = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'recursive_message': case 'recursiveMessage':
          if ($v is null) break;
          if ($this->recursive_message is null) {
            $this->recursive_message = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
          }
          $this->recursive_message->MergeJsonFrom($v);
          break;
        case 'optional_recursive_message': case 'optionalRecursiveMessage':
          if ($v is null) break;
          if ($this->optional_recursive_message is null) {
            $this->optional_recursive_message = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
            $this->was_optional_recursive_message_set = true;
          }
          $this->optional_recursive_message->MergeJsonFrom($v);
          break;
        case 'data':
          if ($v is null) break;
          if ($this->data is null) {
            $this->data = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_Data();
          }
          $this->data->MergeJsonFrom($v);
          break;
        case 'default_int32': case 'defaultInt32':
          $this->default_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'default_int64': case 'defaultInt64':
          $this->default_int64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'default_uint32': case 'defaultUint32':
          $this->default_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        case 'default_uint64': case 'defaultUint64':
          $this->default_uint64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'default_sint32': case 'defaultSint32':
          $this->default_sint32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'default_sint64': case 'defaultSint64':
          $this->default_sint64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'default_fixed32': case 'defaultFixed32':
          $this->default_fixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'default_fixed64': case 'defaultFixed64':
          $this->default_fixed64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'default_sfixed32': case 'defaultSfixed32':
          $this->default_sfixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'default_sfixed64': case 'defaultSfixed64':
          $this->default_sfixed64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'default_float': case 'defaultFloat':
          $this->default_float = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'default_double': case 'defaultDouble':
          $this->default_double = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'default_bool': case 'defaultBool':
          $this->default_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'default_string': case 'defaultString':
          $this->default_string = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'default_bytes': case 'defaultBytes':
          $this->default_bytes = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllRequiredTypesProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->required_int32 = $o->required_int32;
    $this->required_int64 = $o->required_int64;
    $this->required_uint32 = $o->required_uint32;
    $this->required_uint64 = $o->required_uint64;
    $this->required_sint32 = $o->required_sint32;
    $this->required_sint64 = $o->required_sint64;
    $this->required_fixed32 = $o->required_fixed32;
    $this->required_fixed64 = $o->required_fixed64;
    $this->required_sfixed32 = $o->required_sfixed32;
    $this->required_sfixed64 = $o->required_sfixed64;
    $this->required_float = $o->required_float;
    $this->required_double = $o->required_double;
    $this->required_bool = $o->required_bool;
    $this->required_string = $o->required_string;
    $this->required_bytes = $o->required_bytes;
    $tmp = $o->required_nested_message;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->required_nested_message = $nv;
    }
    $tmp = $o->required_foreign_message;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($tmp);
      $this->required_foreign_message = $nv;
    }
    $this->required_nested_enum = $o->required_nested_enum;
    $this->required_foreign_enum = $o->required_foreign_enum;
    $this->required_string_piece = $o->required_string_piece;
    $this->required_cord = $o->required_cord;
    $tmp = $o->recursive_message;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
      $nv->CopyFrom($tmp);
      $this->recursive_message = $nv;
    }
    $tmp = $o->optional_recursive_message;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2();
      $nv->CopyFrom($tmp);
      $this->setOptionalRecursiveMessage($nv);
    } else if ($o->hasOptionalRecursiveMessage()) {
      $this->setOptionalRecursiveMessage(null);
    }
    $tmp = $o->data;
    if ($tmp is nonnull) {
      $nv = new \protobuf_test_messages\proto2\TestAllRequiredTypesProto2_Data();
      $nv->CopyFrom($tmp);
      $this->data = $nv;
    }
    $this->default_int32 = $o->default_int32;
    $this->default_int64 = $o->default_int64;
    $this->default_uint32 = $o->default_uint32;
    $this->default_uint64 = $o->default_uint64;
    $this->default_sint32 = $o->default_sint32;
    $this->default_sint64 = $o->default_sint64;
    $this->default_fixed32 = $o->default_fixed32;
    $this->default_fixed64 = $o->default_fixed64;
    $this->default_sfixed32 = $o->default_sfixed32;
    $this->default_sfixed64 = $o->default_sfixed64;
    $this->default_float = $o->default_float;
    $this->default_double = $o->default_double;
    $this->default_bool = $o->default_bool;
    $this->default_string = $o->default_string;
    $this->default_bytes = $o->default_bytes;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

enum TestLargeOneof_large_oneof_oneof_t: int {
  NOT_SET = 0;
  a1 = 1;
  a2 = 2;
  a3 = 3;
  a4 = 4;
  a5 = 5;
}

interface TestLargeOneof_large_oneof {
  public function WhichOneof(): TestLargeOneof_large_oneof_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): TestLargeOneof_large_oneof;
}

class TestLargeOneof_large_oneof_NOT_SET implements TestLargeOneof_large_oneof {
  public function WhichOneof(): TestLargeOneof_large_oneof_oneof_t {
    return TestLargeOneof_large_oneof_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): TestLargeOneof_large_oneof { return $this; }
}

class TestLargeOneof_large_oneof_a1 implements TestLargeOneof_large_oneof {
  public function __construct(public \protobuf_test_messages\proto2\TestLargeOneof_A1 $a1) {}

  public function WhichOneof(): TestLargeOneof_large_oneof_oneof_t {
    return TestLargeOneof_large_oneof_oneof_t::a1;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->a1->WriteTo($nested);
    $e->writeEncoder($nested, 1);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('a1', 'a1', $this->a1, true);
  }

  public function Copy(): TestLargeOneof_large_oneof {
    $nv = new \protobuf_test_messages\proto2\TestLargeOneof_A1();
    $nv->CopyFrom($this->a1);
    return new TestLargeOneof_large_oneof_a1($nv);
  }
}

class TestLargeOneof_large_oneof_a2 implements TestLargeOneof_large_oneof {
  public function __construct(public \protobuf_test_messages\proto2\TestLargeOneof_A2 $a2) {}

  public function WhichOneof(): TestLargeOneof_large_oneof_oneof_t {
    return TestLargeOneof_large_oneof_oneof_t::a2;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->a2->WriteTo($nested);
    $e->writeEncoder($nested, 2);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('a2', 'a2', $this->a2, true);
  }

  public function Copy(): TestLargeOneof_large_oneof {
    $nv = new \protobuf_test_messages\proto2\TestLargeOneof_A2();
    $nv->CopyFrom($this->a2);
    return new TestLargeOneof_large_oneof_a2($nv);
  }
}

class TestLargeOneof_large_oneof_a3 implements TestLargeOneof_large_oneof {
  public function __construct(public \protobuf_test_messages\proto2\TestLargeOneof_A3 $a3) {}

  public function WhichOneof(): TestLargeOneof_large_oneof_oneof_t {
    return TestLargeOneof_large_oneof_oneof_t::a3;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->a3->WriteTo($nested);
    $e->writeEncoder($nested, 3);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('a3', 'a3', $this->a3, true);
  }

  public function Copy(): TestLargeOneof_large_oneof {
    $nv = new \protobuf_test_messages\proto2\TestLargeOneof_A3();
    $nv->CopyFrom($this->a3);
    return new TestLargeOneof_large_oneof_a3($nv);
  }
}

class TestLargeOneof_large_oneof_a4 implements TestLargeOneof_large_oneof {
  public function __construct(public \protobuf_test_messages\proto2\TestLargeOneof_A4 $a4) {}

  public function WhichOneof(): TestLargeOneof_large_oneof_oneof_t {
    return TestLargeOneof_large_oneof_oneof_t::a4;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->a4->WriteTo($nested);
    $e->writeEncoder($nested, 4);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('a4', 'a4', $this->a4, true);
  }

  public function Copy(): TestLargeOneof_large_oneof {
    $nv = new \protobuf_test_messages\proto2\TestLargeOneof_A4();
    $nv->CopyFrom($this->a4);
    return new TestLargeOneof_large_oneof_a4($nv);
  }
}

class TestLargeOneof_large_oneof_a5 implements TestLargeOneof_large_oneof {
  public function __construct(public \protobuf_test_messages\proto2\TestLargeOneof_A5 $a5) {}

  public function WhichOneof(): TestLargeOneof_large_oneof_oneof_t {
    return TestLargeOneof_large_oneof_oneof_t::a5;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->a5->WriteTo($nested);
    $e->writeEncoder($nested, 5);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('a5', 'a5', $this->a5, true);
  }

  public function Copy(): TestLargeOneof_large_oneof {
    $nv = new \protobuf_test_messages\proto2\TestLargeOneof_A5();
    $nv->CopyFrom($this->a5);
    return new TestLargeOneof_large_oneof_a5($nv);
  }
}

class TestLargeOneof_A1 implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestLargeOneof.A1";
  }

  public static function ParseFrom(string $input): ?TestLargeOneof_A1 {
    $msg = new TestLargeOneof_A1();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestLargeOneof_A1)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestLargeOneof_A2 implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestLargeOneof.A2";
  }

  public static function ParseFrom(string $input): ?TestLargeOneof_A2 {
    $msg = new TestLargeOneof_A2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestLargeOneof_A2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestLargeOneof_A3 implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestLargeOneof.A3";
  }

  public static function ParseFrom(string $input): ?TestLargeOneof_A3 {
    $msg = new TestLargeOneof_A3();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestLargeOneof_A3)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestLargeOneof_A4 implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestLargeOneof.A4";
  }

  public static function ParseFrom(string $input): ?TestLargeOneof_A4 {
    $msg = new TestLargeOneof_A4();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestLargeOneof_A4)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestLargeOneof_A5 implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestLargeOneof.A5";
  }

  public static function ParseFrom(string $input): ?TestLargeOneof_A5 {
    $msg = new TestLargeOneof_A5();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestLargeOneof_A5)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestLargeOneof implements \Protobuf\Message {
  public TestLargeOneof_large_oneof $large_oneof;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'large_oneof' => TestLargeOneof_large_oneof,
  ) $s = shape()) {
    $this->large_oneof = $s['large_oneof'] ?? new TestLargeOneof_large_oneof_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestLargeOneof";
  }

  public static function ParseFrom(string $input): ?TestLargeOneof {
    $msg = new TestLargeOneof();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($this->large_oneof->WhichOneof() == TestLargeOneof_large_oneof_oneof_t::a1) {
            ($this->large_oneof as TestLargeOneof_large_oneof_a1)->a1->MergeFrom($d->readDecoder());
          } else {
            $obj = new \protobuf_test_messages\proto2\TestLargeOneof_A1();
            $obj->MergeFrom($d->readDecoder());
            $this->large_oneof = new TestLargeOneof_large_oneof_a1($obj);
          }
          break;
        case 2:
          if ($this->large_oneof->WhichOneof() == TestLargeOneof_large_oneof_oneof_t::a2) {
            ($this->large_oneof as TestLargeOneof_large_oneof_a2)->a2->MergeFrom($d->readDecoder());
          } else {
            $obj = new \protobuf_test_messages\proto2\TestLargeOneof_A2();
            $obj->MergeFrom($d->readDecoder());
            $this->large_oneof = new TestLargeOneof_large_oneof_a2($obj);
          }
          break;
        case 3:
          if ($this->large_oneof->WhichOneof() == TestLargeOneof_large_oneof_oneof_t::a3) {
            ($this->large_oneof as TestLargeOneof_large_oneof_a3)->a3->MergeFrom($d->readDecoder());
          } else {
            $obj = new \protobuf_test_messages\proto2\TestLargeOneof_A3();
            $obj->MergeFrom($d->readDecoder());
            $this->large_oneof = new TestLargeOneof_large_oneof_a3($obj);
          }
          break;
        case 4:
          if ($this->large_oneof->WhichOneof() == TestLargeOneof_large_oneof_oneof_t::a4) {
            ($this->large_oneof as TestLargeOneof_large_oneof_a4)->a4->MergeFrom($d->readDecoder());
          } else {
            $obj = new \protobuf_test_messages\proto2\TestLargeOneof_A4();
            $obj->MergeFrom($d->readDecoder());
            $this->large_oneof = new TestLargeOneof_large_oneof_a4($obj);
          }
          break;
        case 5:
          if ($this->large_oneof->WhichOneof() == TestLargeOneof_large_oneof_oneof_t::a5) {
            ($this->large_oneof as TestLargeOneof_large_oneof_a5)->a5->MergeFrom($d->readDecoder());
          } else {
            $obj = new \protobuf_test_messages\proto2\TestLargeOneof_A5();
            $obj->MergeFrom($d->readDecoder());
            $this->large_oneof = new TestLargeOneof_large_oneof_a5($obj);
          }
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $this->large_oneof->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $this->large_oneof->WriteJsonTo($e);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'a1':
          $obj = new \protobuf_test_messages\proto2\TestLargeOneof_A1();
          $obj->MergeJsonFrom($v);
          $this->large_oneof = new TestLargeOneof_large_oneof_a1($obj);
          break;
        case 'a2':
          $obj = new \protobuf_test_messages\proto2\TestLargeOneof_A2();
          $obj->MergeJsonFrom($v);
          $this->large_oneof = new TestLargeOneof_large_oneof_a2($obj);
          break;
        case 'a3':
          $obj = new \protobuf_test_messages\proto2\TestLargeOneof_A3();
          $obj->MergeJsonFrom($v);
          $this->large_oneof = new TestLargeOneof_large_oneof_a3($obj);
          break;
        case 'a4':
          $obj = new \protobuf_test_messages\proto2\TestLargeOneof_A4();
          $obj->MergeJsonFrom($v);
          $this->large_oneof = new TestLargeOneof_large_oneof_a4($obj);
          break;
        case 'a5':
          $obj = new \protobuf_test_messages\proto2\TestLargeOneof_A5();
          $obj->MergeJsonFrom($v);
          $this->large_oneof = new TestLargeOneof_large_oneof_a5($obj);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestLargeOneof)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->large_oneof = $o->large_oneof->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_test_messages_proto2__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/test_messages_proto2.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 15568 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\xbc\x5b\xdb\x73\x1c\x47\xf5\xd6\xf4\x4a\x5a\xa9\xa5\x5d\xad\x5a\xb2\xdd\x56\x92\xca\x58\xb6\xe3\xb1\x1d\xdb\xd2\x6a\x3c\x96\xf6\x97\x38\xb1\x6c\xc9\xf2\x4d\xf2\x6f\x64\x13\x62\x93\x2c\x2b\xed\x48\x5e\xbc\xbb\xa3\xec\xc5\xb6\x80\x22\x55\x94\x29\x20\xbc\x24\x40\xb8\x4\x8\x90\x7f\x81\x47\xaa\x80\x47\x2\x81\x67\xf8\xb\x8\x97\x82\x82\x4\x72\xe1\x62\xaa\xaf\xd3\x3d\x33\xb2\xac\x5d\x5\x3f\xac\xb5\x67\xbe\xfe\x4e\x9f\x9e\xd3\xdf\x4c\x77\x9f\x85\x87\x56\x7d\x7f\xb5\xec\x1d\x5b\xab\xf9\xd\x7f\xa9\xb9\x72\xac\xe1\xd5\x1b\xf9\x8a\x57\xaf\x17\x56\xbd\x7a\x9e\x9a\xb3\x47\xe9\x7f\xe8\x11\x1\xca\x6b\x20\x76\x35\x3b\xfa\xbb\x67\x21\xba\xe2\xd5\x1b\xa7\xca\xe5\x2b\xeb\x6b\x5e\xfd\x32\x35\xa3\xfd\x30\xed\xaf\x35\x4a\x7e\xb5\x50\xce\x97\xaa\x8d\x89\x2c\x36\x4c\xc3\xea\x72\x53\xc2\x7a\x8e\x18\xc3\x30\xc7\xc6\xc0\x34\xac\x84\x6\x73\x6c\x74\x0\xe\x48\x58\x93\xd1\x25\x4c\xc3\x4a\xb9\xb2\xf5\x55\x6a\x8d\x0\x1d\x1b\x77\x9a\x86\xd5\xa9\x3\x43\x8c\x75\xc6\xd8\x65\x1a\xd6\x60\x0\x5c\x8c\x32\xd6\x19\x63\xb7\x69\x58\x48\x7\x3a\x36\x3a\x8\x33\x12\xb8\x52\xba\xe3\x15\x27\xb2\x38\x69\x1a\x56\xd2\x95\x4\xb3\xcc\x1c\x85\x3a\x36\xee\x31\xd\xab\x3b\x4\x75\x6c\x74\x18\xe\x6\xee\x5\x6d\xaf\x69\x58\x3\xae\xe4\x58\xe4\xf6\x18\xb0\x63\x63\x68\x1a\x56\x26\xc\x76\x6c\x6d\xe8\x57\xca\x7e\xa1\x81\xfb\x4c\xc3\x2\xc1\xd0\xcf\x12\xa3\x16\x7f\xd1\x6f\x2e\x95\x3d\xdc\x6f\x1a\x96\x11\xc4\x7f\x86\x5a\xd1\x5e\x28\x5b\xe6\x97\x7c\xbf\x8c\x53\xa6\x61\xf5\xb8\xfd\xc2\x38\xed\xfb\x65\x7d\x34\x1b\xb5\x52\x75\x15\xa7\x4d\xc3\xea\x55\x46\x93\x5a\xb5\xde\x2d\xad\x37\xbc\x3a\x1e\x30\xd\xab\x3f\xe8\xdd\x34\x31\xa2\xdb\x70\x97\x84\x55\xbd\x7a\xc3\x2b\x8a\x4\xc5\xc8\x34\xac\xbe\xec\x53\x47\xef\x9b\xbe\x47\xa3\xa9\x7b\x74\x9e\xf2\x5c\x62\x40\x77\x87\xe0\xd7\xcc\xa8\x2\x71\x30\x7a\x7e\xcd\x2b\xad\x56\xa5\xe7\x21\xea\x79\x62\x13\xcf\xb3\xac\x15\x27\x64\xbe\xdd\x9d\x72\xf0\xb5\xab\xa8\xa\x87\xc3\x71\x7a\xd5\x66\x5\xef\x30\xd\x2b\x9d\x7d\xa2\xd5\x20\x67\xaa\xcd\x8a\x8b\xf4\x8\x89\xd\x15\xe1\x8e\x48\x78\xd4\xe1\x4e\xea\x70\xec\xc1\x62\x23\x54\x3c\xb0\xa1\x50\x60\xd4\x8b\xa3\x78\x61\xd9\x90\x5f\x2b\x79\xcb\x1e\xc6\x24\x27\xa6\x41\xf\x8\xda\xb1\xbc\xb8\x4c\x2e\xa3\x3\x4a\xaa\x2d\xfb\xb5\x22\xde\xcd\xf1\x46\x90\x6e\xa7\xfd\x5a\x11\x3d\xf\x7\x6b\xde\x72\xb3\x56\x2f\xdd\xf2\xe4\xed\x79\x88\xde\x9e\xf1\x2d\x8f\x99\x9b\x91\x5c\xe2\xb6\xec\x87\xe9\x9a\xb7\xe6\x15\xc8\xfd\x60\x22\xf2\xa8\x99\x20\x2a\x27\xac\x52\xe5\x54\x98\x63\x63\xd3\x4c\x10\x95\x53\x60\x4c\x93\x24\x8c\xab\xdc\x1e\x33\x41\x54\x4e\x98\x3\x95\xd3\x80\x8e\x8d\x47\xcd\x4\x51\x39\x15\x18\x62\xe4\x2a\xb7\xd7\x4c\x10\x95\x13\xe6\xc5\x28\x23\x57\xb9\x7d\x66\x82\xa8\x9c\xa\x64\x2a\x27\x81\x42\x8e\xf6\x9b\x9\xa2\x72\xc2\xae\xa8\x9c\xe\x75\x6c\xfc\x98\x99\x20\x2a\xa7\x41\x99\xca\x5\xee\x5\xed\x1\x33\x41\x54\x4e\x76\x40\x51\xb9\x10\xd8\xb1\xb1\x65\x26\x88\xca\xe9\x60\xa6\x72\x41\x27\xa8\xca\x1d\x34\x13\x44\xe5\x64\x17\x84\xca\x49\x18\x57\xb9\x43\x66\x82\xa8\x9c\x30\x7\x2a\x27\x81\x54\xe5\xe\x9b\x9\xa2\x72\xc2\x28\x54\x2e\xe8\x21\x53\xb9\xc7\xcd\x4\x51\x39\xd9\x3f\xa9\x72\x1\x1b\x55\xb9\x23\x66\x82\xa8\x9c\xa4\x13\x2a\x27\x61\x21\x95\x1b\x33\x13\xdb\xa2\x72\x82\x3f\xa2\x72\xc1\xe8\x85\x54\x6e\x9c\x7a\x6e\x4d\xe5\xe4\xe0\x47\x54\x2e\x1c\x27\x15\x9d\x9\x33\xd1\xbe\xca\xe9\x11\xa\x95\x8b\x84\x47\x1d\xda\xd4\x61\xb\x2a\x17\xa\x4c\xa8\x5c\x28\x1b\xb8\xca\x39\x24\x27\x98\xca\xe9\x79\x21\x55\x4e\xb6\xa3\x2a\x77\x82\xe3\x8d\x20\xdd\xa8\xca\xed\x87\xfd\x6b\x85\xe5\x9b\x52\x83\x2e\x10\xd\x9a\x6\x19\xc3\xed\x63\x76\xa1\x42\xa\xcc\xb1\xf1\x45\xa2\x41\x21\x18\xd5\x8c\x14\x87\x71\xd\xba\x44\x34\x88\xe2\x78\x7b\xa9\x42\x2a\xd0\xb1\xf1\x3c\xd1\xa0\x30\x50\x63\xe4\x1a\xb4\x40\x34\x48\x5\x2e\x86\x19\xb9\x6\x5d\x26\x1a\x14\x6\x52\x15\x4a\x73\xa0\x10\x8b\xff\x27\x1a\x44\x91\x9c\x22\x50\x21\xd\xea\xd8\xd8\x25\x1a\x14\x81\x52\x15\x1a\x10\xee\x5\xed\x22\xd1\x20\x8a\xe5\x2c\x8a\xa\xe9\x60\xc7\xc6\x57\x88\x6\x45\xc1\x54\x85\xc4\xd0\x33\xd\xba\x4a\x34\x48\x1d\x7a\xa1\x42\x22\x7e\xae\x41\x1f\x23\x1a\xa4\xc6\x2f\x55\x88\xb7\x63\x1a\xf4\xc\xd1\x20\xa\x83\xcc\x4c\x55\xa8\xa\x11\x7\xa9\x73\xe9\xe3\xed\xcf\x25\xea\x29\xc3\xb8\x95\xd9\x74\x10\xa6\x9b\x55\x2d\x11\x9f\xe5\x89\xd8\xe1\xa6\xc4\x15\x96\x8a\x21\xa8\x63\xe3\x6b\x3c\x19\x75\x28\xbb\x29\x12\xca\x13\xf2\x3a\x4f\xc8\xe\x57\xb2\xf0\x94\xc\x83\x1d\x1b\x7f\x82\x27\x65\x8\x1c\x62\xe6\x89\xf9\x1c\x4f\x4c\x5\xbc\x18\x65\xe6\xc9\xf9\x3c\x4f\xce\x10\xd8\xb1\xd1\x11\x98\x91\x60\x91\x49\x79\x9e\xa0\x1d\xae\x24\x12\x29\x1a\x81\x3b\x36\xfe\x24\x4f\xd2\x30\xdc\xb1\xd1\x31\x38\x18\x74\x45\xd0\x17\x78\xa2\x76\xb8\x92\x4b\xa6\x6a\xb4\x81\x63\xe3\x25\x9e\xac\x91\x6\x6c\x7a\x5\x1d\xa2\x9\xbb\xcc\x13\x56\xb9\x3d\x2c\x65\xd5\x71\xe1\x49\x5b\xe4\x49\xab\x8c\xb\x4f\xdb\x3\x50\xb6\x66\x89\xeb\xf1\xc4\xed\x70\xfb\xc5\x5\x9a\xba\x35\x38\x2c\x81\x6a\xf2\xae\x6c\x4b\xf2\x76\xb8\x48\xb0\x2b\xe9\x5b\x86\x3\x95\xc2\x1a\xcb\x5c\x9e\xbf\x93\xf4\x11\x77\x66\xeb\xee\x2e\x15\xd6\x68\xa2\xd3\x8f\x99\x6a\xa3\xb6\xee\xa6\x2a\xaa\x4d\xf1\xe6\xd8\x7c\xa\x4c\xb5\xe7\xcd\xb1\xe9\x87\xe6\x8d\xdb\x50\xd\xe\x12\x6f\x6c\xfe\x88\x69\x94\xa3\xfe\x66\x5b\xf2\xc7\xe6\x1b\xfb\x64\x1e\x49\x38\xaa\x55\xf5\xe9\xd8\x62\x36\xfe\x5f\x9b\x3e\x1d\x9b\x7d\xea\x3e\x85\x55\xf8\x64\xb3\x59\x4c\xea\x27\xda\xf0\xc9\x66\xff\x62\x28\x4e\xd5\xaa\xfa\x74\x6c\xa1\xd\x4f\xb6\xe9\xd3\xb1\x17\x43\x71\xaa\x56\x74\x7\xe\x11\x9f\x7c\x82\x4b\x8d\x39\x49\xbd\xce\xb5\xe4\x95\x8b\x11\xff\x8f\xf9\x25\x81\xe9\x76\xcd\xb3\x63\x4b\xb9\x7a\xaa\x5d\xcf\x8e\xcd\xff\xb\x79\x96\x76\xf4\x39\xb8\x83\x8e\xb3\x8\x5a\x4a\xdf\xd3\xd4\xf7\xf9\xd6\xc6\x9a\x93\x88\xff\x99\x77\x12\x62\xf8\x8a\xee\x9f\xdc\x69\x11\xfb\xa9\xb6\xfd\x3b\xb6\xf8\x3f\xec\x3f\xb8\x82\x4a\x30\x1d\xe8\x13\x55\xcf\x1b\xd4\xf1\xe9\xd6\xe5\x89\x68\x2d\xf3\xd8\x5f\x51\x4c\xba\x14\xb2\x7\xc0\x74\xbb\x52\x48\x1f\x17\x21\x29\x64\x8f\x10\x1f\x66\x2\x6f\xfc\x19\x72\x9a\xba\x9b\x69\xdd\x1d\x7b\xe2\x30\x7f\xe9\x8a\x66\x44\x5f\x30\x20\xe\x3c\x86\x16\x54\xab\xd4\xf3\xc5\xd6\x3d\x6b\x2b\x28\xd6\x81\x1d\x95\xb8\x6b\x68\x5\x92\x91\xa0\xf7\x92\xdd\xd0\x33\xd4\xf7\x74\x4b\xbe\xc9\x8d\xb\xee\x67\x5f\x25\xb0\x48\x85\x62\x6b\xf\xbe\x20\x9d\x69\x47\xa1\x28\x5\xfb\x54\x14\x4a\xb1\x8a\x9b\xca\x7d\xb2\xb5\xed\x6c\x1b\x37\x95\xd1\xd2\xe5\x70\x70\x53\x15\x23\xfa\x92\x1\x77\x2b\x1e\x43\x77\xf5\x2c\x75\x7d\xa9\xd\xd7\x31\xb7\x75\x67\x25\xf6\x22\xfa\x8a\x1\x47\x94\xae\x84\x17\xce\x73\xb4\x2f\xf3\x6d\xf4\x45\x5f\x36\xb3\xce\xec\xaa\xc4\x5f\x45\x2f\xc2\x9d\xd1\x71\xa1\x6f\x53\xe7\xda\x11\x2e\x25\x6e\xf2\xfa\xa4\x8\x57\xe8\xa\xfa\xbc\x1\x77\xc5\xc\x7\xed\xc2\x79\xda\x85\xb\xed\x8f\x45\xd0\x87\xe1\x4a\xcc\x25\xb4\x17\xf6\xfb\x55\xcf\x5f\x11\x2f\x3f\xbe\x69\x58\xa9\xb9\xe\xb7\x8f\x5a\xf9\x2b\x4b\x1d\xe\x33\x50\x28\x7b\xd6\xb6\x65\x2b\x79\xae\xc3\x45\x94\x5e\xcf\x16\xd9\x33\x3e\x31\x5f\x30\xd\xab\x57\xf6\x8c\x4f\xa7\x3d\x90\x7d\xe5\x33\xa9\x66\x1a\x56\xff\x5c\x87\xb\xa9\x91\x4d\x80\x47\x21\xe4\x10\x22\x25\x75\xd3\xb0\x7a\xe6\x3a\xdc\x5e\x86\x20\x32\xa0\xd\x81\x63\xe3\x86\x69\x58\x9d\xda\x10\x38\x76\xe0\x88\xc9\x7e\xd3\x34\x2c\x20\x1d\x31\xbd\x96\x3c\x5c\xab\x6f\x99\x86\x65\x48\x1e\xae\xb1\xcf\x89\xde\xd0\xdb\x7c\xbb\xfd\x6d\x6a\x19\xb\xbd\x9d\x17\x60\x67\xb1\xd0\x28\xe0\x37\xd\xd3\xb0\x60\xd6\xd9\x3a\xf3\x99\x42\xa3\xe0\x52\x12\xfa\x4e\xd3\x2c\x37\x4a\xb7\xfd\x5a\x71\xb5\xe6\x37\xd7\x56\x4a\x5e\xb9\x88\xdf\x62\xdc\xad\xe8\x15\x61\x7b\xc6\xaf\x15\xcf\x12\xb6\x59\xc2\xe6\xc6\xb9\x40\x63\x30\x55\xf4\x56\xa\xcd\x72\x83\xaf\x38\xfe\x4a\x4f\xc9\x72\xf0\xc8\x78\x76\xc2\x3e\xee\x9c\x98\x9c\x72\xfb\x39\x82\xad\x1b\x72\x5a\xb\xc7\xc6\x7f\x23\x2d\x12\xb9\xe1\x23\x53\xb2\x49\x6c\x5b\xc7\x46\x59\x98\x16\x6d\xf9\x2c\x78\x87\x34\x4e\xe5\x60\x36\x68\x22\xe8\xf9\x94\x78\x42\x6f\xe3\xd8\xf8\x5d\xd2\xa6\x33\x37\x3c\x3e\x16\xe3\x50\x6d\xad\x7b\xe4\x2f\xe3\x7f\x27\xad\x7\xb5\x0\x45\x9b\xc5\x88\x47\xfe\x32\xfd\xf\xd2\x6\x6d\x10\xa2\xda\xda\xb1\x91\xd\x7\x44\x6b\xf1\x7e\xf8\x1e\x69\x9e\xd4\x82\x14\x1e\xc4\x5b\xed\xc9\x50\x2b\xc7\xc6\xef\x93\x56\xdd\x1b\x84\xa9\xb5\x77\x6c\xe4\xc0\x8c\xec\xb3\x70\xfb\x1\x21\x18\xd0\x22\x15\x4e\xe4\x3b\xe5\xd3\xe1\x76\x8e\x8d\x3f\x24\xed\x32\x1b\x44\xab\x33\xd0\x4d\xc\x99\xf\x6c\xc6\xfe\x93\x34\x7\xb9\xae\x29\xef\xf0\x58\x90\x0\x6c\xe6\x1e\x9\x86\x96\xcf\xdd\x7f\x11\xb4\x91\xeb\x3a\xe1\x1d\xce\x66\xe5\x58\xf2\x39\x6c\x41\xd1\x9c\x69\xca\xbf\x9\xb8\x27\xd7\xd9\xa8\x35\x3d\xb7\x8f\x5f\xa2\xd2\x72\x4c\xb9\x67\x4c\xc5\xfe\x43\xb0\xbd\xb9\xa4\xeb\xd7\xbd\xa5\x66\x31\xb8\x4d\x4c\xcf\x1e\xf\xba\xcd\x14\xed\x1e\xc1\xf7\xe7\xba\x3f\xe5\xd7\x6f\x34\xb\xb2\xdf\x52\xda\xe8\x7c\xa9\x16\x2a\xde\x38\x7e\x25\x41\x4f\x92\x15\x13\x32\x61\x1f\xfd\x96\x27\x5f\xb3\xf8\xab\x2a\x62\x9e\x98\xd0\x1e\xd8\x9f\xf\x20\x13\xf8\x6b\x1c\x32\x2b\x20\x13\x68\x14\xa6\x18\x82\x42\xec\x3c\xfe\x7a\x98\x86\xca\x23\xfd\x36\x46\x20\xc7\xf1\xab\xc\xa1\xda\xd0\x5e\x41\x33\x46\x79\x1c\xfc\xd\xd\x44\x78\x1c\x19\x11\xf9\x76\x2\x7f\x33\xec\xe8\x4\x1\xc8\xae\x4d\xe2\x6f\x85\x7b\x3b\x19\x84\x4c\xbe\x4e\xe1\x6f\x87\x29\xa6\xd0\x28\xec\x9f\x95\x88\xf1\x31\xfc\x1a\xef\x87\x24\x19\x1f\xa3\x98\x73\x33\x17\xcf\xe4\xe7\x4f\x5d\x9a\x19\x1f\xc7\xdf\x11\x18\x62\x64\xb6\x0\x43\xc7\x3a\x8b\xbf\xab\x61\xa8\xd\xed\x83\xe9\xbc\x32\xbe\xe3\x13\xf8\x7b\x11\x6f\x13\xc\x35\x1b\xa0\x6c\xfc\x7a\x4\x65\x7\x3\xc8\x40\xc7\xf1\xf7\xd5\x1\xa4\x20\x65\x94\x59\x74\xe\xfe\x41\x4\xe4\x10\x7f\x4a\x9f\x4e\xe4\xf3\xf8\x87\x11\xd4\x9\x82\x52\xfa\x34\x99\xcf\xe3\x37\x22\xbd\x9a\x44\xd\x38\xc4\x95\x3f\x5f\xf7\x1a\xf9\x65\xbf\x56\xf3\x96\x1b\xf8\xdd\x4\x7d\x37\x68\x65\x11\xc6\x20\x8b\x5e\xe3\x34\xe3\x72\x7\x2b\x61\xd3\x48\xd\xa6\xf4\xb7\x85\x7e\x68\x14\x78\x29\x85\x51\x40\x8b\xb0\x6f\xd9\x97\xa7\x92\xb4\x76\xa2\xa5\x93\x4d\x95\x65\xe4\x69\x88\xa2\xfb\x57\x28\x3\x13\x37\xbd\x75\xee\x9a\xfc\x89\x86\x61\xd7\xad\x42\xb9\xc9\xdc\x76\xb9\xec\x4b\xe\x4c\x1a\x1\x83\xba\x27\xa5\x32\x24\x62\x18\x12\x2a\xc3\x34\x1c\x8e\xdb\x65\x52\x39\x52\x31\x1c\xa9\x78\xe\x6d\xd7\x48\xe5\xe8\x8c\xe1\xe8\x8c\x72\x44\x76\x81\x54\x8e\xc1\x18\x8e\xc1\x78\xe\x6d\x57\x47\xe5\x40\x31\x1c\x48\xe5\x38\x3\x77\xc6\xef\xd1\xa8\x2c\xc9\x18\x96\xe4\x6\x2c\xfa\x7e\x8b\xca\xd2\x1d\xc3\xd2\xad\xb2\xcc\x42\xbc\xd1\xce\x89\xca\x33\x10\xc3\x33\xb0\x11\x4f\x68\x7\x44\xe5\xc9\xc4\xf0\x64\x54\x9e\xa7\xe0\x60\x64\x43\x63\xb3\x74\xed\x89\x4d\x57\x75\x97\x62\x33\x6\xa0\x32\x9c\x82\x43\x31\x1b\xf\x9b\x51\x18\x2a\xc5\x97\xd\x38\xb2\xf1\x16\x42\xc\xd5\x55\x95\x6a\x1b\x8e\x80\x95\xbe\x9c\x84\x99\xf0\x8e\x82\xda\x81\x9e\xcd\x6\x94\x67\x7c\x78\x97\x40\xe5\xe8\x8d\xe1\xe8\x8d\xe\x69\x78\xd9\xbf\x19\x45\xbf\x4a\xf1\x92\x1\x1f\xba\xcf\xfa\x3d\x86\xeb\x23\x1c\xd3\x17\xe1\xc3\xf7\x5b\xbf\xc7\x74\xe6\x9c\xde\x99\x96\x4e\xda\x95\xe\xdc\x35\xd8\x7c\x8b\x5b\xb8\xc7\x78\x77\x55\xef\xed\x1e\xbe\x2b\xdd\x58\x87\xbb\x37\x5c\xbb\xc7\x74\x63\x56\xef\xc6\xd6\x8f\xe4\x15\xd7\x17\x61\x27\x59\xf5\x91\x57\x27\xba\x6\xe3\x6b\xae\x5f\xb0\x49\x5\xa9\x8d\xad\xb2\x46\x61\x3f\x43\xf0\x75\xd2\x2f\xd9\x3\x87\x35\x63\xcf\xa3\x91\xeb\x70\x28\x66\x9d\x17\x26\xff\xd5\xe6\xe4\xbf\x8e\x21\xdf\x3\x7\x23\xef\x7\x87\x7a\x7a\x3a\x33\xf7\xee\xdd\xbb\x97\xcc\x81\x1e\x63\xe4\x43\x92\xdd\x61\xcc\xcc\x9d\x86\x57\xad\x97\xfc\xea\x38\x19\xcb\x7a\xa3\xc6\x4a\xa3\x5c\xf2\x67\xf6\xe7\x6\xdc\xa1\xbe\xc3\x78\x2\x8c\xb6\xe3\xf5\x5\x7f\xf0\xe3\xe7\x69\xa2\x5e\xda\x6\xb2\x20\xe\x77\x28\x78\x2b\x92\xd6\x91\xf7\xee\x1b\x7c\x96\xbc\x26\x95\x68\x99\x64\x97\x6b\x94\xb2\x6f\x7e\xb4\x81\xbf\xfc\x23\xba\x8c\xda\xe6\xc8\xb3\xf1\x91\xdf\x5\x10\xc9\x6f\xcf\x94\x1a\x37\x16\xaa\x9e\xbf\x82\xd2\xf2\xbd\x70\xae\x83\xbc\x19\xa6\xa1\xb1\xc4\x5e\xcc\xc8\xf7\xa5\xec\x4f\xc\x38\x2c\xc3\xce\xdf\x2e\x35\x6e\xe4\xe9\x6e\xca\xf6\x8c\xc0\xab\xaf\xfd\x25\x47\x47\xa0\x85\x3\x82\x68\x30\x2e\xf2\x22\xb6\xe9\x94\xdc\x98\x22\xd3\x6c\x74\xa\x42\x65\x8b\x31\x9\x13\xb3\xb\xb\x99\xe\xf2\xc7\xf4\x29\x37\x63\xb0\x3f\xae\x65\x0\x99\x6\xf3\x33\x67\xe9\xbc\xa1\xff\x8c\x43\x5d\x3d\x77\x32\x6f\x1a\x21\xc2\xf3\xdd\x3d\x6f\x27\x33\x2f\xcf\x9f\xef\xe9\xf9\xe9\xdd\x27\x33\x3f\xbb\xfb\xa4\x9b\xae\x79\x75\xaf\x76\x8b\x1e\xca\x13\x97\xfb\xe0\x70\x9c\xc6\x92\x5c\x5b\x16\xaf\xe4\xcb\xa3\x97\x21\x54\xd4\xe0\x51\x5d\xd\x3e\x1d\x11\x83\x3d\x21\x31\xf8\x4c\x44\xb\x46\x5f\x4f\xc0\x1d\x57\xab\x37\xab\xfe\xed\xea\x15\x5f\x1d\x40\xf4\x58\xa4\xc8\xfa\xf7\xc9\xb8\x2a\x6b\x2b\x5a\x75\xfb\x87\x64\x6c\xd9\xed\x75\x98\xe\xed\x7d\xfe\x31\xd9\xfa\xd3\x27\x55\xd5\xd6\x2e\xa5\xa0\x6c\x93\xc6\x87\xff\x94\xa4\x3b\x6c\x9b\x1d\x78\xc4\x6\x7f\x74\x81\x53\xd1\xd1\x76\x75\x66\xb4\x2f\x5c\x8c\xfc\xe7\x64\x4c\x35\xf2\x63\x91\xf2\xcd\x77\x92\x31\xf5\x9b\x23\x8f\xc0\x94\xe6\x4d\x5f\x85\x8d\xee\x84\xc3\xf3\xcd\x72\x79\x6e\x7d\xcd\x6f\xdc\xf0\xea\x25\x9e\xd9\xa3\xc7\x60\x9a\x64\xe7\x42\xb5\xbc\xce\x2d\x8f\xc0\x4e\xea\x18\xc2\xee\x9b\xb3\x85\x72\xdd\xcb\x74\xa0\x5e\xd8\x75\xf3\x4a\xad\xe9\x65\x8c\xd1\xfd\x70\x60\xa1\xea\xf1\x1a\x30\x96\x5c\x88\x6f\x74\xb2\x47\x22\xfd\x7b\xb4\x0\x7\xe9\x55\x32\x39\x2e\x78\xeb\xb7\xfd\x5a\xb1\x8e\x76\xc2\xee\x52\xb5\x5c\xaa\x7a\xbc\x5f\xfc\x1b\xc2\x30\xb9\xec\x57\x97\xbd\xb5\x6\x7f\xc7\x12\x5f\xd1\x8\xec\xa9\x79\x2f\x34\x4b\x35\xaf\x8e\x13\xb4\x3c\x51\x7e\x1f\x7d\x6b\x37\x1c\xe1\xa3\xed\x32\x5b\x31\x54\xdd\xcf\xa1\x45\x59\xdd\xf\xd8\xb8\x31\xab\x52\xf7\x1a\xc0\x68\x75\x3f\x60\x75\xaf\x12\x26\xaa\x54\x39\x4c\x56\xf7\x3\x56\xf7\xca\xcc\x6a\xdd\xab\x2\xa4\xd5\xfd\x80\xd5\xbd\x6\xc0\x10\xa3\xac\xee\x7\xac\xee\x95\x99\x17\xa3\x8c\xb2\xba\x1f\xb0\xba\xd7\x0\x28\xea\x5e\x39\x30\xa8\xee\x7\xac\xee\x95\xd9\xb5\xba\x57\x15\x4a\xab\xfb\x1\xab\x7b\x55\xa0\xa2\xee\x55\xb8\xf\xaa\xfb\x1\xab\x7b\xe5\x1d\xd0\xea\x5e\x35\x30\xad\xee\x7\xac\xee\x55\x5\x8b\xba\x57\xd1\x9\x5e\xdd\xf\x58\xdd\x2b\xef\x42\x50\xf7\xca\x61\xb2\xba\x1f\xb0\xba\x57\x66\x56\xeb\x5e\x39\x90\x57\xf7\x3\x56\xf7\xca\x8c\x41\xdd\xab\xe8\xa1\xa8\xee\x7\xac\xee\x95\xf7\x4f\xa9\x7b\x15\x6c\xbc\xba\x1f\xb0\xba\x57\x4e\x47\xf7\xfd\x5e\x84\xbb\x24\x2c\x52\xdd\xf\xac\xbe\xec\xd9\x7\x7b\xdc\xc4\xa4\x70\xb4\xfe\x95\x41\x62\xea\x5f\xc5\x28\x46\xaa\xfc\x41\x1b\xf5\xaf\xfc\x26\xe8\x47\x75\xb7\xe0\x70\x38\x5e\x5e\xe5\xf\xac\xf4\x83\x3e\x5b\x37\xe\x56\xd4\xc1\xaa\x91\x6\x75\xb0\xa1\x30\x79\xb5\x3f\x68\xb5\xe\x56\xb\x30\xa8\x83\xd5\xb2\x43\x56\xfb\x83\xa0\xe\x56\xcd\x13\xa5\xe\x96\xb7\xe3\xd5\xfe\x20\xa8\x83\x65\x17\x68\x1d\xec\x4a\x7c\xb5\x3f\xb9\x4d\x53\x2d\x8f\x5d\x4c\xd5\xff\x6d\x38\x22\x1f\x2e\x51\x87\xf\xd3\xe7\x65\x1b\xe\xe5\xf\x4b\xdc\xb0\xe3\xc5\xe0\xd4\xb\x58\x30\x7b\xb2\xf5\x84\x50\x4e\xbf\xe2\xce\xa0\xc0\x96\xcf\xa0\x40\x3b\x67\x50\xa0\x85\x33\x28\xd0\xd6\x19\x14\x68\xe1\xc\xa\xb4\x77\x6\x5\x5a\x3a\x83\x2\xed\x9e\x41\x81\x16\xcf\xa0\x40\x7b\x67\x50\x60\x4b\x67\x50\x60\x2b\x67\x50\x60\xb\x67\x50\x60\x8b\x67\x50\x60\xa3\x33\xa8\x91\xb7\x8d\xd\xb6\xe2\x1\xdb\x8a\xbf\x1e\xde\x8a\x6f\x53\x76\x54\x36\x54\x56\x7e\xfe\xa5\x7a\x49\xb4\xab\x35\x43\xca\xcf\xa5\xe4\x1\xc0\xc6\xfb\x24\x60\xf3\x7d\x12\xd0\xc2\x56\xc6\x4b\xe0\x1\xb7\x32\x80\xd8\xca\xf8\xcd\x86\x2b\xfa\xb\xad\x8b\xe2\xc6\x5b\x1a\x57\xb7\x91\x74\xb3\xad\x8d\x2f\x82\x7\xda\xda\x0\x6c\x6b\xe3\xb7\xff\x9b\x81\x90\x5b\x1c\x1f\xc9\x48\xc4\x6f\x75\xb4\xbf\xc6\x17\x8b\xfa\xd1\x57\x12\x30\x4d\x7a\x76\xb1\x50\x5b\xf5\xd8\x86\xc9\x34\x4\x85\x71\xcc\x82\x1a\x7b\x80\xa0\x82\xa6\x47\x4f\x8d\xcf\x75\xb8\xa0\x30\x4e\x39\xb2\x7c\x7b\x76\xab\x1c\x59\xca\x91\xa5\x1c\x13\x7c\x22\x6f\x95\x63\x82\x72\x4c\x50\xe\xf6\x43\xe7\xad\x73\xd8\x94\xc3\xa6\x1c\xc7\xe9\x6f\xa0\xb7\xce\x71\x9c\x72\x1c\x1f\xe9\x84\xe0\xd4\x38\xfd\xcc\xd2\xcf\x9\xfa\x69\xd3\xcf\xe3\xd3\x29\xd8\x57\x26\x8d\xd8\xc6\xd3\xa1\x59\x38\x18\x79\x71\x44\x3\xb0\x6f\x76\xc1\x9d\x39\x77\x76\x3e\xcf\x6e\xb6\x62\x60\x37\x5d\x33\x5c\xcb\x80\xdc\x35\x38\x10\x6c\x6c\xb1\xc7\xf7\xd6\x4f\x40\xf1\x1d\xba\x68\x4e\x4b\x26\xaa\x6f\xb9\xcf\x42\xa8\x54\xeb\xb4\x40\xbb\x4e\x37\x38\xe\x6e\xd2\x50\x29\x13\x52\xfc\x4d\x4f\x42\x6b\xd9\xaf\x1c\x65\xbf\xd5\xbf\x3f\xc5\x9c\xf1\xbe\x61\xbc\x1\xba\x99\xdb\xff\x6\x0\x0\xff\xff\x74\x3e\x9d\x68");
  }
}
