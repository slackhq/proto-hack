<?hh // strict
namespace protobuf_test_messages\proto2;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/test_messages_proto2.proto

newtype ForeignEnumProto2_enum_t as int = int;
abstract class ForeignEnumProto2 {
  const ForeignEnumProto2_enum_t FOREIGN_FOO = 0;
  const ForeignEnumProto2_enum_t FOREIGN_BAR = 1;
  const ForeignEnumProto2_enum_t FOREIGN_BAZ = 2;
  private static dict<int, string> $itos = dict[
    0 => 'FOREIGN_FOO',
    1 => 'FOREIGN_BAR',
    2 => 'FOREIGN_BAZ',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FOREIGN_FOO' => 0,
    'FOREIGN_BAR' => 1,
    'FOREIGN_BAZ' => 2,
  ];
  public static function FromMixed(mixed $m): ForeignEnumProto2_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): ForeignEnumProto2_enum_t {
    return $i;
  }
}

newtype TestAllTypesProto2_NestedEnum_enum_t as int = int;
abstract class TestAllTypesProto2_NestedEnum {
  const TestAllTypesProto2_NestedEnum_enum_t FOO = 0;
  const TestAllTypesProto2_NestedEnum_enum_t BAR = 1;
  const TestAllTypesProto2_NestedEnum_enum_t BAZ = 2;
  const TestAllTypesProto2_NestedEnum_enum_t NEG = -1;
  private static dict<int, string> $itos = dict[
    0 => 'FOO',
    1 => 'BAR',
    2 => 'BAZ',
    -1 => 'NEG',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'FOO' => 0,
    'BAR' => 1,
    'BAZ' => 2,
    'NEG' => -1,
  ];
  public static function FromMixed(mixed $m): TestAllTypesProto2_NestedEnum_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): TestAllTypesProto2_NestedEnum_enum_t {
    return $i;
  }
}

enum TestAllTypesProto2_oneof_field_oneof_t: int {
  NOT_SET = 0;
  oneof_uint32 = 111;
  oneof_nested_message = 112;
  oneof_string = 113;
  oneof_bytes = 114;
  oneof_bool = 115;
  oneof_uint64 = 116;
  oneof_float = 117;
  oneof_double = 118;
  oneof_enum = 119;
}

interface TestAllTypesProto2_oneof_field {
  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): TestAllTypesProto2_oneof_field;
}

class TestAllTypesProto2_oneof_field_NOT_SET implements TestAllTypesProto2_oneof_field {
  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): TestAllTypesProto2_oneof_field { return $this; }
}

class TestAllTypesProto2_oneof_field_oneof_uint32 implements TestAllTypesProto2_oneof_field {
  public function __construct(public int $oneof_uint32) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_uint32;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(111, 0);;
    $e->writeVarint($this->oneof_uint32);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('oneof_uint32', 'oneofUint32', $this->oneof_uint32, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_uint32($this->oneof_uint32);
  }
}

class TestAllTypesProto2_oneof_field_oneof_nested_message implements TestAllTypesProto2_oneof_field {
  public function __construct(public \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $oneof_nested_message) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_nested_message;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->oneof_nested_message->WriteTo($nested);
    $e->writeEncoder($nested, 112);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('oneof_nested_message', 'oneofNestedMessage', $this->oneof_nested_message, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
    $nv->CopyFrom($this->oneof_nested_message);
    return new TestAllTypesProto2_oneof_field_oneof_nested_message($nv);
  }
}

class TestAllTypesProto2_oneof_field_oneof_string implements TestAllTypesProto2_oneof_field {
  public function __construct(public string $oneof_string) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_string;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(113, 2);;
    $e->writeString($this->oneof_string);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('oneof_string', 'oneofString', $this->oneof_string, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_string($this->oneof_string);
  }
}

class TestAllTypesProto2_oneof_field_oneof_bytes implements TestAllTypesProto2_oneof_field {
  public function __construct(public string $oneof_bytes) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_bytes;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(114, 2);;
    $e->writeString($this->oneof_bytes);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBytes('oneof_bytes', 'oneofBytes', $this->oneof_bytes, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_bytes($this->oneof_bytes);
  }
}

class TestAllTypesProto2_oneof_field_oneof_bool implements TestAllTypesProto2_oneof_field {
  public function __construct(public bool $oneof_bool) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_bool;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(115, 0);;
    $e->writeBool($this->oneof_bool);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('oneof_bool', 'oneofBool', $this->oneof_bool, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_bool($this->oneof_bool);
  }
}

class TestAllTypesProto2_oneof_field_oneof_uint64 implements TestAllTypesProto2_oneof_field {
  public function __construct(public int $oneof_uint64) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_uint64;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(116, 0);;
    $e->writeVarint($this->oneof_uint64);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('oneof_uint64', 'oneofUint64', $this->oneof_uint64, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_uint64($this->oneof_uint64);
  }
}

class TestAllTypesProto2_oneof_field_oneof_float implements TestAllTypesProto2_oneof_field {
  public function __construct(public float $oneof_float) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_float;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(117, 5);;
    $e->writeFloat($this->oneof_float);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeFloat('oneof_float', 'oneofFloat', $this->oneof_float, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_float($this->oneof_float);
  }
}

class TestAllTypesProto2_oneof_field_oneof_double implements TestAllTypesProto2_oneof_field {
  public function __construct(public float $oneof_double) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_double;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(118, 1);;
    $e->writeDouble($this->oneof_double);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeFloat('oneof_double', 'oneofDouble', $this->oneof_double, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_double($this->oneof_double);
  }
}

class TestAllTypesProto2_oneof_field_oneof_enum implements TestAllTypesProto2_oneof_field {
  public function __construct(public \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t $oneof_enum) {}

  public function WhichOneof(): TestAllTypesProto2_oneof_field_oneof_t {
    return TestAllTypesProto2_oneof_field_oneof_t::oneof_enum;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(119, 0);;
    $e->writeVarint($this->oneof_enum);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('oneof_enum', 'oneofEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->oneof_enum, true);
  }

  public function Copy(): TestAllTypesProto2_oneof_field {
    return new TestAllTypesProto2_oneof_field_oneof_enum($this->oneof_enum);
  }
}

class TestAllTypesProto2_NestedMessage implements \Protobuf\Message {
  public int $a;
  public ?\protobuf_test_messages\proto2\TestAllTypesProto2 $corecursive;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'a' => int,
    ?'corecursive' => ?\protobuf_test_messages\proto2\TestAllTypesProto2,
  ) $s = shape()) {
    $this->a = $s['a'] ?? 0;
    $this->corecursive = $s['corecursive'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.NestedMessage";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_NestedMessage {
    $msg = new TestAllTypesProto2_NestedMessage();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->a = $d->readVarint32Signed();
          break;
        case 2:
          if ($this->corecursive == null) $this->corecursive = new \protobuf_test_messages\proto2\TestAllTypesProto2();
          $this->corecursive->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->a !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->a);
    }
    $msg = $this->corecursive;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('a', 'a', $this->a, false);
    $e->writeMessage('corecursive', 'corecursive', $this->corecursive, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'a':
          $this->a = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'corecursive':
          if ($v === null) break;
          if ($this->corecursive == null) $this->corecursive = new \protobuf_test_messages\proto2\TestAllTypesProto2();
          $this->corecursive->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_NestedMessage)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->a = $o->a;
    $tmp = $o->corecursive;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2();
      $nv->CopyFrom($tmp);
      $this->corecursive = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt32Int32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt32Int32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapInt32Int32Entry {
    $msg = new TestAllTypesProto2_MapInt32Int32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt32Int32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt64Int64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt64Int64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapInt64Int64Entry {
    $msg = new TestAllTypesProto2_MapInt64Int64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint();
          break;
        case 2:
          $this->value = $d->readVarint();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt64Int64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapUint32Uint32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapUint32Uint32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapUint32Uint32Entry {
    $msg = new TestAllTypesProto2_MapUint32Uint32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32();
          break;
        case 2:
          $this->value = $d->readVarint32();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapUint32Uint32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapUint64Uint64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapUint64Uint64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapUint64Uint64Entry {
    $msg = new TestAllTypesProto2_MapUint64Uint64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint();
          break;
        case 2:
          $this->value = $d->readVarint();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('key', 'key', $this->key, false);
    $e->writeInt64Unsigned('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapUint64Uint64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSint32Sint32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSint32Sint32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapSint32Sint32Entry {
    $msg = new TestAllTypesProto2_MapSint32Sint32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarintZigZag32();
          break;
        case 2:
          $this->value = $d->readVarintZigZag32();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarintZigZag32($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarintZigZag32($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSint32Sint32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSint64Sint64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSint64Sint64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapSint64Sint64Entry {
    $msg = new TestAllTypesProto2_MapSint64Sint64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarintZigZag64();
          break;
        case 2:
          $this->value = $d->readVarintZigZag64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarintZigZag64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarintZigZag64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSint64Sint64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapFixed32Fixed32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapFixed32Fixed32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapFixed32Fixed32Entry {
    $msg = new TestAllTypesProto2_MapFixed32Fixed32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt32Unsigned();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt32Unsigned();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 5);
      $e->writeLittleEndianInt32Unsigned($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 5);
      $e->writeLittleEndianInt32Unsigned($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapFixed32Fixed32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapFixed64Fixed64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapFixed64Fixed64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapFixed64Fixed64Entry {
    $msg = new TestAllTypesProto2_MapFixed64Fixed64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt64();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 1);
      $e->writeLittleEndianInt64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 1);
      $e->writeLittleEndianInt64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Unsigned('key', 'key', $this->key, false);
    $e->writeInt64Unsigned('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapFixed64Fixed64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSfixed32Sfixed32Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSfixed32Sfixed32Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapSfixed32Sfixed32Entry {
    $msg = new TestAllTypesProto2_MapSfixed32Sfixed32Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt32Signed();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 5);
      $e->writeLittleEndianInt32Signed($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 5);
      $e->writeLittleEndianInt32Signed($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeInt32('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSfixed32Sfixed32Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapSfixed64Sfixed64Entry implements \Protobuf\Message {
  public int $key;
  public int $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => int,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapSfixed64Sfixed64Entry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapSfixed64Sfixed64Entry {
    $msg = new TestAllTypesProto2_MapSfixed64Sfixed64Entry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readLittleEndianInt64();
          break;
        case 2:
          $this->value = $d->readLittleEndianInt64();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 1);
      $e->writeLittleEndianInt64($this->key);
    }
    if ($this->value !== 0) {
      $e->writeTag(2, 1);
      $e->writeLittleEndianInt64($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt64Signed('key', 'key', $this->key, false);
    $e->writeInt64Signed('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapSfixed64Sfixed64Entry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt32FloatEntry implements \Protobuf\Message {
  public int $key;
  public float $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => float,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0.0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt32FloatEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapInt32FloatEntry {
    $msg = new TestAllTypesProto2_MapInt32FloatEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readFloat();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0.0) {
      $e->writeTag(2, 5);
      $e->writeFloat($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeFloat('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt32FloatEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapInt32DoubleEntry implements \Protobuf\Message {
  public int $key;
  public float $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => int,
    ?'value' => float,
  ) $s = shape()) {
    $this->key = $s['key'] ?? 0;
    $this->value = $s['value'] ?? 0.0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapInt32DoubleEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapInt32DoubleEntry {
    $msg = new TestAllTypesProto2_MapInt32DoubleEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readVarint32Signed();
          break;
        case 2:
          $this->value = $d->readDouble();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->key);
    }
    if ($this->value !== 0.0) {
      $e->writeTag(2, 1);
      $e->writeDouble($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('key', 'key', $this->key, false);
    $e->writeFloat('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapInt32DoubleEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapBoolBoolEntry implements \Protobuf\Message {
  public bool $key;
  public bool $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => bool,
    ?'value' => bool,
  ) $s = shape()) {
    $this->key = $s['key'] ?? false;
    $this->value = $s['value'] ?? false;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapBoolBoolEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapBoolBoolEntry {
    $msg = new TestAllTypesProto2_MapBoolBoolEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readBool();
          break;
        case 2:
          $this->value = $d->readBool();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== false) {
      $e->writeTag(1, 0);
      $e->writeBool($this->key);
    }
    if ($this->value !== false) {
      $e->writeTag(2, 0);
      $e->writeBool($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('key', 'key', $this->key, false);
    $e->writeBool('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapBoolBoolEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringStringEntry implements \Protobuf\Message {
  public string $key;
  public string $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => string,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringStringEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringStringEntry {
    $msg = new TestAllTypesProto2_MapStringStringEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeString('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringStringEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringBytesEntry implements \Protobuf\Message {
  public string $key;
  public string $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => string,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringBytesEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringBytesEntry {
    $msg = new TestAllTypesProto2_MapStringBytesEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeBytes('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringBytesEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringNestedMessageEntry implements \Protobuf\Message {
  public string $key;
  public ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringNestedMessageEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringNestedMessageEntry {
    $msg = new TestAllTypesProto2_MapStringNestedMessageEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeMessage('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          if ($v === null) break;
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringNestedMessageEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $tmp = $o->value;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->value = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringForeignMessageEntry implements \Protobuf\Message {
  public string $key;
  public ?\protobuf_test_messages\proto2\ForeignMessageProto2 $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => ?\protobuf_test_messages\proto2\ForeignMessageProto2,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringForeignMessageEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringForeignMessageEntry {
    $msg = new TestAllTypesProto2_MapStringForeignMessageEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeMessage('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          if ($v === null) break;
          if ($this->value == null) $this->value = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringForeignMessageEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $tmp = $o->value;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($tmp);
      $this->value = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringNestedEnumEntry implements \Protobuf\Message {
  public string $key;
  public \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FOO;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringNestedEnumEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringNestedEnumEntry {
    $msg = new TestAllTypesProto2_MapStringNestedEnumEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FOO) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeEnum('value', 'value', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringNestedEnumEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MapStringForeignEnumEntry implements \Protobuf\Message {
  public string $key;
  public \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? \protobuf_test_messages\proto2\ForeignEnumProto2::FOREIGN_FOO;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MapStringForeignEnumEntry";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MapStringForeignEnumEntry {
    $msg = new TestAllTypesProto2_MapStringForeignEnumEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          $this->value = \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    if ($this->value !== \protobuf_test_messages\proto2\ForeignEnumProto2::FOREIGN_FOO) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeEnum('value', 'value', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          $this->value = \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MapStringForeignEnumEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $this->value = $o->value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_Data implements \Protobuf\Message {
  public int $group_int32;
  public int $group_uint32;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'group_int32' => int,
    ?'group_uint32' => int,
  ) $s = shape()) {
    $this->group_int32 = $s['group_int32'] ?? 0;
    $this->group_uint32 = $s['group_uint32'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.Data";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_Data {
    $msg = new TestAllTypesProto2_Data();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 202:
          $this->group_int32 = $d->readVarint32Signed();
          break;
        case 203:
          $this->group_uint32 = $d->readVarint32();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->group_int32 !== 0) {
      $e->writeTag(202, 0);
      $e->writeVarint($this->group_int32);
    }
    if ($this->group_uint32 !== 0) {
      $e->writeTag(203, 0);
      $e->writeVarint($this->group_uint32);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('group_int32', 'groupInt32', $this->group_int32, false);
    $e->writeInt32('group_uint32', 'groupUint32', $this->group_uint32, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'group_int32': case 'groupInt32':
          $this->group_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'group_uint32': case 'groupUint32':
          $this->group_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_Data)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->group_int32 = $o->group_int32;
    $this->group_uint32 = $o->group_uint32;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MessageSetCorrect implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MessageSetCorrect";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MessageSetCorrect {
    $msg = new TestAllTypesProto2_MessageSetCorrect();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MessageSetCorrect)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MessageSetCorrectExtension1 implements \Protobuf\Message {
  public string $str;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'str' => string,
  ) $s = shape()) {
    $this->str = $s['str'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MessageSetCorrectExtension1";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MessageSetCorrectExtension1 {
    $msg = new TestAllTypesProto2_MessageSetCorrectExtension1();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 25:
          $this->str = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->str !== '') {
      $e->writeTag(25, 2);
      $e->writeString($this->str);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('str', 'str', $this->str, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'str':
          $this->str = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MessageSetCorrectExtension1)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->str = $o->str;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2_MessageSetCorrectExtension2 implements \Protobuf\Message {
  public int $i;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'i' => int,
  ) $s = shape()) {
    $this->i = $s['i'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2.MessageSetCorrectExtension2";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2_MessageSetCorrectExtension2 {
    $msg = new TestAllTypesProto2_MessageSetCorrectExtension2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 9:
          $this->i = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->i !== 0) {
      $e->writeTag(9, 0);
      $e->writeVarint($this->i);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('i', 'i', $this->i, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'i':
          $this->i = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2_MessageSetCorrectExtension2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->i = $o->i;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class TestAllTypesProto2 implements \Protobuf\Message {
  public int $optional_int32;
  public int $optional_int64;
  public int $optional_uint32;
  public int $optional_uint64;
  public int $optional_sint32;
  public int $optional_sint64;
  public int $optional_fixed32;
  public int $optional_fixed64;
  public int $optional_sfixed32;
  public int $optional_sfixed64;
  public float $optional_float;
  public float $optional_double;
  public bool $optional_bool;
  public string $optional_string;
  public string $optional_bytes;
  public ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage $optional_nested_message;
  public ?\protobuf_test_messages\proto2\ForeignMessageProto2 $optional_foreign_message;
  public \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t $optional_nested_enum;
  public \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t $optional_foreign_enum;
  public string $optional_string_piece;
  public string $optional_cord;
  public ?\protobuf_test_messages\proto2\TestAllTypesProto2 $recursive_message;
  public vec<int> $repeated_int32;
  public vec<int> $repeated_int64;
  public vec<int> $repeated_uint32;
  public vec<int> $repeated_uint64;
  public vec<int> $repeated_sint32;
  public vec<int> $repeated_sint64;
  public vec<int> $repeated_fixed32;
  public vec<int> $repeated_fixed64;
  public vec<int> $repeated_sfixed32;
  public vec<int> $repeated_sfixed64;
  public vec<float> $repeated_float;
  public vec<float> $repeated_double;
  public vec<bool> $repeated_bool;
  public vec<string> $repeated_string;
  public vec<string> $repeated_bytes;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage> $repeated_nested_message;
  public vec<\protobuf_test_messages\proto2\ForeignMessageProto2> $repeated_foreign_message;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $repeated_nested_enum;
  public vec<\protobuf_test_messages\proto2\ForeignEnumProto2_enum_t> $repeated_foreign_enum;
  public vec<string> $repeated_string_piece;
  public vec<string> $repeated_cord;
  public vec<int> $packed_int32;
  public vec<int> $packed_int64;
  public vec<int> $packed_uint32;
  public vec<int> $packed_uint64;
  public vec<int> $packed_sint32;
  public vec<int> $packed_sint64;
  public vec<int> $packed_fixed32;
  public vec<int> $packed_fixed64;
  public vec<int> $packed_sfixed32;
  public vec<int> $packed_sfixed64;
  public vec<float> $packed_float;
  public vec<float> $packed_double;
  public vec<bool> $packed_bool;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $packed_nested_enum;
  public vec<int> $unpacked_int32;
  public vec<int> $unpacked_int64;
  public vec<int> $unpacked_uint32;
  public vec<int> $unpacked_uint64;
  public vec<int> $unpacked_sint32;
  public vec<int> $unpacked_sint64;
  public vec<int> $unpacked_fixed32;
  public vec<int> $unpacked_fixed64;
  public vec<int> $unpacked_sfixed32;
  public vec<int> $unpacked_sfixed64;
  public vec<float> $unpacked_float;
  public vec<float> $unpacked_double;
  public vec<bool> $unpacked_bool;
  public vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $unpacked_nested_enum;
  public dict<int, int> $map_int32_int32;
  public dict<int, int> $map_int64_int64;
  public dict<int, int> $map_uint32_uint32;
  public dict<int, int> $map_uint64_uint64;
  public dict<int, int> $map_sint32_sint32;
  public dict<int, int> $map_sint64_sint64;
  public dict<int, int> $map_fixed32_fixed32;
  public dict<int, int> $map_fixed64_fixed64;
  public dict<int, int> $map_sfixed32_sfixed32;
  public dict<int, int> $map_sfixed64_sfixed64;
  public dict<int, float> $map_int32_float;
  public dict<int, float> $map_int32_double;
  public dict<\Protobuf\Internal\bool_map_key_t, bool> $map_bool_bool;
  public dict<string, string> $map_string_string;
  public dict<string, string> $map_string_bytes;
  public dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage> $map_string_nested_message;
  public dict<string, \protobuf_test_messages\proto2\ForeignMessageProto2> $map_string_foreign_message;
  public dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t> $map_string_nested_enum;
  public dict<string, \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t> $map_string_foreign_enum;
  public ?\protobuf_test_messages\proto2\TestAllTypesProto2_Data $data;
  public int $default_int32;
  public int $default_int64;
  public int $default_uint32;
  public int $default_uint64;
  public int $default_sint32;
  public int $default_sint64;
  public int $default_fixed32;
  public int $default_fixed64;
  public int $default_sfixed32;
  public int $default_sfixed64;
  public float $default_float;
  public float $default_double;
  public bool $default_bool;
  public string $default_string;
  public string $default_bytes;
  public int $fieldname1;
  public int $field_name2;
  public int $_field_name3;
  public int $field__name4_;
  public int $field0name5;
  public int $field_0_name6;
  public int $fieldName7;
  public int $FieldName8;
  public int $field_Name9;
  public int $Field_Name10;
  public int $FIELD_NAME11;
  public int $FIELD_name12;
  public int $__field_name13;
  public int $__Field_name14;
  public int $field__name15;
  public int $field__Name16;
  public int $field_name17__;
  public int $Field_name18__;
  public TestAllTypesProto2_oneof_field $oneof_field;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'optional_int32' => int,
    ?'optional_int64' => int,
    ?'optional_uint32' => int,
    ?'optional_uint64' => int,
    ?'optional_sint32' => int,
    ?'optional_sint64' => int,
    ?'optional_fixed32' => int,
    ?'optional_fixed64' => int,
    ?'optional_sfixed32' => int,
    ?'optional_sfixed64' => int,
    ?'optional_float' => float,
    ?'optional_double' => float,
    ?'optional_bool' => bool,
    ?'optional_string' => string,
    ?'optional_bytes' => string,
    ?'optional_nested_message' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage,
    ?'optional_foreign_message' => ?\protobuf_test_messages\proto2\ForeignMessageProto2,
    ?'optional_nested_enum' => \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t,
    ?'optional_foreign_enum' => \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t,
    ?'optional_string_piece' => string,
    ?'optional_cord' => string,
    ?'recursive_message' => ?\protobuf_test_messages\proto2\TestAllTypesProto2,
    ?'repeated_int32' => vec<int>,
    ?'repeated_int64' => vec<int>,
    ?'repeated_uint32' => vec<int>,
    ?'repeated_uint64' => vec<int>,
    ?'repeated_sint32' => vec<int>,
    ?'repeated_sint64' => vec<int>,
    ?'repeated_fixed32' => vec<int>,
    ?'repeated_fixed64' => vec<int>,
    ?'repeated_sfixed32' => vec<int>,
    ?'repeated_sfixed64' => vec<int>,
    ?'repeated_float' => vec<float>,
    ?'repeated_double' => vec<float>,
    ?'repeated_bool' => vec<bool>,
    ?'repeated_string' => vec<string>,
    ?'repeated_bytes' => vec<string>,
    ?'repeated_nested_message' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage>,
    ?'repeated_foreign_message' => vec<\protobuf_test_messages\proto2\ForeignMessageProto2>,
    ?'repeated_nested_enum' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'repeated_foreign_enum' => vec<\protobuf_test_messages\proto2\ForeignEnumProto2_enum_t>,
    ?'repeated_string_piece' => vec<string>,
    ?'repeated_cord' => vec<string>,
    ?'packed_int32' => vec<int>,
    ?'packed_int64' => vec<int>,
    ?'packed_uint32' => vec<int>,
    ?'packed_uint64' => vec<int>,
    ?'packed_sint32' => vec<int>,
    ?'packed_sint64' => vec<int>,
    ?'packed_fixed32' => vec<int>,
    ?'packed_fixed64' => vec<int>,
    ?'packed_sfixed32' => vec<int>,
    ?'packed_sfixed64' => vec<int>,
    ?'packed_float' => vec<float>,
    ?'packed_double' => vec<float>,
    ?'packed_bool' => vec<bool>,
    ?'packed_nested_enum' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'unpacked_int32' => vec<int>,
    ?'unpacked_int64' => vec<int>,
    ?'unpacked_uint32' => vec<int>,
    ?'unpacked_uint64' => vec<int>,
    ?'unpacked_sint32' => vec<int>,
    ?'unpacked_sint64' => vec<int>,
    ?'unpacked_fixed32' => vec<int>,
    ?'unpacked_fixed64' => vec<int>,
    ?'unpacked_sfixed32' => vec<int>,
    ?'unpacked_sfixed64' => vec<int>,
    ?'unpacked_float' => vec<float>,
    ?'unpacked_double' => vec<float>,
    ?'unpacked_bool' => vec<bool>,
    ?'unpacked_nested_enum' => vec<\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'map_int32_int32' => dict<int, int>,
    ?'map_int64_int64' => dict<int, int>,
    ?'map_uint32_uint32' => dict<int, int>,
    ?'map_uint64_uint64' => dict<int, int>,
    ?'map_sint32_sint32' => dict<int, int>,
    ?'map_sint64_sint64' => dict<int, int>,
    ?'map_fixed32_fixed32' => dict<int, int>,
    ?'map_fixed64_fixed64' => dict<int, int>,
    ?'map_sfixed32_sfixed32' => dict<int, int>,
    ?'map_sfixed64_sfixed64' => dict<int, int>,
    ?'map_int32_float' => dict<int, float>,
    ?'map_int32_double' => dict<int, float>,
    ?'map_bool_bool' => dict<\Protobuf\Internal\bool_map_key_t, bool>,
    ?'map_string_string' => dict<string, string>,
    ?'map_string_bytes' => dict<string, string>,
    ?'map_string_nested_message' => dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage>,
    ?'map_string_foreign_message' => dict<string, \protobuf_test_messages\proto2\ForeignMessageProto2>,
    ?'map_string_nested_enum' => dict<string, \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum_enum_t>,
    ?'map_string_foreign_enum' => dict<string, \protobuf_test_messages\proto2\ForeignEnumProto2_enum_t>,
    ?'data' => ?\protobuf_test_messages\proto2\TestAllTypesProto2_Data,
    ?'default_int32' => int,
    ?'default_int64' => int,
    ?'default_uint32' => int,
    ?'default_uint64' => int,
    ?'default_sint32' => int,
    ?'default_sint64' => int,
    ?'default_fixed32' => int,
    ?'default_fixed64' => int,
    ?'default_sfixed32' => int,
    ?'default_sfixed64' => int,
    ?'default_float' => float,
    ?'default_double' => float,
    ?'default_bool' => bool,
    ?'default_string' => string,
    ?'default_bytes' => string,
    ?'fieldname1' => int,
    ?'field_name2' => int,
    ?'_field_name3' => int,
    ?'field__name4_' => int,
    ?'field0name5' => int,
    ?'field_0_name6' => int,
    ?'fieldName7' => int,
    ?'FieldName8' => int,
    ?'field_Name9' => int,
    ?'Field_Name10' => int,
    ?'FIELD_NAME11' => int,
    ?'FIELD_name12' => int,
    ?'__field_name13' => int,
    ?'__Field_name14' => int,
    ?'field__name15' => int,
    ?'field__Name16' => int,
    ?'field_name17__' => int,
    ?'Field_name18__' => int,
    ?'oneof_field' => TestAllTypesProto2_oneof_field,
  ) $s = shape()) {
    $this->optional_int32 = $s['optional_int32'] ?? 0;
    $this->optional_int64 = $s['optional_int64'] ?? 0;
    $this->optional_uint32 = $s['optional_uint32'] ?? 0;
    $this->optional_uint64 = $s['optional_uint64'] ?? 0;
    $this->optional_sint32 = $s['optional_sint32'] ?? 0;
    $this->optional_sint64 = $s['optional_sint64'] ?? 0;
    $this->optional_fixed32 = $s['optional_fixed32'] ?? 0;
    $this->optional_fixed64 = $s['optional_fixed64'] ?? 0;
    $this->optional_sfixed32 = $s['optional_sfixed32'] ?? 0;
    $this->optional_sfixed64 = $s['optional_sfixed64'] ?? 0;
    $this->optional_float = $s['optional_float'] ?? 0.0;
    $this->optional_double = $s['optional_double'] ?? 0.0;
    $this->optional_bool = $s['optional_bool'] ?? false;
    $this->optional_string = $s['optional_string'] ?? '';
    $this->optional_bytes = $s['optional_bytes'] ?? '';
    $this->optional_nested_message = $s['optional_nested_message'] ?? null;
    $this->optional_foreign_message = $s['optional_foreign_message'] ?? null;
    $this->optional_nested_enum = $s['optional_nested_enum'] ?? \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FOO;
    $this->optional_foreign_enum = $s['optional_foreign_enum'] ?? \protobuf_test_messages\proto2\ForeignEnumProto2::FOREIGN_FOO;
    $this->optional_string_piece = $s['optional_string_piece'] ?? '';
    $this->optional_cord = $s['optional_cord'] ?? '';
    $this->recursive_message = $s['recursive_message'] ?? null;
    $this->repeated_int32 = $s['repeated_int32'] ?? vec[];
    $this->repeated_int64 = $s['repeated_int64'] ?? vec[];
    $this->repeated_uint32 = $s['repeated_uint32'] ?? vec[];
    $this->repeated_uint64 = $s['repeated_uint64'] ?? vec[];
    $this->repeated_sint32 = $s['repeated_sint32'] ?? vec[];
    $this->repeated_sint64 = $s['repeated_sint64'] ?? vec[];
    $this->repeated_fixed32 = $s['repeated_fixed32'] ?? vec[];
    $this->repeated_fixed64 = $s['repeated_fixed64'] ?? vec[];
    $this->repeated_sfixed32 = $s['repeated_sfixed32'] ?? vec[];
    $this->repeated_sfixed64 = $s['repeated_sfixed64'] ?? vec[];
    $this->repeated_float = $s['repeated_float'] ?? vec[];
    $this->repeated_double = $s['repeated_double'] ?? vec[];
    $this->repeated_bool = $s['repeated_bool'] ?? vec[];
    $this->repeated_string = $s['repeated_string'] ?? vec[];
    $this->repeated_bytes = $s['repeated_bytes'] ?? vec[];
    $this->repeated_nested_message = $s['repeated_nested_message'] ?? vec[];
    $this->repeated_foreign_message = $s['repeated_foreign_message'] ?? vec[];
    $this->repeated_nested_enum = $s['repeated_nested_enum'] ?? vec[];
    $this->repeated_foreign_enum = $s['repeated_foreign_enum'] ?? vec[];
    $this->repeated_string_piece = $s['repeated_string_piece'] ?? vec[];
    $this->repeated_cord = $s['repeated_cord'] ?? vec[];
    $this->packed_int32 = $s['packed_int32'] ?? vec[];
    $this->packed_int64 = $s['packed_int64'] ?? vec[];
    $this->packed_uint32 = $s['packed_uint32'] ?? vec[];
    $this->packed_uint64 = $s['packed_uint64'] ?? vec[];
    $this->packed_sint32 = $s['packed_sint32'] ?? vec[];
    $this->packed_sint64 = $s['packed_sint64'] ?? vec[];
    $this->packed_fixed32 = $s['packed_fixed32'] ?? vec[];
    $this->packed_fixed64 = $s['packed_fixed64'] ?? vec[];
    $this->packed_sfixed32 = $s['packed_sfixed32'] ?? vec[];
    $this->packed_sfixed64 = $s['packed_sfixed64'] ?? vec[];
    $this->packed_float = $s['packed_float'] ?? vec[];
    $this->packed_double = $s['packed_double'] ?? vec[];
    $this->packed_bool = $s['packed_bool'] ?? vec[];
    $this->packed_nested_enum = $s['packed_nested_enum'] ?? vec[];
    $this->unpacked_int32 = $s['unpacked_int32'] ?? vec[];
    $this->unpacked_int64 = $s['unpacked_int64'] ?? vec[];
    $this->unpacked_uint32 = $s['unpacked_uint32'] ?? vec[];
    $this->unpacked_uint64 = $s['unpacked_uint64'] ?? vec[];
    $this->unpacked_sint32 = $s['unpacked_sint32'] ?? vec[];
    $this->unpacked_sint64 = $s['unpacked_sint64'] ?? vec[];
    $this->unpacked_fixed32 = $s['unpacked_fixed32'] ?? vec[];
    $this->unpacked_fixed64 = $s['unpacked_fixed64'] ?? vec[];
    $this->unpacked_sfixed32 = $s['unpacked_sfixed32'] ?? vec[];
    $this->unpacked_sfixed64 = $s['unpacked_sfixed64'] ?? vec[];
    $this->unpacked_float = $s['unpacked_float'] ?? vec[];
    $this->unpacked_double = $s['unpacked_double'] ?? vec[];
    $this->unpacked_bool = $s['unpacked_bool'] ?? vec[];
    $this->unpacked_nested_enum = $s['unpacked_nested_enum'] ?? vec[];
    $this->map_int32_int32 = $s['map_int32_int32'] ?? dict[];
    $this->map_int64_int64 = $s['map_int64_int64'] ?? dict[];
    $this->map_uint32_uint32 = $s['map_uint32_uint32'] ?? dict[];
    $this->map_uint64_uint64 = $s['map_uint64_uint64'] ?? dict[];
    $this->map_sint32_sint32 = $s['map_sint32_sint32'] ?? dict[];
    $this->map_sint64_sint64 = $s['map_sint64_sint64'] ?? dict[];
    $this->map_fixed32_fixed32 = $s['map_fixed32_fixed32'] ?? dict[];
    $this->map_fixed64_fixed64 = $s['map_fixed64_fixed64'] ?? dict[];
    $this->map_sfixed32_sfixed32 = $s['map_sfixed32_sfixed32'] ?? dict[];
    $this->map_sfixed64_sfixed64 = $s['map_sfixed64_sfixed64'] ?? dict[];
    $this->map_int32_float = $s['map_int32_float'] ?? dict[];
    $this->map_int32_double = $s['map_int32_double'] ?? dict[];
    $this->map_bool_bool = $s['map_bool_bool'] ?? dict[];
    $this->map_string_string = $s['map_string_string'] ?? dict[];
    $this->map_string_bytes = $s['map_string_bytes'] ?? dict[];
    $this->map_string_nested_message = $s['map_string_nested_message'] ?? dict[];
    $this->map_string_foreign_message = $s['map_string_foreign_message'] ?? dict[];
    $this->map_string_nested_enum = $s['map_string_nested_enum'] ?? dict[];
    $this->map_string_foreign_enum = $s['map_string_foreign_enum'] ?? dict[];
    $this->data = $s['data'] ?? null;
    $this->default_int32 = $s['default_int32'] ?? -123456789;
    $this->default_int64 = $s['default_int64'] ?? -9123456789123456789;
    $this->default_uint32 = $s['default_uint32'] ?? 2123456789;
    $this->default_uint64 = $s['default_uint64'] ?? -8323287284586094827;
    $this->default_sint32 = $s['default_sint32'] ?? -123456789;
    $this->default_sint64 = $s['default_sint64'] ?? -9123456789123456789;
    $this->default_fixed32 = $s['default_fixed32'] ?? 2123456789;
    $this->default_fixed64 = $s['default_fixed64'] ?? -8323287284586094827;
    $this->default_sfixed32 = $s['default_sfixed32'] ?? -123456789;
    $this->default_sfixed64 = $s['default_sfixed64'] ?? -9123456789123456789;
    $this->default_float = $s['default_float'] ?? (float)9e+09;
    $this->default_double = $s['default_double'] ?? (float)7e+22;
    $this->default_bool = $s['default_bool'] ?? true;
    $this->default_string = $s['default_string'] ?? 'Rosebud';
    $this->default_bytes = $s['default_bytes'] ?? \stripcslashes('joshua');
    $this->fieldname1 = $s['fieldname1'] ?? 0;
    $this->field_name2 = $s['field_name2'] ?? 0;
    $this->_field_name3 = $s['_field_name3'] ?? 0;
    $this->field__name4_ = $s['field__name4_'] ?? 0;
    $this->field0name5 = $s['field0name5'] ?? 0;
    $this->field_0_name6 = $s['field_0_name6'] ?? 0;
    $this->fieldName7 = $s['fieldName7'] ?? 0;
    $this->FieldName8 = $s['FieldName8'] ?? 0;
    $this->field_Name9 = $s['field_Name9'] ?? 0;
    $this->Field_Name10 = $s['Field_Name10'] ?? 0;
    $this->FIELD_NAME11 = $s['FIELD_NAME11'] ?? 0;
    $this->FIELD_name12 = $s['FIELD_name12'] ?? 0;
    $this->__field_name13 = $s['__field_name13'] ?? 0;
    $this->__Field_name14 = $s['__Field_name14'] ?? 0;
    $this->field__name15 = $s['field__name15'] ?? 0;
    $this->field__Name16 = $s['field__Name16'] ?? 0;
    $this->field_name17__ = $s['field_name17__'] ?? 0;
    $this->Field_name18__ = $s['Field_name18__'] ?? 0;
    $this->oneof_field = $s['oneof_field'] ?? new TestAllTypesProto2_oneof_field_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.TestAllTypesProto2";
  }

  public static function ParseFrom(string $input): ?TestAllTypesProto2 {
    $msg = new TestAllTypesProto2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->optional_int32 = $d->readVarint32Signed();
          break;
        case 2:
          $this->optional_int64 = $d->readVarint();
          break;
        case 3:
          $this->optional_uint32 = $d->readVarint32();
          break;
        case 4:
          $this->optional_uint64 = $d->readVarint();
          break;
        case 5:
          $this->optional_sint32 = $d->readVarintZigZag32();
          break;
        case 6:
          $this->optional_sint64 = $d->readVarintZigZag64();
          break;
        case 7:
          $this->optional_fixed32 = $d->readLittleEndianInt32Unsigned();
          break;
        case 8:
          $this->optional_fixed64 = $d->readLittleEndianInt64();
          break;
        case 9:
          $this->optional_sfixed32 = $d->readLittleEndianInt32Signed();
          break;
        case 10:
          $this->optional_sfixed64 = $d->readLittleEndianInt64();
          break;
        case 11:
          $this->optional_float = $d->readFloat();
          break;
        case 12:
          $this->optional_double = $d->readDouble();
          break;
        case 13:
          $this->optional_bool = $d->readBool();
          break;
        case 14:
          $this->optional_string = $d->readString();
          break;
        case 15:
          $this->optional_bytes = $d->readString();
          break;
        case 18:
          if ($this->optional_nested_message == null) $this->optional_nested_message = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $this->optional_nested_message->MergeFrom($d->readDecoder());
          break;
        case 19:
          if ($this->optional_foreign_message == null) $this->optional_foreign_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->optional_foreign_message->MergeFrom($d->readDecoder());
          break;
        case 21:
          $this->optional_nested_enum = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          break;
        case 22:
          $this->optional_foreign_enum = \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($d->readVarint());
          break;
        case 24:
          $this->optional_string_piece = $d->readString();
          break;
        case 25:
          $this->optional_cord = $d->readString();
          break;
        case 27:
          if ($this->recursive_message == null) $this->recursive_message = new \protobuf_test_messages\proto2\TestAllTypesProto2();
          $this->recursive_message->MergeFrom($d->readDecoder());
          break;
        case 31:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->repeated_int32 []= $d->readVarint32Signed();
          }
          break;
        case 32:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int64 []= $packed->readVarint();
            }
          } else {
            $this->repeated_int64 []= $d->readVarint();
          }
          break;
        case 33:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->repeated_uint32 []= $d->readVarint32();
          }
          break;
        case 34:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_uint64 []= $packed->readVarint();
            }
          } else {
            $this->repeated_uint64 []= $d->readVarint();
          }
          break;
        case 35:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->repeated_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 36:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->repeated_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 37:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->repeated_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 38:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->repeated_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 39:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->repeated_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 40:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->repeated_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 41:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_float []= $packed->readFloat();
            }
          } else {
            $this->repeated_float []= $d->readFloat();
          }
          break;
        case 42:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_double []= $packed->readDouble();
            }
          } else {
            $this->repeated_double []= $d->readDouble();
          }
          break;
        case 43:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_bool []= $packed->readBool();
            }
          } else {
            $this->repeated_bool []= $d->readBool();
          }
          break;
        case 44:
          $this->repeated_string []= $d->readString();
          break;
        case 45:
          $this->repeated_bytes []= $d->readString();
          break;
        case 48:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_nested_message []= $obj;
          break;
        case 49:
          $obj = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $obj->MergeFrom($d->readDecoder());
          $this->repeated_foreign_message []= $obj;
          break;
        case 51:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->repeated_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 52:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_foreign_enum []= \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($packed->readVarint());
            }
          } else {
            $this->repeated_foreign_enum []= \protobuf_test_messages\proto2\ForeignEnumProto2::FromInt($d->readVarint());
          }
          break;
        case 54:
          $this->repeated_string_piece []= $d->readString();
          break;
        case 55:
          $this->repeated_cord []= $d->readString();
          break;
        case 56:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32Int32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_int32[$obj->key] = $obj->value;
          break;
        case 57:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt64Int64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int64_int64[$obj->key] = $obj->value;
          break;
        case 58:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint32Uint32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_uint32_uint32[$obj->key] = $obj->value;
          break;
        case 59:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint64Uint64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_uint64_uint64[$obj->key] = $obj->value;
          break;
        case 60:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint32Sint32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sint32_sint32[$obj->key] = $obj->value;
          break;
        case 61:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint64Sint64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sint64_sint64[$obj->key] = $obj->value;
          break;
        case 62:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed32Fixed32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_fixed32_fixed32[$obj->key] = $obj->value;
          break;
        case 63:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed64Fixed64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_fixed64_fixed64[$obj->key] = $obj->value;
          break;
        case 64:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed32Sfixed32Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sfixed32_sfixed32[$obj->key] = $obj->value;
          break;
        case 65:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed64Sfixed64Entry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_sfixed64_sfixed64[$obj->key] = $obj->value;
          break;
        case 66:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32FloatEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_float[$obj->key] = $obj->value;
          break;
        case 67:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32DoubleEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_int32_double[$obj->key] = $obj->value;
          break;
        case 68:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapBoolBoolEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_bool_bool[\Protobuf\BoolMapKey::FromBool($obj->key)] = $obj->value;
          break;
        case 69:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringStringEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_string[$obj->key] = $obj->value;
          break;
        case 70:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringBytesEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_bytes[$obj->key] = $obj->value;
          break;
        case 71:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedMessageEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_nested_message[$obj->key] = $obj->value ?? new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          break;
        case 72:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignMessageEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_foreign_message[$obj->key] = $obj->value ?? new \protobuf_test_messages\proto2\ForeignMessageProto2();
          break;
        case 73:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedEnumEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_nested_enum[$obj->key] = $obj->value;
          break;
        case 74:
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignEnumEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->map_string_foreign_enum[$obj->key] = $obj->value;
          break;
        case 75:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->packed_int32 []= $d->readVarint32Signed();
          }
          break;
        case 76:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_int64 []= $packed->readVarint();
            }
          } else {
            $this->packed_int64 []= $d->readVarint();
          }
          break;
        case 77:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->packed_uint32 []= $d->readVarint32();
          }
          break;
        case 78:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_uint64 []= $packed->readVarint();
            }
          } else {
            $this->packed_uint64 []= $d->readVarint();
          }
          break;
        case 79:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->packed_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 80:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->packed_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 81:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->packed_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 82:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->packed_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 83:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->packed_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 84:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->packed_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 85:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_float []= $packed->readFloat();
            }
          } else {
            $this->packed_float []= $d->readFloat();
          }
          break;
        case 86:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_double []= $packed->readDouble();
            }
          } else {
            $this->packed_double []= $d->readDouble();
          }
          break;
        case 87:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_bool []= $packed->readBool();
            }
          } else {
            $this->packed_bool []= $d->readBool();
          }
          break;
        case 88:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->packed_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->packed_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 89:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->unpacked_int32 []= $d->readVarint32Signed();
          }
          break;
        case 90:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_int64 []= $packed->readVarint();
            }
          } else {
            $this->unpacked_int64 []= $d->readVarint();
          }
          break;
        case 91:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_uint32 []= $packed->readVarint32();
            }
          } else {
            $this->unpacked_uint32 []= $d->readVarint32();
          }
          break;
        case 92:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_uint64 []= $packed->readVarint();
            }
          } else {
            $this->unpacked_uint64 []= $d->readVarint();
          }
          break;
        case 93:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sint32 []= $packed->readVarintZigZag32();
            }
          } else {
            $this->unpacked_sint32 []= $d->readVarintZigZag32();
          }
          break;
        case 94:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sint64 []= $packed->readVarintZigZag64();
            }
          } else {
            $this->unpacked_sint64 []= $d->readVarintZigZag64();
          }
          break;
        case 95:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_fixed32 []= $packed->readLittleEndianInt32Unsigned();
            }
          } else {
            $this->unpacked_fixed32 []= $d->readLittleEndianInt32Unsigned();
          }
          break;
        case 96:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_fixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->unpacked_fixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 97:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sfixed32 []= $packed->readLittleEndianInt32Signed();
            }
          } else {
            $this->unpacked_sfixed32 []= $d->readLittleEndianInt32Signed();
          }
          break;
        case 98:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_sfixed64 []= $packed->readLittleEndianInt64();
            }
          } else {
            $this->unpacked_sfixed64 []= $d->readLittleEndianInt64();
          }
          break;
        case 99:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_float []= $packed->readFloat();
            }
          } else {
            $this->unpacked_float []= $d->readFloat();
          }
          break;
        case 100:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_double []= $packed->readDouble();
            }
          } else {
            $this->unpacked_double []= $d->readDouble();
          }
          break;
        case 101:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_bool []= $packed->readBool();
            }
          } else {
            $this->unpacked_bool []= $d->readBool();
          }
          break;
        case 102:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->unpacked_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($packed->readVarint());
            }
          } else {
            $this->unpacked_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint());
          }
          break;
        case 111:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_uint32($d->readVarint32());
          break;
        case 112:
          if ($this->oneof_field->WhichOneof() == TestAllTypesProto2_oneof_field_oneof_t::oneof_nested_message) {
            ($this->oneof_field as TestAllTypesProto2_oneof_field_oneof_nested_message)->oneof_nested_message->MergeFrom($d->readDecoder());
          } else {
            $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
            $obj->MergeFrom($d->readDecoder());
            $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_nested_message($obj);
          }
          break;
        case 113:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_string($d->readString());
          break;
        case 114:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_bytes($d->readString());
          break;
        case 115:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_bool($d->readBool());
          break;
        case 116:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_uint64($d->readVarint());
          break;
        case 117:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_float($d->readFloat());
          break;
        case 118:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_double($d->readDouble());
          break;
        case 119:
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_enum(\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromInt($d->readVarint()));
          break;
        case 201:
          if ($this->data == null) $this->data = new \protobuf_test_messages\proto2\TestAllTypesProto2_Data();
          $this->data->MergeFrom($d->readDecoder());
          break;
        case 241:
          $this->default_int32 = $d->readVarint32Signed();
          break;
        case 242:
          $this->default_int64 = $d->readVarint();
          break;
        case 243:
          $this->default_uint32 = $d->readVarint32();
          break;
        case 244:
          $this->default_uint64 = $d->readVarint();
          break;
        case 245:
          $this->default_sint32 = $d->readVarintZigZag32();
          break;
        case 246:
          $this->default_sint64 = $d->readVarintZigZag64();
          break;
        case 247:
          $this->default_fixed32 = $d->readLittleEndianInt32Unsigned();
          break;
        case 248:
          $this->default_fixed64 = $d->readLittleEndianInt64();
          break;
        case 249:
          $this->default_sfixed32 = $d->readLittleEndianInt32Signed();
          break;
        case 250:
          $this->default_sfixed64 = $d->readLittleEndianInt64();
          break;
        case 251:
          $this->default_float = $d->readFloat();
          break;
        case 252:
          $this->default_double = $d->readDouble();
          break;
        case 253:
          $this->default_bool = $d->readBool();
          break;
        case 254:
          $this->default_string = $d->readString();
          break;
        case 255:
          $this->default_bytes = $d->readString();
          break;
        case 401:
          $this->fieldname1 = $d->readVarint32Signed();
          break;
        case 402:
          $this->field_name2 = $d->readVarint32Signed();
          break;
        case 403:
          $this->_field_name3 = $d->readVarint32Signed();
          break;
        case 404:
          $this->field__name4_ = $d->readVarint32Signed();
          break;
        case 405:
          $this->field0name5 = $d->readVarint32Signed();
          break;
        case 406:
          $this->field_0_name6 = $d->readVarint32Signed();
          break;
        case 407:
          $this->fieldName7 = $d->readVarint32Signed();
          break;
        case 408:
          $this->FieldName8 = $d->readVarint32Signed();
          break;
        case 409:
          $this->field_Name9 = $d->readVarint32Signed();
          break;
        case 410:
          $this->Field_Name10 = $d->readVarint32Signed();
          break;
        case 411:
          $this->FIELD_NAME11 = $d->readVarint32Signed();
          break;
        case 412:
          $this->FIELD_name12 = $d->readVarint32Signed();
          break;
        case 413:
          $this->__field_name13 = $d->readVarint32Signed();
          break;
        case 414:
          $this->__Field_name14 = $d->readVarint32Signed();
          break;
        case 415:
          $this->field__name15 = $d->readVarint32Signed();
          break;
        case 416:
          $this->field__Name16 = $d->readVarint32Signed();
          break;
        case 417:
          $this->field_name17__ = $d->readVarint32Signed();
          break;
        case 418:
          $this->Field_name18__ = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->optional_int32 !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->optional_int32);
    }
    if ($this->optional_int64 !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->optional_int64);
    }
    if ($this->optional_uint32 !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->optional_uint32);
    }
    if ($this->optional_uint64 !== 0) {
      $e->writeTag(4, 0);
      $e->writeVarint($this->optional_uint64);
    }
    if ($this->optional_sint32 !== 0) {
      $e->writeTag(5, 0);
      $e->writeVarintZigZag32($this->optional_sint32);
    }
    if ($this->optional_sint64 !== 0) {
      $e->writeTag(6, 0);
      $e->writeVarintZigZag64($this->optional_sint64);
    }
    if ($this->optional_fixed32 !== 0) {
      $e->writeTag(7, 5);
      $e->writeLittleEndianInt32Unsigned($this->optional_fixed32);
    }
    if ($this->optional_fixed64 !== 0) {
      $e->writeTag(8, 1);
      $e->writeLittleEndianInt64($this->optional_fixed64);
    }
    if ($this->optional_sfixed32 !== 0) {
      $e->writeTag(9, 5);
      $e->writeLittleEndianInt32Signed($this->optional_sfixed32);
    }
    if ($this->optional_sfixed64 !== 0) {
      $e->writeTag(10, 1);
      $e->writeLittleEndianInt64($this->optional_sfixed64);
    }
    if ($this->optional_float !== 0.0) {
      $e->writeTag(11, 5);
      $e->writeFloat($this->optional_float);
    }
    if ($this->optional_double !== 0.0) {
      $e->writeTag(12, 1);
      $e->writeDouble($this->optional_double);
    }
    if ($this->optional_bool !== false) {
      $e->writeTag(13, 0);
      $e->writeBool($this->optional_bool);
    }
    if ($this->optional_string !== '') {
      $e->writeTag(14, 2);
      $e->writeString($this->optional_string);
    }
    if ($this->optional_bytes !== '') {
      $e->writeTag(15, 2);
      $e->writeString($this->optional_bytes);
    }
    $msg = $this->optional_nested_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 18);
    }
    $msg = $this->optional_foreign_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 19);
    }
    if ($this->optional_nested_enum !== \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FOO) {
      $e->writeTag(21, 0);
      $e->writeVarint($this->optional_nested_enum);
    }
    if ($this->optional_foreign_enum !== \protobuf_test_messages\proto2\ForeignEnumProto2::FOREIGN_FOO) {
      $e->writeTag(22, 0);
      $e->writeVarint($this->optional_foreign_enum);
    }
    if ($this->optional_string_piece !== '') {
      $e->writeTag(24, 2);
      $e->writeString($this->optional_string_piece);
    }
    if ($this->optional_cord !== '') {
      $e->writeTag(25, 2);
      $e->writeString($this->optional_cord);
    }
    $msg = $this->recursive_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 27);
    }
    foreach ($this->repeated_int32 as $elem) {
      $e->writeTag(31, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_int64 as $elem) {
      $e->writeTag(32, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_uint32 as $elem) {
      $e->writeTag(33, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_uint64 as $elem) {
      $e->writeTag(34, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_sint32 as $elem) {
      $e->writeTag(35, 0);
      $e->writeVarintZigZag32($elem);
    }
    foreach ($this->repeated_sint64 as $elem) {
      $e->writeTag(36, 0);
      $e->writeVarintZigZag64($elem);
    }
    foreach ($this->repeated_fixed32 as $elem) {
      $e->writeTag(37, 5);
      $e->writeLittleEndianInt32Unsigned($elem);
    }
    foreach ($this->repeated_fixed64 as $elem) {
      $e->writeTag(38, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->repeated_sfixed32 as $elem) {
      $e->writeTag(39, 5);
      $e->writeLittleEndianInt32Signed($elem);
    }
    foreach ($this->repeated_sfixed64 as $elem) {
      $e->writeTag(40, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->repeated_float as $elem) {
      $e->writeTag(41, 5);
      $e->writeFloat($elem);
    }
    foreach ($this->repeated_double as $elem) {
      $e->writeTag(42, 1);
      $e->writeDouble($elem);
    }
    foreach ($this->repeated_bool as $elem) {
      $e->writeTag(43, 0);
      $e->writeBool($elem);
    }
    foreach ($this->repeated_string as $elem) {
      $e->writeTag(44, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_bytes as $elem) {
      $e->writeTag(45, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_nested_message as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 48);
    }
    foreach ($this->repeated_foreign_message as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 49);
    }
    foreach ($this->repeated_nested_enum as $elem) {
      $e->writeTag(51, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_foreign_enum as $elem) {
      $e->writeTag(52, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->repeated_string_piece as $elem) {
      $e->writeTag(54, 2);
      $e->writeString($elem);
    }
    foreach ($this->repeated_cord as $elem) {
      $e->writeTag(55, 2);
      $e->writeString($elem);
    }
    foreach ($this->map_int32_int32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32Int32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 56);
    }
    foreach ($this->map_int64_int64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt64Int64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 57);
    }
    foreach ($this->map_uint32_uint32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint32Uint32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 58);
    }
    foreach ($this->map_uint64_uint64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapUint64Uint64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 59);
    }
    foreach ($this->map_sint32_sint32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint32Sint32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 60);
    }
    foreach ($this->map_sint64_sint64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSint64Sint64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 61);
    }
    foreach ($this->map_fixed32_fixed32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed32Fixed32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 62);
    }
    foreach ($this->map_fixed64_fixed64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapFixed64Fixed64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 63);
    }
    foreach ($this->map_sfixed32_sfixed32 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed32Sfixed32Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 64);
    }
    foreach ($this->map_sfixed64_sfixed64 as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapSfixed64Sfixed64Entry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 65);
    }
    foreach ($this->map_int32_float as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32FloatEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 66);
    }
    foreach ($this->map_int32_double as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapInt32DoubleEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 67);
    }
    foreach ($this->map_bool_bool as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapBoolBoolEntry();
      $obj->key = \Protobuf\BoolMapKey::ToBool($k);
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 68);
    }
    foreach ($this->map_string_string as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringStringEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 69);
    }
    foreach ($this->map_string_bytes as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringBytesEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 70);
    }
    foreach ($this->map_string_nested_message as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedMessageEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 71);
    }
    foreach ($this->map_string_foreign_message as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignMessageEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 72);
    }
    foreach ($this->map_string_nested_enum as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringNestedEnumEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 73);
    }
    foreach ($this->map_string_foreign_enum as $k => $v) {
      $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_MapStringForeignEnumEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 74);
    }
    if (\count($this->packed_int32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_int32 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 75);
    }
    if (\count($this->packed_int64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_int64 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 76);
    }
    if (\count($this->packed_uint32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_uint32 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 77);
    }
    if (\count($this->packed_uint64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_uint64 as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 78);
    }
    if (\count($this->packed_sint32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sint32 as $elem) {
        $packed->writeVarintZigZag32($elem);
      }
      $e->writeEncoder($packed, 79);
    }
    if (\count($this->packed_sint64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sint64 as $elem) {
        $packed->writeVarintZigZag64($elem);
      }
      $e->writeEncoder($packed, 80);
    }
    if (\count($this->packed_fixed32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_fixed32 as $elem) {
        $packed->writeLittleEndianInt32Unsigned($elem);
      }
      $e->writeEncoder($packed, 81);
    }
    if (\count($this->packed_fixed64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_fixed64 as $elem) {
        $packed->writeLittleEndianInt64($elem);
      }
      $e->writeEncoder($packed, 82);
    }
    if (\count($this->packed_sfixed32) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sfixed32 as $elem) {
        $packed->writeLittleEndianInt32Signed($elem);
      }
      $e->writeEncoder($packed, 83);
    }
    if (\count($this->packed_sfixed64) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_sfixed64 as $elem) {
        $packed->writeLittleEndianInt64($elem);
      }
      $e->writeEncoder($packed, 84);
    }
    if (\count($this->packed_float) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_float as $elem) {
        $packed->writeFloat($elem);
      }
      $e->writeEncoder($packed, 85);
    }
    if (\count($this->packed_double) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_double as $elem) {
        $packed->writeDouble($elem);
      }
      $e->writeEncoder($packed, 86);
    }
    if (\count($this->packed_bool) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_bool as $elem) {
        $packed->writeBool($elem);
      }
      $e->writeEncoder($packed, 87);
    }
    if (\count($this->packed_nested_enum) > 0) {
      $packed = new \Protobuf\Internal\Encoder();
      foreach ($this->packed_nested_enum as $elem) {
        $packed->writeVarint($elem);
      }
      $e->writeEncoder($packed, 88);
    }
    foreach ($this->unpacked_int32 as $elem) {
      $e->writeTag(89, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_int64 as $elem) {
      $e->writeTag(90, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_uint32 as $elem) {
      $e->writeTag(91, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_uint64 as $elem) {
      $e->writeTag(92, 0);
      $e->writeVarint($elem);
    }
    foreach ($this->unpacked_sint32 as $elem) {
      $e->writeTag(93, 0);
      $e->writeVarintZigZag32($elem);
    }
    foreach ($this->unpacked_sint64 as $elem) {
      $e->writeTag(94, 0);
      $e->writeVarintZigZag64($elem);
    }
    foreach ($this->unpacked_fixed32 as $elem) {
      $e->writeTag(95, 5);
      $e->writeLittleEndianInt32Unsigned($elem);
    }
    foreach ($this->unpacked_fixed64 as $elem) {
      $e->writeTag(96, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->unpacked_sfixed32 as $elem) {
      $e->writeTag(97, 5);
      $e->writeLittleEndianInt32Signed($elem);
    }
    foreach ($this->unpacked_sfixed64 as $elem) {
      $e->writeTag(98, 1);
      $e->writeLittleEndianInt64($elem);
    }
    foreach ($this->unpacked_float as $elem) {
      $e->writeTag(99, 5);
      $e->writeFloat($elem);
    }
    foreach ($this->unpacked_double as $elem) {
      $e->writeTag(100, 1);
      $e->writeDouble($elem);
    }
    foreach ($this->unpacked_bool as $elem) {
      $e->writeTag(101, 0);
      $e->writeBool($elem);
    }
    foreach ($this->unpacked_nested_enum as $elem) {
      $e->writeTag(102, 0);
      $e->writeVarint($elem);
    }
    $msg = $this->data;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 201);
    }
    if ($this->default_int32 !== -123456789) {
      $e->writeTag(241, 0);
      $e->writeVarint($this->default_int32);
    }
    if ($this->default_int64 !== -9123456789123456789) {
      $e->writeTag(242, 0);
      $e->writeVarint($this->default_int64);
    }
    if ($this->default_uint32 !== 2123456789) {
      $e->writeTag(243, 0);
      $e->writeVarint($this->default_uint32);
    }
    if ($this->default_uint64 !== -8323287284586094827) {
      $e->writeTag(244, 0);
      $e->writeVarint($this->default_uint64);
    }
    if ($this->default_sint32 !== -123456789) {
      $e->writeTag(245, 0);
      $e->writeVarintZigZag32($this->default_sint32);
    }
    if ($this->default_sint64 !== -9123456789123456789) {
      $e->writeTag(246, 0);
      $e->writeVarintZigZag64($this->default_sint64);
    }
    if ($this->default_fixed32 !== 2123456789) {
      $e->writeTag(247, 5);
      $e->writeLittleEndianInt32Unsigned($this->default_fixed32);
    }
    if ($this->default_fixed64 !== -8323287284586094827) {
      $e->writeTag(248, 1);
      $e->writeLittleEndianInt64($this->default_fixed64);
    }
    if ($this->default_sfixed32 !== -123456789) {
      $e->writeTag(249, 5);
      $e->writeLittleEndianInt32Signed($this->default_sfixed32);
    }
    if ($this->default_sfixed64 !== -9123456789123456789) {
      $e->writeTag(250, 1);
      $e->writeLittleEndianInt64($this->default_sfixed64);
    }
    if ($this->default_float !== (float)9e+09) {
      $e->writeTag(251, 5);
      $e->writeFloat($this->default_float);
    }
    if ($this->default_double !== (float)7e+22) {
      $e->writeTag(252, 1);
      $e->writeDouble($this->default_double);
    }
    if ($this->default_bool !== true) {
      $e->writeTag(253, 0);
      $e->writeBool($this->default_bool);
    }
    if ($this->default_string !== 'Rosebud') {
      $e->writeTag(254, 2);
      $e->writeString($this->default_string);
    }
    if ($this->default_bytes !== \stripcslashes('joshua')) {
      $e->writeTag(255, 2);
      $e->writeString($this->default_bytes);
    }
    if ($this->fieldname1 !== 0) {
      $e->writeTag(401, 0);
      $e->writeVarint($this->fieldname1);
    }
    if ($this->field_name2 !== 0) {
      $e->writeTag(402, 0);
      $e->writeVarint($this->field_name2);
    }
    if ($this->_field_name3 !== 0) {
      $e->writeTag(403, 0);
      $e->writeVarint($this->_field_name3);
    }
    if ($this->field__name4_ !== 0) {
      $e->writeTag(404, 0);
      $e->writeVarint($this->field__name4_);
    }
    if ($this->field0name5 !== 0) {
      $e->writeTag(405, 0);
      $e->writeVarint($this->field0name5);
    }
    if ($this->field_0_name6 !== 0) {
      $e->writeTag(406, 0);
      $e->writeVarint($this->field_0_name6);
    }
    if ($this->fieldName7 !== 0) {
      $e->writeTag(407, 0);
      $e->writeVarint($this->fieldName7);
    }
    if ($this->FieldName8 !== 0) {
      $e->writeTag(408, 0);
      $e->writeVarint($this->FieldName8);
    }
    if ($this->field_Name9 !== 0) {
      $e->writeTag(409, 0);
      $e->writeVarint($this->field_Name9);
    }
    if ($this->Field_Name10 !== 0) {
      $e->writeTag(410, 0);
      $e->writeVarint($this->Field_Name10);
    }
    if ($this->FIELD_NAME11 !== 0) {
      $e->writeTag(411, 0);
      $e->writeVarint($this->FIELD_NAME11);
    }
    if ($this->FIELD_name12 !== 0) {
      $e->writeTag(412, 0);
      $e->writeVarint($this->FIELD_name12);
    }
    if ($this->__field_name13 !== 0) {
      $e->writeTag(413, 0);
      $e->writeVarint($this->__field_name13);
    }
    if ($this->__Field_name14 !== 0) {
      $e->writeTag(414, 0);
      $e->writeVarint($this->__Field_name14);
    }
    if ($this->field__name15 !== 0) {
      $e->writeTag(415, 0);
      $e->writeVarint($this->field__name15);
    }
    if ($this->field__Name16 !== 0) {
      $e->writeTag(416, 0);
      $e->writeVarint($this->field__Name16);
    }
    if ($this->field_name17__ !== 0) {
      $e->writeTag(417, 0);
      $e->writeVarint($this->field_name17__);
    }
    if ($this->Field_name18__ !== 0) {
      $e->writeTag(418, 0);
      $e->writeVarint($this->Field_name18__);
    }
    $this->oneof_field->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('optional_int32', 'optionalInt32', $this->optional_int32, false);
    $e->writeInt64Signed('optional_int64', 'optionalInt64', $this->optional_int64, false);
    $e->writeInt32('optional_uint32', 'optionalUint32', $this->optional_uint32, false);
    $e->writeInt64Unsigned('optional_uint64', 'optionalUint64', $this->optional_uint64, false);
    $e->writeInt32('optional_sint32', 'optionalSint32', $this->optional_sint32, false);
    $e->writeInt64Signed('optional_sint64', 'optionalSint64', $this->optional_sint64, false);
    $e->writeInt32('optional_fixed32', 'optionalFixed32', $this->optional_fixed32, false);
    $e->writeInt64Unsigned('optional_fixed64', 'optionalFixed64', $this->optional_fixed64, false);
    $e->writeInt32('optional_sfixed32', 'optionalSfixed32', $this->optional_sfixed32, false);
    $e->writeInt64Signed('optional_sfixed64', 'optionalSfixed64', $this->optional_sfixed64, false);
    $e->writeFloat('optional_float', 'optionalFloat', $this->optional_float, false);
    $e->writeFloat('optional_double', 'optionalDouble', $this->optional_double, false);
    $e->writeBool('optional_bool', 'optionalBool', $this->optional_bool, false);
    $e->writeString('optional_string', 'optionalString', $this->optional_string, false);
    $e->writeBytes('optional_bytes', 'optionalBytes', $this->optional_bytes, false);
    $e->writeMessage('optional_nested_message', 'optionalNestedMessage', $this->optional_nested_message, false);
    $e->writeMessage('optional_foreign_message', 'optionalForeignMessage', $this->optional_foreign_message, false);
    $e->writeEnum('optional_nested_enum', 'optionalNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->optional_nested_enum, false);
    $e->writeEnum('optional_foreign_enum', 'optionalForeignEnum', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->optional_foreign_enum, false);
    $e->writeString('optional_string_piece', 'optionalStringPiece', $this->optional_string_piece, false);
    $e->writeString('optional_cord', 'optionalCord', $this->optional_cord, false);
    $e->writeMessage('recursive_message', 'recursiveMessage', $this->recursive_message, false);
    $e->writePrimitiveList('repeated_int32', 'repeatedInt32', $this->repeated_int32);
    $e->writeInt64SignedList('repeated_int64', 'repeatedInt64', $this->repeated_int64);
    $e->writePrimitiveList('repeated_uint32', 'repeatedUint32', $this->repeated_uint32);
    $e->writeInt64UnsignedList('repeated_uint64', 'repeatedUint64', $this->repeated_uint64);
    $e->writePrimitiveList('repeated_sint32', 'repeatedSint32', $this->repeated_sint32);
    $e->writeInt64SignedList('repeated_sint64', 'repeatedSint64', $this->repeated_sint64);
    $e->writePrimitiveList('repeated_fixed32', 'repeatedFixed32', $this->repeated_fixed32);
    $e->writeInt64UnsignedList('repeated_fixed64', 'repeatedFixed64', $this->repeated_fixed64);
    $e->writePrimitiveList('repeated_sfixed32', 'repeatedSfixed32', $this->repeated_sfixed32);
    $e->writeInt64SignedList('repeated_sfixed64', 'repeatedSfixed64', $this->repeated_sfixed64);
    $e->writeFloatList('repeated_float', 'repeatedFloat', $this->repeated_float);
    $e->writeFloatList('repeated_double', 'repeatedDouble', $this->repeated_double);
    $e->writePrimitiveList('repeated_bool', 'repeatedBool', $this->repeated_bool);
    $e->writePrimitiveList('repeated_string', 'repeatedString', $this->repeated_string);
    $e->writeBytesList('repeated_bytes', 'repeatedBytes', $this->repeated_bytes);
    $e->writeMessageList('repeated_nested_message', 'repeatedNestedMessage', $this->repeated_nested_message);
    $e->writeMessageList('repeated_foreign_message', 'repeatedForeignMessage', $this->repeated_foreign_message);
    $e->writeEnumList('repeated_nested_enum', 'repeatedNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->repeated_nested_enum);
    $e->writeEnumList('repeated_foreign_enum', 'repeatedForeignEnum', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->repeated_foreign_enum);
    $e->writePrimitiveList('repeated_string_piece', 'repeatedStringPiece', $this->repeated_string_piece);
    $e->writePrimitiveList('repeated_cord', 'repeatedCord', $this->repeated_cord);
    $e->writePrimitiveMap('map_int32_int32', 'mapInt32Int32', $this->map_int32_int32);
    $e->writeInt64SignedMap('map_int64_int64', 'mapInt64Int64', $this->map_int64_int64);
    $e->writePrimitiveMap('map_uint32_uint32', 'mapUint32Uint32', $this->map_uint32_uint32);
    $e->writeInt64UnsignedMap('map_uint64_uint64', 'mapUint64Uint64', $this->map_uint64_uint64);
    $e->writePrimitiveMap('map_sint32_sint32', 'mapSint32Sint32', $this->map_sint32_sint32);
    $e->writeInt64SignedMap('map_sint64_sint64', 'mapSint64Sint64', $this->map_sint64_sint64);
    $e->writePrimitiveMap('map_fixed32_fixed32', 'mapFixed32Fixed32', $this->map_fixed32_fixed32);
    $e->writeInt64UnsignedMap('map_fixed64_fixed64', 'mapFixed64Fixed64', $this->map_fixed64_fixed64);
    $e->writePrimitiveMap('map_sfixed32_sfixed32', 'mapSfixed32Sfixed32', $this->map_sfixed32_sfixed32);
    $e->writeInt64SignedMap('map_sfixed64_sfixed64', 'mapSfixed64Sfixed64', $this->map_sfixed64_sfixed64);
    $e->writeFloatMap('map_int32_float', 'mapInt32Float', $this->map_int32_float);
    $e->writeFloatMap('map_int32_double', 'mapInt32Double', $this->map_int32_double);
    $e->writePrimitiveMap('map_bool_bool', 'mapBoolBool', $this->map_bool_bool);
    $e->writePrimitiveMap('map_string_string', 'mapStringString', $this->map_string_string);
    $e->writeBytesMap('map_string_bytes', 'mapStringBytes', $this->map_string_bytes);
    $e->writeMessageMap('map_string_nested_message', 'mapStringNestedMessage', $this->map_string_nested_message);
    $e->writeMessageMap('map_string_foreign_message', 'mapStringForeignMessage', $this->map_string_foreign_message);
    $e->writeEnumMap('map_string_nested_enum', 'mapStringNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->map_string_nested_enum);
    $e->writeEnumMap('map_string_foreign_enum', 'mapStringForeignEnum', \protobuf_test_messages\proto2\ForeignEnumProto2::ToStringDict(), $this->map_string_foreign_enum);
    $e->writePrimitiveList('packed_int32', 'packedInt32', $this->packed_int32);
    $e->writeInt64SignedList('packed_int64', 'packedInt64', $this->packed_int64);
    $e->writePrimitiveList('packed_uint32', 'packedUint32', $this->packed_uint32);
    $e->writeInt64UnsignedList('packed_uint64', 'packedUint64', $this->packed_uint64);
    $e->writePrimitiveList('packed_sint32', 'packedSint32', $this->packed_sint32);
    $e->writeInt64SignedList('packed_sint64', 'packedSint64', $this->packed_sint64);
    $e->writePrimitiveList('packed_fixed32', 'packedFixed32', $this->packed_fixed32);
    $e->writeInt64UnsignedList('packed_fixed64', 'packedFixed64', $this->packed_fixed64);
    $e->writePrimitiveList('packed_sfixed32', 'packedSfixed32', $this->packed_sfixed32);
    $e->writeInt64SignedList('packed_sfixed64', 'packedSfixed64', $this->packed_sfixed64);
    $e->writeFloatList('packed_float', 'packedFloat', $this->packed_float);
    $e->writeFloatList('packed_double', 'packedDouble', $this->packed_double);
    $e->writePrimitiveList('packed_bool', 'packedBool', $this->packed_bool);
    $e->writeEnumList('packed_nested_enum', 'packedNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->packed_nested_enum);
    $e->writePrimitiveList('unpacked_int32', 'unpackedInt32', $this->unpacked_int32);
    $e->writeInt64SignedList('unpacked_int64', 'unpackedInt64', $this->unpacked_int64);
    $e->writePrimitiveList('unpacked_uint32', 'unpackedUint32', $this->unpacked_uint32);
    $e->writeInt64UnsignedList('unpacked_uint64', 'unpackedUint64', $this->unpacked_uint64);
    $e->writePrimitiveList('unpacked_sint32', 'unpackedSint32', $this->unpacked_sint32);
    $e->writeInt64SignedList('unpacked_sint64', 'unpackedSint64', $this->unpacked_sint64);
    $e->writePrimitiveList('unpacked_fixed32', 'unpackedFixed32', $this->unpacked_fixed32);
    $e->writeInt64UnsignedList('unpacked_fixed64', 'unpackedFixed64', $this->unpacked_fixed64);
    $e->writePrimitiveList('unpacked_sfixed32', 'unpackedSfixed32', $this->unpacked_sfixed32);
    $e->writeInt64SignedList('unpacked_sfixed64', 'unpackedSfixed64', $this->unpacked_sfixed64);
    $e->writeFloatList('unpacked_float', 'unpackedFloat', $this->unpacked_float);
    $e->writeFloatList('unpacked_double', 'unpackedDouble', $this->unpacked_double);
    $e->writePrimitiveList('unpacked_bool', 'unpackedBool', $this->unpacked_bool);
    $e->writeEnumList('unpacked_nested_enum', 'unpackedNestedEnum', \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::ToStringDict(), $this->unpacked_nested_enum);
    $e->writeMessage('data', 'data', $this->data, false);
    $e->writeInt32('default_int32', 'defaultInt32', $this->default_int32, false);
    $e->writeInt64Signed('default_int64', 'defaultInt64', $this->default_int64, false);
    $e->writeInt32('default_uint32', 'defaultUint32', $this->default_uint32, false);
    $e->writeInt64Unsigned('default_uint64', 'defaultUint64', $this->default_uint64, false);
    $e->writeInt32('default_sint32', 'defaultSint32', $this->default_sint32, false);
    $e->writeInt64Signed('default_sint64', 'defaultSint64', $this->default_sint64, false);
    $e->writeInt32('default_fixed32', 'defaultFixed32', $this->default_fixed32, false);
    $e->writeInt64Unsigned('default_fixed64', 'defaultFixed64', $this->default_fixed64, false);
    $e->writeInt32('default_sfixed32', 'defaultSfixed32', $this->default_sfixed32, false);
    $e->writeInt64Signed('default_sfixed64', 'defaultSfixed64', $this->default_sfixed64, false);
    $e->writeFloat('default_float', 'defaultFloat', $this->default_float, false);
    $e->writeFloat('default_double', 'defaultDouble', $this->default_double, false);
    $e->writeBool('default_bool', 'defaultBool', $this->default_bool, false);
    $e->writeString('default_string', 'defaultString', $this->default_string, false);
    $e->writeBytes('default_bytes', 'defaultBytes', $this->default_bytes, false);
    $e->writeInt32('fieldname1', 'fieldname1', $this->fieldname1, false);
    $e->writeInt32('field_name2', 'fieldName2', $this->field_name2, false);
    $e->writeInt32('_field_name3', 'FieldName3', $this->_field_name3, false);
    $e->writeInt32('field__name4_', 'fieldName4', $this->field__name4_, false);
    $e->writeInt32('field0name5', 'field0name5', $this->field0name5, false);
    $e->writeInt32('field_0_name6', 'field0Name6', $this->field_0_name6, false);
    $e->writeInt32('fieldName7', 'fieldName7', $this->fieldName7, false);
    $e->writeInt32('FieldName8', 'FieldName8', $this->FieldName8, false);
    $e->writeInt32('field_Name9', 'fieldName9', $this->field_Name9, false);
    $e->writeInt32('Field_Name10', 'FieldName10', $this->Field_Name10, false);
    $e->writeInt32('FIELD_NAME11', 'FIELDNAME11', $this->FIELD_NAME11, false);
    $e->writeInt32('FIELD_name12', 'FIELDName12', $this->FIELD_name12, false);
    $e->writeInt32('__field_name13', 'FieldName13', $this->__field_name13, false);
    $e->writeInt32('__Field_name14', 'FieldName14', $this->__Field_name14, false);
    $e->writeInt32('field__name15', 'fieldName15', $this->field__name15, false);
    $e->writeInt32('field__Name16', 'fieldName16', $this->field__Name16, false);
    $e->writeInt32('field_name17__', 'fieldName17', $this->field_name17__, false);
    $e->writeInt32('Field_name18__', 'FieldName18', $this->Field_name18__, false);
    $this->oneof_field->WriteJsonTo($e);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'optional_int32': case 'optionalInt32':
          $this->optional_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_int64': case 'optionalInt64':
          $this->optional_int64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_uint32': case 'optionalUint32':
          $this->optional_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        case 'optional_uint64': case 'optionalUint64':
          $this->optional_uint64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'optional_sint32': case 'optionalSint32':
          $this->optional_sint32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_sint64': case 'optionalSint64':
          $this->optional_sint64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_fixed32': case 'optionalFixed32':
          $this->optional_fixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_fixed64': case 'optionalFixed64':
          $this->optional_fixed64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'optional_sfixed32': case 'optionalSfixed32':
          $this->optional_sfixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_sfixed64': case 'optionalSfixed64':
          $this->optional_sfixed64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'optional_float': case 'optionalFloat':
          $this->optional_float = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'optional_double': case 'optionalDouble':
          $this->optional_double = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'optional_bool': case 'optionalBool':
          $this->optional_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'optional_string': case 'optionalString':
          $this->optional_string = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'optional_bytes': case 'optionalBytes':
          $this->optional_bytes = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        case 'optional_nested_message': case 'optionalNestedMessage':
          if ($v === null) break;
          if ($this->optional_nested_message == null) $this->optional_nested_message = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $this->optional_nested_message->MergeJsonFrom($v);
          break;
        case 'optional_foreign_message': case 'optionalForeignMessage':
          if ($v === null) break;
          if ($this->optional_foreign_message == null) $this->optional_foreign_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->optional_foreign_message->MergeJsonFrom($v);
          break;
        case 'optional_nested_enum': case 'optionalNestedEnum':
          $this->optional_nested_enum = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v);
          break;
        case 'optional_foreign_enum': case 'optionalForeignEnum':
          $this->optional_foreign_enum = \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($v);
          break;
        case 'optional_string_piece': case 'optionalStringPiece':
          $this->optional_string_piece = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'optional_cord': case 'optionalCord':
          $this->optional_cord = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'recursive_message': case 'recursiveMessage':
          if ($v === null) break;
          if ($this->recursive_message == null) $this->recursive_message = new \protobuf_test_messages\proto2\TestAllTypesProto2();
          $this->recursive_message->MergeJsonFrom($v);
          break;
        case 'repeated_int32': case 'repeatedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_int64': case 'repeatedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_uint32': case 'repeatedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'repeated_uint64': case 'repeatedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'repeated_sint32': case 'repeatedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_sint64': case 'repeatedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_fixed32': case 'repeatedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_fixed64': case 'repeatedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'repeated_sfixed32': case 'repeatedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'repeated_sfixed64': case 'repeatedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'repeated_float': case 'repeatedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'repeated_double': case 'repeatedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'repeated_bool': case 'repeatedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'repeated_string': case 'repeatedString':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_string []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'repeated_bytes': case 'repeatedBytes':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_bytes []= \Protobuf\Internal\JsonDecoder::readBytes($vv);
          }
          break;
        case 'repeated_nested_message': case 'repeatedNestedMessage':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
            $obj->MergeJsonFrom($vv);
            $this->repeated_nested_message []= $obj;
          }
          break;
        case 'repeated_foreign_message': case 'repeatedForeignMessage':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \protobuf_test_messages\proto2\ForeignMessageProto2();
            $obj->MergeJsonFrom($vv);
            $this->repeated_foreign_message []= $obj;
          }
          break;
        case 'repeated_nested_enum': case 'repeatedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($vv);
          }
          break;
        case 'repeated_foreign_enum': case 'repeatedForeignEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_foreign_enum []= \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($vv);
          }
          break;
        case 'repeated_string_piece': case 'repeatedStringPiece':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_string_piece []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'repeated_cord': case 'repeatedCord':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_cord []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'map_int32_int32': case 'mapInt32Int32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_int32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_int64_int64': case 'mapInt64Int64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int64_int64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_uint32_uint32': case 'mapUint32Uint32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_uint32_uint32[\Protobuf\Internal\JsonDecoder::readInt32Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
            }
          }
          break;
        case 'map_uint64_uint64': case 'mapUint64Uint64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_uint64_uint64[\Protobuf\Internal\JsonDecoder::readInt64Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
            }
          }
          break;
        case 'map_sint32_sint32': case 'mapSint32Sint32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sint32_sint32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_sint64_sint64': case 'mapSint64Sint64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sint64_sint64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_fixed32_fixed32': case 'mapFixed32Fixed32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_fixed32_fixed32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_fixed64_fixed64': case 'mapFixed64Fixed64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_fixed64_fixed64[\Protobuf\Internal\JsonDecoder::readInt64Unsigned($k)] = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
            }
          }
          break;
        case 'map_sfixed32_sfixed32': case 'mapSfixed32Sfixed32':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sfixed32_sfixed32[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
            }
          }
          break;
        case 'map_sfixed64_sfixed64': case 'mapSfixed64Sfixed64':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_sfixed64_sfixed64[\Protobuf\Internal\JsonDecoder::readInt64Signed($k)] = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
            }
          }
          break;
        case 'map_int32_float': case 'mapInt32Float':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_float[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readFloat($v);
            }
          }
          break;
        case 'map_int32_double': case 'mapInt32Double':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_int32_double[\Protobuf\Internal\JsonDecoder::readInt32Signed($k)] = \Protobuf\Internal\JsonDecoder::readFloat($v);
            }
          }
          break;
        case 'map_bool_bool': case 'mapBoolBool':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_bool_bool[\Protobuf\Internal\JsonDecoder::readBoolMapKey($k)] = \Protobuf\Internal\JsonDecoder::readBool($v);
            }
          }
          break;
        case 'map_string_string': case 'mapStringString':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_string[\Protobuf\Internal\JsonDecoder::readString($k)] = \Protobuf\Internal\JsonDecoder::readString($v);
            }
          }
          break;
        case 'map_string_bytes': case 'mapStringBytes':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_bytes[\Protobuf\Internal\JsonDecoder::readString($k)] = \Protobuf\Internal\JsonDecoder::readBytes($v);
            }
          }
          break;
        case 'map_string_nested_message': case 'mapStringNestedMessage':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
              $obj->MergeJsonFrom($v);
              $this->map_string_nested_message[\Protobuf\Internal\JsonDecoder::readString($k)] = $obj;
            }
          }
          break;
        case 'map_string_foreign_message': case 'mapStringForeignMessage':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $obj = new \protobuf_test_messages\proto2\ForeignMessageProto2();
              $obj->MergeJsonFrom($v);
              $this->map_string_foreign_message[\Protobuf\Internal\JsonDecoder::readString($k)] = $obj;
            }
          }
          break;
        case 'map_string_nested_enum': case 'mapStringNestedEnum':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_nested_enum[\Protobuf\Internal\JsonDecoder::readString($k)] = \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v);
            }
          }
          break;
        case 'map_string_foreign_enum': case 'mapStringForeignEnum':
          if ($v !== null) {
            foreach (\Protobuf\Internal\JsonDecoder::readObject($v) as $k => $v) {
              $this->map_string_foreign_enum[\Protobuf\Internal\JsonDecoder::readString($k)] = \protobuf_test_messages\proto2\ForeignEnumProto2::FromMixed($v);
            }
          }
          break;
        case 'packed_int32': case 'packedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_int64': case 'packedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_uint32': case 'packedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'packed_uint64': case 'packedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'packed_sint32': case 'packedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_sint64': case 'packedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_fixed32': case 'packedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_fixed64': case 'packedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'packed_sfixed32': case 'packedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'packed_sfixed64': case 'packedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'packed_float': case 'packedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'packed_double': case 'packedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'packed_bool': case 'packedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'packed_nested_enum': case 'packedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->packed_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($vv);
          }
          break;
        case 'unpacked_int32': case 'unpackedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_int64': case 'unpackedInt64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_int64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_uint32': case 'unpackedUint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_uint32 []= \Protobuf\Internal\JsonDecoder::readInt32Unsigned($vv);
          }
          break;
        case 'unpacked_uint64': case 'unpackedUint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_uint64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'unpacked_sint32': case 'unpackedSint32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sint32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_sint64': case 'unpackedSint64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sint64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_fixed32': case 'unpackedFixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_fixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_fixed64': case 'unpackedFixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_fixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Unsigned($vv);
          }
          break;
        case 'unpacked_sfixed32': case 'unpackedSfixed32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sfixed32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        case 'unpacked_sfixed64': case 'unpackedSfixed64':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_sfixed64 []= \Protobuf\Internal\JsonDecoder::readInt64Signed($vv);
          }
          break;
        case 'unpacked_float': case 'unpackedFloat':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_float []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'unpacked_double': case 'unpackedDouble':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_double []= \Protobuf\Internal\JsonDecoder::readFloat($vv);
          }
          break;
        case 'unpacked_bool': case 'unpackedBool':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_bool []= \Protobuf\Internal\JsonDecoder::readBool($vv);
          }
          break;
        case 'unpacked_nested_enum': case 'unpackedNestedEnum':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->unpacked_nested_enum []= \protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($vv);
          }
          break;
        case 'oneof_uint32': case 'oneofUint32':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_uint32(\Protobuf\Internal\JsonDecoder::readInt32Unsigned($v));
          break;
        case 'oneof_nested_message': case 'oneofNestedMessage':
          $obj = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
          $obj->MergeJsonFrom($v);
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_nested_message($obj);
          break;
        case 'oneof_string': case 'oneofString':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_string(\Protobuf\Internal\JsonDecoder::readString($v));
          break;
        case 'oneof_bytes': case 'oneofBytes':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_bytes(\Protobuf\Internal\JsonDecoder::readBytes($v));
          break;
        case 'oneof_bool': case 'oneofBool':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_bool(\Protobuf\Internal\JsonDecoder::readBool($v));
          break;
        case 'oneof_uint64': case 'oneofUint64':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_uint64(\Protobuf\Internal\JsonDecoder::readInt64Unsigned($v));
          break;
        case 'oneof_float': case 'oneofFloat':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_float(\Protobuf\Internal\JsonDecoder::readFloat($v));
          break;
        case 'oneof_double': case 'oneofDouble':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_double(\Protobuf\Internal\JsonDecoder::readFloat($v));
          break;
        case 'oneof_enum': case 'oneofEnum':
          $this->oneof_field = new TestAllTypesProto2_oneof_field_oneof_enum(\protobuf_test_messages\proto2\TestAllTypesProto2_NestedEnum::FromMixed($v));
          break;
        case 'data':
          if ($v === null) break;
          if ($this->data == null) $this->data = new \protobuf_test_messages\proto2\TestAllTypesProto2_Data();
          $this->data->MergeJsonFrom($v);
          break;
        case 'default_int32': case 'defaultInt32':
          $this->default_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'default_int64': case 'defaultInt64':
          $this->default_int64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'default_uint32': case 'defaultUint32':
          $this->default_uint32 = \Protobuf\Internal\JsonDecoder::readInt32Unsigned($v);
          break;
        case 'default_uint64': case 'defaultUint64':
          $this->default_uint64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'default_sint32': case 'defaultSint32':
          $this->default_sint32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'default_sint64': case 'defaultSint64':
          $this->default_sint64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'default_fixed32': case 'defaultFixed32':
          $this->default_fixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'default_fixed64': case 'defaultFixed64':
          $this->default_fixed64 = \Protobuf\Internal\JsonDecoder::readInt64Unsigned($v);
          break;
        case 'default_sfixed32': case 'defaultSfixed32':
          $this->default_sfixed32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'default_sfixed64': case 'defaultSfixed64':
          $this->default_sfixed64 = \Protobuf\Internal\JsonDecoder::readInt64Signed($v);
          break;
        case 'default_float': case 'defaultFloat':
          $this->default_float = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'default_double': case 'defaultDouble':
          $this->default_double = \Protobuf\Internal\JsonDecoder::readFloat($v);
          break;
        case 'default_bool': case 'defaultBool':
          $this->default_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'default_string': case 'defaultString':
          $this->default_string = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'default_bytes': case 'defaultBytes':
          $this->default_bytes = \Protobuf\Internal\JsonDecoder::readBytes($v);
          break;
        case 'fieldname1':
          $this->fieldname1 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_name2': case 'fieldName2':
          $this->field_name2 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '_field_name3': case 'FieldName3':
          $this->_field_name3 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__name4_': case 'fieldName4':
          $this->field__name4_ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field0name5':
          $this->field0name5 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_0_name6': case 'field0Name6':
          $this->field_0_name6 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'fieldName7':
          $this->fieldName7 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FieldName8':
          $this->FieldName8 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_Name9': case 'fieldName9':
          $this->field_Name9 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'Field_Name10': case 'FieldName10':
          $this->Field_Name10 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FIELD_NAME11': case 'FIELDNAME11':
          $this->FIELD_NAME11 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'FIELD_name12': case 'FIELDName12':
          $this->FIELD_name12 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '__field_name13': case 'FieldName13':
          $this->__field_name13 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case '__Field_name14': case 'FieldName14':
          $this->__Field_name14 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__name15': case 'fieldName15':
          $this->field__name15 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field__Name16': case 'fieldName16':
          $this->field__Name16 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'field_name17__': case 'fieldName17':
          $this->field_name17__ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'Field_name18__': case 'FieldName18':
          $this->Field_name18__ = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is TestAllTypesProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->optional_int32 = $o->optional_int32;
    $this->optional_int64 = $o->optional_int64;
    $this->optional_uint32 = $o->optional_uint32;
    $this->optional_uint64 = $o->optional_uint64;
    $this->optional_sint32 = $o->optional_sint32;
    $this->optional_sint64 = $o->optional_sint64;
    $this->optional_fixed32 = $o->optional_fixed32;
    $this->optional_fixed64 = $o->optional_fixed64;
    $this->optional_sfixed32 = $o->optional_sfixed32;
    $this->optional_sfixed64 = $o->optional_sfixed64;
    $this->optional_float = $o->optional_float;
    $this->optional_double = $o->optional_double;
    $this->optional_bool = $o->optional_bool;
    $this->optional_string = $o->optional_string;
    $this->optional_bytes = $o->optional_bytes;
    $tmp = $o->optional_nested_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($tmp);
      $this->optional_nested_message = $nv;
    }
    $tmp = $o->optional_foreign_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($tmp);
      $this->optional_foreign_message = $nv;
    }
    $this->optional_nested_enum = $o->optional_nested_enum;
    $this->optional_foreign_enum = $o->optional_foreign_enum;
    $this->optional_string_piece = $o->optional_string_piece;
    $this->optional_cord = $o->optional_cord;
    $tmp = $o->recursive_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2();
      $nv->CopyFrom($tmp);
      $this->recursive_message = $nv;
    }
    $this->repeated_int32 = $o->repeated_int32;
    $this->repeated_int64 = $o->repeated_int64;
    $this->repeated_uint32 = $o->repeated_uint32;
    $this->repeated_uint64 = $o->repeated_uint64;
    $this->repeated_sint32 = $o->repeated_sint32;
    $this->repeated_sint64 = $o->repeated_sint64;
    $this->repeated_fixed32 = $o->repeated_fixed32;
    $this->repeated_fixed64 = $o->repeated_fixed64;
    $this->repeated_sfixed32 = $o->repeated_sfixed32;
    $this->repeated_sfixed64 = $o->repeated_sfixed64;
    $this->repeated_float = $o->repeated_float;
    $this->repeated_double = $o->repeated_double;
    $this->repeated_bool = $o->repeated_bool;
    $this->repeated_string = $o->repeated_string;
    $this->repeated_bytes = $o->repeated_bytes;
    foreach ($o->repeated_nested_message as $v) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($v);
      $this->repeated_nested_message []= $nv;
    }
    foreach ($o->repeated_foreign_message as $v) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($v);
      $this->repeated_foreign_message []= $nv;
    }
    $this->repeated_nested_enum = $o->repeated_nested_enum;
    $this->repeated_foreign_enum = $o->repeated_foreign_enum;
    $this->repeated_string_piece = $o->repeated_string_piece;
    $this->repeated_cord = $o->repeated_cord;
    $this->map_int32_int32 = $o->map_int32_int32;
    $this->map_int64_int64 = $o->map_int64_int64;
    $this->map_uint32_uint32 = $o->map_uint32_uint32;
    $this->map_uint64_uint64 = $o->map_uint64_uint64;
    $this->map_sint32_sint32 = $o->map_sint32_sint32;
    $this->map_sint64_sint64 = $o->map_sint64_sint64;
    $this->map_fixed32_fixed32 = $o->map_fixed32_fixed32;
    $this->map_fixed64_fixed64 = $o->map_fixed64_fixed64;
    $this->map_sfixed32_sfixed32 = $o->map_sfixed32_sfixed32;
    $this->map_sfixed64_sfixed64 = $o->map_sfixed64_sfixed64;
    $this->map_int32_float = $o->map_int32_float;
    $this->map_int32_double = $o->map_int32_double;
    $this->map_bool_bool = $o->map_bool_bool;
    $this->map_string_string = $o->map_string_string;
    $this->map_string_bytes = $o->map_string_bytes;
    foreach ($o->map_string_nested_message as $k => $v) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_NestedMessage();
      $nv->CopyFrom($v);
      $this->map_string_nested_message[$k] = $nv;
    }
    foreach ($o->map_string_foreign_message as $k => $v) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($v);
      $this->map_string_foreign_message[$k] = $nv;
    }
    $this->map_string_nested_enum = $o->map_string_nested_enum;
    $this->map_string_foreign_enum = $o->map_string_foreign_enum;
    $this->packed_int32 = $o->packed_int32;
    $this->packed_int64 = $o->packed_int64;
    $this->packed_uint32 = $o->packed_uint32;
    $this->packed_uint64 = $o->packed_uint64;
    $this->packed_sint32 = $o->packed_sint32;
    $this->packed_sint64 = $o->packed_sint64;
    $this->packed_fixed32 = $o->packed_fixed32;
    $this->packed_fixed64 = $o->packed_fixed64;
    $this->packed_sfixed32 = $o->packed_sfixed32;
    $this->packed_sfixed64 = $o->packed_sfixed64;
    $this->packed_float = $o->packed_float;
    $this->packed_double = $o->packed_double;
    $this->packed_bool = $o->packed_bool;
    $this->packed_nested_enum = $o->packed_nested_enum;
    $this->unpacked_int32 = $o->unpacked_int32;
    $this->unpacked_int64 = $o->unpacked_int64;
    $this->unpacked_uint32 = $o->unpacked_uint32;
    $this->unpacked_uint64 = $o->unpacked_uint64;
    $this->unpacked_sint32 = $o->unpacked_sint32;
    $this->unpacked_sint64 = $o->unpacked_sint64;
    $this->unpacked_fixed32 = $o->unpacked_fixed32;
    $this->unpacked_fixed64 = $o->unpacked_fixed64;
    $this->unpacked_sfixed32 = $o->unpacked_sfixed32;
    $this->unpacked_sfixed64 = $o->unpacked_sfixed64;
    $this->unpacked_float = $o->unpacked_float;
    $this->unpacked_double = $o->unpacked_double;
    $this->unpacked_bool = $o->unpacked_bool;
    $this->unpacked_nested_enum = $o->unpacked_nested_enum;
    $tmp = $o->data;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\TestAllTypesProto2_Data();
      $nv->CopyFrom($tmp);
      $this->data = $nv;
    }
    $this->default_int32 = $o->default_int32;
    $this->default_int64 = $o->default_int64;
    $this->default_uint32 = $o->default_uint32;
    $this->default_uint64 = $o->default_uint64;
    $this->default_sint32 = $o->default_sint32;
    $this->default_sint64 = $o->default_sint64;
    $this->default_fixed32 = $o->default_fixed32;
    $this->default_fixed64 = $o->default_fixed64;
    $this->default_sfixed32 = $o->default_sfixed32;
    $this->default_sfixed64 = $o->default_sfixed64;
    $this->default_float = $o->default_float;
    $this->default_double = $o->default_double;
    $this->default_bool = $o->default_bool;
    $this->default_string = $o->default_string;
    $this->default_bytes = $o->default_bytes;
    $this->fieldname1 = $o->fieldname1;
    $this->field_name2 = $o->field_name2;
    $this->_field_name3 = $o->_field_name3;
    $this->field__name4_ = $o->field__name4_;
    $this->field0name5 = $o->field0name5;
    $this->field_0_name6 = $o->field_0_name6;
    $this->fieldName7 = $o->fieldName7;
    $this->FieldName8 = $o->FieldName8;
    $this->field_Name9 = $o->field_Name9;
    $this->Field_Name10 = $o->Field_Name10;
    $this->FIELD_NAME11 = $o->FIELD_NAME11;
    $this->FIELD_name12 = $o->FIELD_name12;
    $this->__field_name13 = $o->__field_name13;
    $this->__Field_name14 = $o->__Field_name14;
    $this->field__name15 = $o->field__name15;
    $this->field__Name16 = $o->field__Name16;
    $this->field_name17__ = $o->field_name17__;
    $this->Field_name18__ = $o->Field_name18__;
    $this->oneof_field = $o->oneof_field->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ForeignMessageProto2 implements \Protobuf\Message {
  public int $c;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'c' => int,
  ) $s = shape()) {
    $this->c = $s['c'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.ForeignMessageProto2";
  }

  public static function ParseFrom(string $input): ?ForeignMessageProto2 {
    $msg = new ForeignMessageProto2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->c = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->c !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->c);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('c', 'c', $this->c, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'c':
          $this->c = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ForeignMessageProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->c = $o->c;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UnknownToTestAllTypes_OptionalGroup implements \Protobuf\Message {
  public int $a;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'a' => int,
  ) $s = shape()) {
    $this->a = $s['a'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.UnknownToTestAllTypes.OptionalGroup";
  }

  public static function ParseFrom(string $input): ?UnknownToTestAllTypes_OptionalGroup {
    $msg = new UnknownToTestAllTypes_OptionalGroup();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->a = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->a !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->a);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('a', 'a', $this->a, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'a':
          $this->a = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UnknownToTestAllTypes_OptionalGroup)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->a = $o->a;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class UnknownToTestAllTypes implements \Protobuf\Message {
  public int $optional_int32;
  public string $optional_string;
  public ?\protobuf_test_messages\proto2\ForeignMessageProto2 $nested_message;
  public ?\protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup $optionalgroup;
  public bool $optional_bool;
  public vec<int> $repeated_int32;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'optional_int32' => int,
    ?'optional_string' => string,
    ?'nested_message' => ?\protobuf_test_messages\proto2\ForeignMessageProto2,
    ?'optionalgroup' => ?\protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup,
    ?'optional_bool' => bool,
    ?'repeated_int32' => vec<int>,
  ) $s = shape()) {
    $this->optional_int32 = $s['optional_int32'] ?? 0;
    $this->optional_string = $s['optional_string'] ?? '';
    $this->nested_message = $s['nested_message'] ?? null;
    $this->optionalgroup = $s['optionalgroup'] ?? null;
    $this->optional_bool = $s['optional_bool'] ?? false;
    $this->repeated_int32 = $s['repeated_int32'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.UnknownToTestAllTypes";
  }

  public static function ParseFrom(string $input): ?UnknownToTestAllTypes {
    $msg = new UnknownToTestAllTypes();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1001:
          $this->optional_int32 = $d->readVarint32Signed();
          break;
        case 1002:
          $this->optional_string = $d->readString();
          break;
        case 1003:
          if ($this->nested_message == null) $this->nested_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->nested_message->MergeFrom($d->readDecoder());
          break;
        case 1004:
          if ($this->optionalgroup == null) $this->optionalgroup = new \protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup();
          $this->optionalgroup->MergeFrom($d->readDecoder());
          break;
        case 1006:
          $this->optional_bool = $d->readBool();
          break;
        case 1011:
          if ($wt == 2) {
            $packed = $d->readDecoder();
            while (!$packed->isEOF()) {
              $this->repeated_int32 []= $packed->readVarint32Signed();
            }
          } else {
            $this->repeated_int32 []= $d->readVarint32Signed();
          }
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->optional_int32 !== 0) {
      $e->writeTag(1001, 0);
      $e->writeVarint($this->optional_int32);
    }
    if ($this->optional_string !== '') {
      $e->writeTag(1002, 2);
      $e->writeString($this->optional_string);
    }
    $msg = $this->nested_message;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1003);
    }
    $msg = $this->optionalgroup;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1004);
    }
    if ($this->optional_bool !== false) {
      $e->writeTag(1006, 0);
      $e->writeBool($this->optional_bool);
    }
    foreach ($this->repeated_int32 as $elem) {
      $e->writeTag(1011, 0);
      $e->writeVarint($elem);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('optional_int32', 'optionalInt32', $this->optional_int32, false);
    $e->writeString('optional_string', 'optionalString', $this->optional_string, false);
    $e->writeMessage('nested_message', 'nestedMessage', $this->nested_message, false);
    $e->writeMessage('optionalgroup', 'optionalgroup', $this->optionalgroup, false);
    $e->writeBool('optional_bool', 'optionalBool', $this->optional_bool, false);
    $e->writePrimitiveList('repeated_int32', 'repeatedInt32', $this->repeated_int32);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'optional_int32': case 'optionalInt32':
          $this->optional_int32 = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'optional_string': case 'optionalString':
          $this->optional_string = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'nested_message': case 'nestedMessage':
          if ($v === null) break;
          if ($this->nested_message == null) $this->nested_message = new \protobuf_test_messages\proto2\ForeignMessageProto2();
          $this->nested_message->MergeJsonFrom($v);
          break;
        case 'optionalgroup':
          if ($v === null) break;
          if ($this->optionalgroup == null) $this->optionalgroup = new \protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup();
          $this->optionalgroup->MergeJsonFrom($v);
          break;
        case 'optional_bool': case 'optionalBool':
          $this->optional_bool = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'repeated_int32': case 'repeatedInt32':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->repeated_int32 []= \Protobuf\Internal\JsonDecoder::readInt32Signed($vv);
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is UnknownToTestAllTypes)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->optional_int32 = $o->optional_int32;
    $this->optional_string = $o->optional_string;
    $tmp = $o->nested_message;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\ForeignMessageProto2();
      $nv->CopyFrom($tmp);
      $this->nested_message = $nv;
    }
    $tmp = $o->optionalgroup;
    if ($tmp !== null) {
      $nv = new \protobuf_test_messages\proto2\UnknownToTestAllTypes_OptionalGroup();
      $nv->CopyFrom($tmp);
      $this->optionalgroup = $nv;
    }
    $this->optional_bool = $o->optional_bool;
    $this->repeated_int32 = $o->repeated_int32;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class NullHypothesisProto2 implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.NullHypothesisProto2";
  }

  public static function ParseFrom(string $input): ?NullHypothesisProto2 {
    $msg = new NullHypothesisProto2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is NullHypothesisProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype EnumOnlyProto2_Bool_enum_t as int = int;
abstract class EnumOnlyProto2_Bool {
  const EnumOnlyProto2_Bool_enum_t kFalse = 0;
  const EnumOnlyProto2_Bool_enum_t kTrue = 1;
  private static dict<int, string> $itos = dict[
    0 => 'kFalse',
    1 => 'kTrue',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'kFalse' => 0,
    'kTrue' => 1,
  ];
  public static function FromMixed(mixed $m): EnumOnlyProto2_Bool_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): EnumOnlyProto2_Bool_enum_t {
    return $i;
  }
}

class EnumOnlyProto2 implements \Protobuf\Message {
  private string $XXX_unrecognized;

  public function __construct(shape(
  ) $s = shape()) {
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.EnumOnlyProto2";
  }

  public static function ParseFrom(string $input): ?EnumOnlyProto2 {
    $msg = new EnumOnlyProto2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumOnlyProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class OneStringProto2 implements \Protobuf\Message {
  public string $data;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'data' => string,
  ) $s = shape()) {
    $this->data = $s['data'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "protobuf_test_messages.proto2.OneStringProto2";
  }

  public static function ParseFrom(string $input): ?OneStringProto2 {
    $msg = new OneStringProto2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->data = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->data !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->data);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('data', 'data', $this->data, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'data':
          $this->data = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is OneStringProto2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->data = $o->data;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_test_messages_proto2__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/test_messages_proto2.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 11824 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\xb4\x5a\xe9\x73\xdb\xc6\x15\xe7\x12\x92\x48\xad\x78\x69\x2d\x3b\x1b\xa5\x99\xc0\xb2\x1d\x23\x76\x6c\x4b\x14\xb2\x92\xd8\x34\x89\x65\x8b\x96\x93\x48\x4a\x20\xbb\x87\xd3\x84\xa5\x24\x48\x61\x4d\x12\x2a\x8f\xc4\xfa\xd2\xcc\x74\xfa\xa1\xd3\x7e\x49\xef\x3b\x3d\xfe\x85\x7e\xea\xf4\x1f\x68\xda\x7f\xa4\xd7\x74\xa6\x4d\xdb\x1c\x3d\xdc\xd9\x13\xbb\x0\x64\xd7\xa4\xea\x19\x8b\xe4\xc3\xef\xfd\xde\x7b\x8b\xb7\x3f\xec\x2\x80\xe7\xf6\x82\x60\xaf\xe9\x5f\xda\xef\x4\xbd\x60\xab\xbf\x7b\xa9\xe7\x77\x7b\xb5\x96\xdf\xed\xd6\xf7\xfc\x6e\x8d\x99\xcb\x17\xd9\x7\x7a\x54\x82\x6a\x6\x88\x1f\x2d\xcf\xfc\xf2\x65\x88\x6e\xf8\xdd\xde\xe5\x66\xf3\xc6\xc1\xbe\xdf\x7d\x89\x99\xd1\x19\x58\x8\xf6\x7b\x8d\xa0\x5d\x6f\xd6\x1a\xed\xde\x7c\x19\x3\x1b\x38\xa3\x5e\x5e\x5a\xaf\x53\x63\x14\x46\x5c\x9c\xb6\x81\x63\x19\x30\xe2\xa2\xb3\xb0\xa8\x60\x7d\x4e\x67\xd9\xc0\xc9\x7b\xca\xfb\x26\xb3\xc6\x80\xc4\xc5\x23\x36\x70\x46\x4c\x60\x84\xb1\xcb\x19\x47\x6d\xe0\x4c\x86\xc0\xcd\x38\x63\x97\x33\x8e\xd9\xc0\x41\x26\x90\xb8\xe8\x9\x58\x52\xc0\xdd\xc6\x1d\x7f\x67\xbe\x8c\x33\x36\x70\x32\x9e\x22\xa8\x72\x73\x1c\x4a\x5c\x9c\xb5\x81\x33\x16\x81\x12\x17\x9d\x87\x93\x61\x78\x49\x3b\x6e\x3\xa7\xe8\x29\x8e\x4d\x61\x4f\x0\x13\x17\x43\x1b\x38\xa5\x28\x98\xb8\xc6\xd0\xef\x36\x83\x7a\xf\x4f\xd8\xc0\x49\x87\x43\x5f\xa5\x46\xa3\xfe\x9d\xa0\xbf\xd5\xf4\x71\xce\x6\xe\x8\xeb\xbf\xca\xac\xe8\x14\x54\x9e\xb5\xad\x20\x68\xe2\xbc\xd\x9c\xac\x97\x93\xc6\xe5\x20\x68\x9a\xa3\xd9\xeb\x34\xda\x7b\xb8\x60\x3\x67\x5c\x1b\x4d\x66\x35\xb2\xdb\x3a\xe8\xf9\x5d\x5c\xb4\x81\x93\xb\xb3\x5b\xa6\x46\xf4\x26\x7c\x48\xc1\xda\x7e\xb7\xe7\xef\xc8\x6\xc5\xc8\x6\xce\x44\xf9\xd9\x8b\xf7\x6c\xdf\x8b\xf1\xd6\xbd\xb8\xce\x78\xd6\x38\xd0\x3b\x2e\xf9\xd\x33\x6a\x41\x1c\x8e\x5e\xd0\xf1\x1b\x7b\x6d\x15\xf9\x18\x8b\x3c\x7f\x9f\xc8\x55\xee\x25\x8\x79\x6c\xef\x84\x1a\x7c\xe3\x28\x6a\xc3\xa9\x68\x9d\x7e\xbb\xdf\xc2\xc7\x6d\xe0\x14\xca\x4f\xf\x5a\xe4\x4a\xbb\xdf\xf2\x90\x59\x21\xb5\xa1\x1d\x78\x3c\x56\x1e\xb\x78\x82\x5\x9c\xfd\xdf\x6a\xa3\x54\xa2\xb0\x63\x91\xc2\x58\x14\xa2\x45\xe1\xdd\x50\xdb\x6f\xf8\xdb\x3e\xc6\xb4\x27\x96\xd3\xd9\x74\xe8\xc7\xfb\xe2\x25\x7a\x18\x9d\xd5\x5a\x6d\x3b\xe8\xec\xe0\x87\x5\x1e\x84\xed\x76\x25\xe8\xec\xa0\xd7\xe0\x64\xc7\xdf\xee\x77\xba\x8d\x37\x7c\x75\x7a\x1e\x61\xa7\x67\xee\x81\xc7\xcc\x2b\x29\x2e\x79\x5a\xce\xc0\x42\xc7\xdf\xf7\xeb\xf4\x7c\x70\x11\x79\xcc\xb6\xa8\xca\x49\xab\x52\x39\x1d\x46\x5c\x6c\xdb\x16\x55\x39\xd\xc6\x35\x49\xc1\x84\xca\x9d\xb4\x2d\xaa\x72\xd2\x1c\xaa\x9c\x1\x24\x2e\x9e\xb1\x2d\xaa\x72\x3a\x30\xc2\x28\x54\xee\x94\x6d\x51\x95\x93\xe6\xcd\x38\xa3\x50\xb9\xd3\xb6\x45\x55\x4e\x7\x72\x95\x53\x40\x29\x47\x67\x6c\x8b\xaa\x9c\xb4\x6b\x2a\x67\x42\x89\x8b\x1f\xb7\x2d\xaa\x72\x6\x94\xab\x5c\x18\x5e\xd2\x9e\xb5\x2d\xaa\x72\x2a\x1\x4d\xe5\x22\x60\xe2\x62\xc7\xb6\xa8\xca\x99\x60\xae\x72\x61\x12\x4c\xe5\x9e\xb0\x2d\xaa\x72\x2a\x5\xa9\x72\xa\x26\x54\xee\x9c\x6d\x51\x95\x93\xe6\x50\xe5\x14\x90\xa9\xdc\x79\xdb\xa2\x2a\x27\x8d\x52\xe5\xc2\xc\xb9\xca\x3d\x69\x5b\x54\xe5\x54\x7e\x4a\xe5\x42\x36\xa6\x72\x17\x6c\x8b\xaa\x9c\xa2\x93\x2a\xa7\x60\x11\x95\x9b\xb5\xad\x23\x51\x39\xc9\x1f\x53\xb9\x70\xf4\x22\x2a\x37\xc7\x22\xf\xa6\x72\x6a\xf0\x63\x2a\x17\xad\x93\x89\xce\xbc\x6d\xd\xaf\x72\x66\x85\x52\xe5\x62\xe5\xb1\x80\x2e\xb\x38\x80\xca\x45\xa\x93\x2a\x17\xe9\x6\xa1\x72\x84\xf6\x4\x57\x39\xb3\x2f\x94\xca\x29\x3f\xa6\x72\xb\x2\xf\xc2\x76\x63\x2a\x77\x6\xe6\xf6\xeb\xdb\xb7\x95\x6\xbd\x40\x35\x68\x39\x5d\x2\xde\x4\xb7\x4b\x15\xd2\x60\xc4\xc5\x2f\x52\xd\x8a\xc0\x98\x66\xe4\x5\x4c\x68\xd0\x1a\xd5\x20\x86\x13\xfe\x4a\x85\x74\x20\x71\xf1\x3a\xd5\xa0\x28\xd0\x60\x14\x1a\xb4\x41\x35\x48\x7\x6e\x46\x19\x85\x6\xbd\x44\x35\x28\xa\x64\x2a\x54\x10\x40\x29\x16\x2f\x53\xd\x62\x48\x41\x11\xaa\x90\x1\x25\x2e\xf6\xa8\x6\xc5\xa0\x4c\x85\x8a\x32\xbc\xa4\xdd\xa4\x1a\xc4\xb0\x82\x45\x53\x21\x13\x4c\x5c\x7c\x83\x6a\x50\x1c\xcc\x54\x48\xe\x3d\xd7\xa0\x9b\x54\x83\xf4\xa1\x97\x2a\x24\xeb\x17\x1a\xf4\x49\xaa\x41\x7a\xfd\x4a\x85\x84\x1f\xd7\xa0\x4f\x51\xd\x62\x30\xc8\xcd\x4c\x85\xda\x10\x9\x90\x3e\x97\x3e\x3d\xfc\x5c\x62\x91\x4a\x9c\x5b\x9b\x4d\x4f\xc0\x42\xbf\x6d\x34\xe2\x67\x44\x23\xa6\xbc\xbc\x3c\xc2\x5b\x31\x2\x25\x2e\xbe\x25\x9a\xd1\x84\xf2\x93\xa2\xa0\xa2\x21\x5f\x11\xd\x99\xf2\x14\x8b\x68\xc9\x28\x98\xb8\xf8\xb3\xa2\x29\x23\xe0\x8\xb3\x68\xcc\x57\x45\x63\x6a\xe0\xcd\x38\xb3\x68\xce\xd7\x44\x73\x46\xc0\xc4\x45\x17\x60\x49\x81\x65\x27\xd5\x44\x83\xa6\x3c\x45\x24\x5b\x34\x6\x27\x2e\xfe\x9c\x68\xd2\x28\x9c\xb8\xe8\x12\x9c\xc\x53\x91\xf4\x75\xd1\xa8\x29\x4f\x71\xa9\x56\x8d\x3b\x10\x17\x6f\x89\x66\x8d\x39\xf0\xe9\x15\x26\xc4\x1a\x76\x5b\x34\xac\x76\x7a\x78\xcb\xea\xe3\x22\x9a\x76\x47\x34\xad\x36\x2e\xa2\x6d\xcf\x42\xe5\xcd\x1b\xd7\x17\x8d\x9b\xf2\x72\xf2\x0\x6b\xdd\xe\x9c\x52\x40\xbd\x79\x77\x8f\xa4\x79\x53\x1e\x92\xec\x5a\xfb\x36\x61\xb1\x55\xdf\xe7\x9d\x2b\xfa\x77\x91\x5d\xe2\xae\x3e\x78\xb8\xb5\xfa\x3e\x6b\x74\xf6\x67\xa5\xdd\xeb\x1c\x78\xf9\x96\x6e\xd3\xa2\x11\x57\x4c\x81\xa5\xe1\xa2\x11\x97\xfd\x31\xa2\x9\x1b\xea\xc0\x49\x1a\x8d\xcf\x1f\x39\x8d\x2a\x2c\x5e\x75\xa0\x78\x7c\xbe\xf1\xbf\x3c\x22\x2d\x47\xb7\xea\x31\x89\x2b\x67\xe3\xc7\x87\x8c\x49\x5c\xfe\xd7\x8c\x29\xad\x32\x26\x9f\xcd\x72\x52\x3f\x3d\x44\x4c\x3e\xfb\x37\x23\x75\xea\x56\x3d\x26\x71\xa5\x36\x7c\x62\xc8\x98\xc4\xdd\x8c\xd4\xa9\x5b\xd1\x1d\x78\x8c\xc6\x14\x13\x5c\x69\xcc\x33\x2c\xea\xea\x40\x51\x85\x18\x89\xf\x1e\x97\x16\x66\xda\x8d\xc8\xc4\x55\x72\xf5\xec\xb0\x91\x89\x2b\x3e\x22\x91\x95\x1d\x7d\x11\x1e\x67\xe3\x2c\x8b\x56\xd2\xf7\x1c\x8b\xfd\xfc\x60\x63\x2d\x48\xe4\x27\x8f\x4e\x4b\x8c\x1e\x31\xe3\xd3\x33\x2d\x6b\xbf\x3c\x74\x7c\xe2\xca\xcf\x68\xfc\xf0\x88\xa9\x4f\x5c\x95\x97\x87\xd5\x27\xa6\xe1\x11\x7d\xe2\xba\x1e\xc0\x52\x18\x4d\x8\xfb\x15\x16\x6e\x65\xf0\x70\xfc\x32\xc0\xe3\x15\x5a\x86\x11\xed\x42\x9a\x1\xbb\x2c\xf0\x6b\xc3\x55\x16\x6d\x79\xa0\x68\xf4\x22\x42\xff\xf3\x50\x13\xad\xd0\xa2\xa6\x2b\x5f\x88\x8b\xdd\xd9\xca\x30\xd3\x95\x51\xf0\xbf\xda\x74\xd5\xac\x72\x30\x45\x4c\xbe\xd1\xab\xe\x31\x98\x9c\x96\xed\xd\xc3\xc1\xd4\x8c\xe8\x2b\x0\x3e\xac\x45\x8c\xec\x19\xaf\xb1\xd0\x6b\x43\x84\x36\x76\x89\x3c\x85\x13\xad\xc4\x83\xe8\x6b\x0\x4e\x6b\xa9\x44\x77\x91\xab\x2c\x97\xf5\x21\x72\x31\xf7\x90\x3c\x99\x87\x5a\xc9\x47\xd1\x5b\xf0\x44\x7c\x5c\xd8\xd2\xe2\xfa\x30\xb3\x58\xab\x9b\xae\x25\xb4\x59\x1c\x39\x82\xbe\x4\xe0\x43\x9\xc3\xc1\x52\x78\x9e\xa5\xf0\xc2\xf0\x63\x11\xe6\x30\xd5\x4a\x38\x84\x4e\xc1\x5c\xd0\xf6\x83\x5d\xb9\x12\x8\x6c\xe0\xe4\x57\x53\xde\x4\xb3\x8a\xeb\x77\x17\x4e\x71\x50\xa4\x7b\xf6\x8f\xe4\xbe\xea\x6a\xca\x43\x8c\xde\xec\x16\x95\x99\x98\x98\x5f\xb0\x81\x33\xae\x32\x13\xd3\xe9\x24\xe4\x3f\xc5\x4c\xea\xd8\xc0\xc9\xad\xa6\x3c\xc8\x8c\x7c\x2\x3c\x6\xa1\x80\x50\x29\xe9\xda\xc0\xc9\xae\xa6\xbc\x71\x8e\xa0\x32\x60\xc\x1\x71\x71\xcf\x6\xce\x88\x31\x4\xc4\xd\x3\x71\xb9\xed\xdb\xc0\x49\xab\x40\x5c\x27\x15\x8f\xd0\xc8\x37\x6c\xe0\x0\xc5\x23\xb4\xed\x55\x99\xd\x3b\xcd\x6f\xe\x7f\xcf\x56\xd5\xc2\x4e\xe7\xb\x70\x64\xa7\xde\xab\xe3\x77\x81\xd\x1c\x58\x26\xf\xce\x7c\xb5\xde\xab\x7b\x8c\x4\xcd\xc2\xfc\x8e\xbf\x5b\xef\x37\x7b\x62\x11\xfc\x17\xf6\xe0\xa6\x2\x2f\xcc\x95\xe7\xdd\xa7\xc8\xc2\xe2\x92\x97\x13\x8\xbe\x94\xad\x18\x1e\xc4\xc5\x7f\xa5\x1e\x56\x65\xea\xc2\x92\x72\x49\xf4\x25\x2e\x2a\xc3\x82\xf4\x15\xbd\xf8\x1e\x75\xce\x57\x60\x39\x74\x91\xf4\xa2\x31\x9f\x36\x7d\x88\x8b\xff\x46\x7d\x46\x2a\x53\x73\xb3\x9\x1\x75\x6f\x33\xa2\x58\x1f\xfe\x9d\x7a\x4f\x1a\x5\x4a\x9f\xcd\x58\x44\xb1\xbe\xfb\x7\xf5\x41\x87\x94\xa8\x7b\x13\x17\xb9\xb0\x28\xbd\xe5\x92\xe5\x7d\xea\x9e\x31\x8a\x94\x11\xe4\x42\xeb\x99\x88\x17\x71\xf1\x7\xd4\x6b\xec\x90\x32\xd\x7f\xe2\x22\x2\x4b\x2a\x67\x19\xf6\x43\x4a\x50\x34\x2a\x95\x41\xd4\x32\xe7\xb9\xa8\x1f\x71\xf1\x47\xd4\xaf\x74\x48\xb5\x26\x3\xdb\x57\xab\x7e\xe0\xf3\xe6\x9f\xd4\x3d\x5d\x19\x5d\xf2\xcf\xcf\x86\xd\xc0\xe7\xcf\x85\x70\x68\xc5\xc\xfa\x17\x45\x83\xca\xe8\x82\x7f\xbe\x5c\x56\x63\x29\x66\x92\x3\xa5\x3b\x9f\xd9\xff\xa6\xe0\x6c\x65\xa4\xd7\xe9\xfb\xde\x84\x38\xc4\x26\xf8\x25\xed\x9c\x71\x2d\xf9\xf\xc5\x8e\x57\x32\x5e\xd0\xf5\xb7\xfa\x3b\xe1\x69\xe2\xaa\xf2\x64\x98\x36\xd7\x95\xbb\x14\x9f\xab\x8c\x7d\x3e\xe8\xbe\xde\xaf\xab\xbc\x95\xc0\xec\x36\xfc\xe6\x4e\xbb\xde\xf2\xe7\xf0\xd7\x2d\xf6\x70\x53\x33\x21\x1b\x4e\xb0\x5f\x35\xfa\xb3\x8c\xbf\xa1\x23\xd6\xa9\x9\x9d\x84\xb9\x5a\x8\x99\xc7\xdf\x14\x90\xaa\x84\xcc\xa3\x19\x98\xe7\x8\x6\x71\x6b\xf8\x5b\x51\x1a\x26\x52\xec\xd7\x2c\x85\x3c\x85\xbf\xcd\x11\xba\xd\x9d\x92\x34\xb3\x8c\x87\xe0\xef\x18\x20\xca\x43\x54\x45\xf4\xd7\x2\xfe\x6e\x34\xd0\x2\x5\xa8\xd4\x16\xf1\xf7\xa2\xd9\x2e\x86\x25\xd3\x9f\x4b\xf8\xfb\x51\x8a\x25\x34\x3\x73\x55\x85\x98\x9b\xc5\x3f\x10\x79\x28\x92\xb9\x59\x86\xb9\xbe\xf2\xe2\xd5\xda\xfa\xe5\xb5\x95\xb9\x39\xfc\x43\x89\xa1\x46\x6e\xb\x31\x6c\xac\xcb\xf8\x47\x6\x86\xd9\xd0\x69\x58\xa8\x69\xe3\x3b\x37\x8f\x7f\x1c\x8b\x36\xcf\x51\xd5\x10\xe5\xe2\x77\x62\x28\x37\x1c\x40\xe\x7a\xa\xff\x44\x1f\x40\x6\xd2\x46\x99\x57\x47\xf0\x4f\x63\x20\x42\xe3\x69\x39\x2d\xd4\x6a\xf8\x67\x31\xd4\x2\x45\x69\x39\x2d\xd6\x6a\xf8\xe7\xb1\xac\x16\xa7\x3b\x30\x6f\x5e\x3d\x73\x10\xd4\xc5\x73\x76\x50\x47\x9b\x70\x62\x3b\x50\x8f\xac\xd8\x83\xf5\x81\x1e\x7b\xe9\x2c\xd3\xcf\x41\x14\xbf\xb9\x81\x4a\xd0\xba\xed\x1f\x88\xd0\xf4\x2b\x9a\x82\xa3\x6f\xd4\x9b\x7d\x1e\x76\xd4\xe3\x3f\x2a\xe9\x45\x10\x32\xe8\x37\x2c\x74\x6\x2b\x81\xc1\xd2\x19\x96\xe1\x54\xd2\x2d\x8\x9d\x23\x9f\xc0\x91\x4f\xe6\x30\x6e\x29\xe8\x1c\x23\x9\x1c\x23\x71\x8e\xd8\x2d\x2\x9d\x63\x32\x81\x63\x32\x99\xc3\xd8\xf2\xeb\x1c\x28\x81\x3\xe9\x1c\x57\xe1\x89\xe4\xd\xbc\xce\x92\x49\x60\xc9\x1c\xc2\x62\x6e\xc6\x75\x96\xb1\x4\x96\x31\x9d\xa5\xa\xf1\x61\xdb\x6a\x9d\xa7\x98\xc0\x53\x3c\x8c\x27\xb2\x3d\xd6\x79\x4a\x9\x3c\xa5\xc4\x6e\xd3\x37\xbb\xf7\xeb\xd7\xb4\xce\x70\x19\x1e\x4b\xd8\xbf\xde\x8f\x2\xe8\x14\xcf\xc0\x52\x74\x53\xaa\xfb\x67\x13\xfc\xb3\x9\x4d\x12\xdd\x68\xea\x1c\xe3\x9\x1c\xe3\xf1\x32\xa2\x3b\xc7\xfb\x51\xe4\x74\x8a\xaf\x2\xf8\xc8\x3d\xb6\x80\x9\x5c\x37\x75\xae\x23\x78\x4c\xa9\x25\xf3\x16\xfc\xd8\xbd\xb6\x80\x9\xc9\x5c\x37\x93\x19\xe8\xc9\xa5\x96\xc0\x97\x1\x6f\xd1\xa4\xbd\x5f\x42\x74\x4f\x8f\x3e\xec\xc3\x4c\x2d\x8d\x3\xf8\xf0\xa1\xdb\xbf\x84\x34\xaa\x66\x1a\xf\xfe\x88\x53\xb\xfd\x22\x1c\xa1\x1b\x7\x7a\xdd\xdf\xeb\x4\x7d\x71\xb7\x8\xff\x86\xcf\x9\xc8\x6c\x7c\x8b\x30\x3\x73\x1c\x21\x16\xf9\xbf\xe5\x1a\xcd\xdd\xb8\x84\x4f\x9f\x84\x93\x62\xac\x37\xfd\xde\x95\xa0\xd3\xf1\xb7\x7b\xe7\xb2\xd9\x91\xd2\xdd\xbb\x77\xef\x66\x2a\xe9\x2c\x98\xfe\x88\x36\x60\x14\xb3\x72\xa7\xe7\xb7\xbb\x8d\xa0\x3d\x47\xcb\xed\xf6\x3a\xfc\x6d\x10\x8f\x7e\x2d\xff\x1a\xc0\xe3\xa2\xa6\x5a\xd7\xef\xd5\x7c\x9\x46\x57\x6\xd8\x66\x47\x43\xe3\xf\x7f\xf5\x1a\xeb\xa5\xb5\x23\x20\xb\xeb\xf0\x8e\xb5\xd4\x41\x65\x9d\x7e\xff\x9e\xc5\x97\xe9\xc5\xbf\xc1\xde\xc\x1b\xf5\x40\xa3\xfc\xee\xff\xb7\xf0\xb7\x7f\xc1\x96\xe9\x47\x5c\x79\x39\xb1\xf2\x99\x25\x8\xb5\x3b\x28\x19\x68\x55\x37\x36\x4a\x29\xfa\x65\xf9\xb2\x57\x2\xfc\xcb\xad\x52\x9a\x9e\xff\xf5\x95\x6b\xac\x61\xd8\x3f\x70\x6e\x34\x7b\xa7\xf4\x2e\x58\xce\xab\x8d\x3c\x5d\x3e\x3d\x3f\x96\xfd\x5d\xa6\xf4\xf6\xfa\xcc\x69\x38\x95\x34\xcb\xe9\x50\x6e\xcb\x75\xd4\xf6\xcc\x3b\x16\x3c\x7e\xb3\x7d\xbb\x1d\xbc\xd9\xbe\x11\xe8\xf5\xa0\xc7\x63\x2f\x39\xfe\x3e\x93\xf4\x96\xa3\x13\x7f\xeb\xed\xf\x99\xc4\xd7\xde\x5e\x81\x85\xc8\xed\x96\x3f\x66\x6\x57\xab\x7c\xdb\x58\x1e\x36\xc2\xd7\xa6\xd8\xc4\xc3\x7f\xca\xb0\x1b\x6\xf7\xbb\xc7\x9a\x58\xfc\xc5\xd\x41\x75\x8d\x52\x79\x26\x33\x3a\x1d\x7d\x19\xf0\xcf\x99\x84\xb7\x1\x1f\x8f\xbd\x3e\xf5\x5e\x26\xe1\xfd\xa9\xe9\x47\x61\xde\x88\x66\x2e\x74\x67\x4e\xc0\xa9\xf5\x7e\xb3\xb9\x7a\xb0\x1f\xf4\x5e\xf7\xbb\xd\xd1\x68\x33\x97\x60\x81\x76\xcc\x46\xbb\x79\x20\x2c\x8f\xc2\x11\x16\x18\xc2\xb1\xdb\xd5\x7a\xb3\xeb\x97\x52\x68\x1c\x8e\xde\xbe\xd1\xe9\xfb\x25\x30\x73\x6\x16\x37\xda\xbe\x78\x7\x83\xb7\x2\x12\xf7\x56\xb8\x84\xb2\xef\xe7\xaa\x70\x32\xa6\x8b\xa8\x8\x27\xaa\x1b\xde\xca\xf5\x6b\xeb\x35\xde\x9e\x9a\x81\xb7\xa9\x61\xb8\x55\x4a\x57\x6e\xc1\xa2\x9a\x96\xbc\x7e\xf4\xe0\xcb\x73\x7c\x87\xd\x43\x41\x31\xb1\x21\x5b\xbe\x4\x9d\xed\xa0\x75\x91\xbf\xe7\x7b\x6f\xd2\x55\xf0\x1\x0\xff\xd\x0\x0\xff\xff\x9c\xd5\x12\x39");
  }
}
