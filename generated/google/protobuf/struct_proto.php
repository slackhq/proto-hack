<?hh // strict
namespace google\protobuf;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/struct.proto

newtype NullValue_enum_t as int = int;
abstract class NullValue {
  const NullValue_enum_t NULL_VALUE = 0;
  private static dict<int, string> $itos = dict[
    0 => 'NULL_VALUE',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'NULL_VALUE' => 0,
  ];
  public static function FromMixed(mixed $m): NullValue_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): NullValue_enum_t {
    return $i;
  }
}

class Struct_FieldsEntry implements \Protobuf\Message {
  public string $key;
  public ?\google\protobuf\Value $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'key' => string,
    ?'value' => ?\google\protobuf\Value,
  ) $s = shape()) {
    $this->key = $s['key'] ?? '';
    $this->value = $s['value'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Struct.FieldsEntry";
  }

  public static function ParseFrom(string $input): ?Struct_FieldsEntry {
    $msg = new Struct_FieldsEntry();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->key = $d->readString();
          break;
        case 2:
          if ($this->value == null) $this->value = new \google\protobuf\Value();
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->key !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->key);
    }
    $msg = $this->value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('key', 'key', $this->key, false);
    $e->writeMessage('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'key':
          $this->key = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          if ($this->value == null) $this->value = new \google\protobuf\Value();
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Struct_FieldsEntry)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->key = $o->key;
    $tmp = $o->value;
    if ($tmp !== null) {
      $nv = new \google\protobuf\Value();
      $nv->CopyFrom($tmp);
      $this->value = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class Struct implements \Protobuf\Message {
  public dict<string, \google\protobuf\Value> $fields;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'fields' => dict<string, \google\protobuf\Value>,
  ) $s = shape()) {
    $this->fields = $s['fields'] ?? dict[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Struct";
  }

  public static function ParseFrom(string $input): ?Struct {
    $msg = new Struct();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\Struct_FieldsEntry();
          $obj->MergeFrom($d->readDecoder());
          $this->fields[$obj->key] = $obj->value ?? new \google\protobuf\Value();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->fields as $k => $v) {
      $obj = new \google\protobuf\Struct_FieldsEntry();
      $obj->key = $k;
      $obj->value = $v;
      $nested = new \Protobuf\Internal\Encoder();
      $obj->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $dict = dict[];
    foreach ($this->fields as $kk => $vv) {
      $dict[$kk]= $e->encodeMessage($vv);
    }
    $e->setCustomEncoding($dict);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m is dict<_,_>) {
      foreach ($m as $k => $vv) {
        $val = new \google\protobuf\Value();
        $val->MergeJsonFrom($vv);
        $this->fields[(string)$k] = $val;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Struct)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->fields as $k => $v) {
      $nv = new \google\protobuf\Value();
      $nv->CopyFrom($v);
      $this->fields[$k] = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

enum Value_kind_oneof_t: int {
  NOT_SET = 0;
  null_value = 1;
  number_value = 2;
  string_value = 3;
  bool_value = 4;
  struct_value = 5;
  list_value = 6;
}

interface Value_kind {
  public function WhichOneof(): Value_kind_oneof_t;
  public function WriteTo(\Protobuf\Internal\Encoder $e): void;
  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void;
  public function Copy(): Value_kind;
}

class Value_kind_NOT_SET implements Value_kind {
  public function WhichOneof(): Value_kind_oneof_t {
    return Value_kind_oneof_t::NOT_SET;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {}

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {}

  public function Copy(): Value_kind { return $this; }
}

class Value_kind_null_value implements Value_kind {
  public function __construct(public \google\protobuf\NullValue_enum_t $null_value) {}

  public function WhichOneof(): Value_kind_oneof_t {
    return Value_kind_oneof_t::null_value;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(1, 0);;
    $e->writeVarint($this->null_value);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('null_value', 'nullValue', \google\protobuf\NullValue::ToStringDict(), $this->null_value, true);
  }

  public function Copy(): Value_kind {
    return new Value_kind_null_value($this->null_value);
  }
}

class Value_kind_number_value implements Value_kind {
  public function __construct(public float $number_value) {}

  public function WhichOneof(): Value_kind_oneof_t {
    return Value_kind_oneof_t::number_value;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(2, 1);;
    $e->writeDouble($this->number_value);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeFloat('number_value', 'numberValue', $this->number_value, true);
  }

  public function Copy(): Value_kind {
    return new Value_kind_number_value($this->number_value);
  }
}

class Value_kind_string_value implements Value_kind {
  public function __construct(public string $string_value) {}

  public function WhichOneof(): Value_kind_oneof_t {
    return Value_kind_oneof_t::string_value;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(3, 2);;
    $e->writeString($this->string_value);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('string_value', 'stringValue', $this->string_value, true);
  }

  public function Copy(): Value_kind {
    return new Value_kind_string_value($this->string_value);
  }
}

class Value_kind_bool_value implements Value_kind {
  public function __construct(public bool $bool_value) {}

  public function WhichOneof(): Value_kind_oneof_t {
    return Value_kind_oneof_t::bool_value;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $e->writeTag(4, 0);;
    $e->writeBool($this->bool_value);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeBool('bool_value', 'boolValue', $this->bool_value, true);
  }

  public function Copy(): Value_kind {
    return new Value_kind_bool_value($this->bool_value);
  }
}

class Value_kind_struct_value implements Value_kind {
  public function __construct(public \google\protobuf\Struct $struct_value) {}

  public function WhichOneof(): Value_kind_oneof_t {
    return Value_kind_oneof_t::struct_value;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->struct_value->WriteTo($nested);
    $e->writeEncoder($nested, 5);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('struct_value', 'structValue', $this->struct_value, true);
  }

  public function Copy(): Value_kind {
    $nv = new \google\protobuf\Struct();
    $nv->CopyFrom($this->struct_value);
    return new Value_kind_struct_value($nv);
  }
}

class Value_kind_list_value implements Value_kind {
  public function __construct(public \google\protobuf\ListValue $list_value) {}

  public function WhichOneof(): Value_kind_oneof_t {
    return Value_kind_oneof_t::list_value;
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $nested = new \Protobuf\Internal\Encoder();
    $this->list_value->WriteTo($nested);
    $e->writeEncoder($nested, 6);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('list_value', 'listValue', $this->list_value, true);
  }

  public function Copy(): Value_kind {
    $nv = new \google\protobuf\ListValue();
    $nv->CopyFrom($this->list_value);
    return new Value_kind_list_value($nv);
  }
}

class Value implements \Protobuf\Message {
  public Value_kind $kind;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'kind' => Value_kind,
  ) $s = shape()) {
    $this->kind = $s['kind'] ?? new Value_kind_NOT_SET();
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Value";
  }

  public static function ParseFrom(string $input): ?Value {
    $msg = new Value();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->kind = new Value_kind_null_value(\google\protobuf\NullValue::FromInt($d->readVarint()));
          break;
        case 2:
          $this->kind = new Value_kind_number_value($d->readDouble());
          break;
        case 3:
          $this->kind = new Value_kind_string_value($d->readString());
          break;
        case 4:
          $this->kind = new Value_kind_bool_value($d->readBool());
          break;
        case 5:
          if ($this->kind->WhichOneof() == Value_kind_oneof_t::struct_value) {
            ($this->kind as Value_kind_struct_value)->struct_value->MergeFrom($d->readDecoder());
          } else {
            $obj = new \google\protobuf\Struct();
            $obj->MergeFrom($d->readDecoder());
            $this->kind = new Value_kind_struct_value($obj);
          }
          break;
        case 6:
          if ($this->kind->WhichOneof() == Value_kind_oneof_t::list_value) {
            ($this->kind as Value_kind_list_value)->list_value->MergeFrom($d->readDecoder());
          } else {
            $obj = new \google\protobuf\ListValue();
            $obj->MergeFrom($d->readDecoder());
            $this->kind = new Value_kind_list_value($obj);
          }
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $this->kind->WriteTo($e);
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->kind is \google\protobuf\Value_kind_null_value) {
      $e->setCustomEncoding(null);
      return;
    }
    if ($this->kind is \google\protobuf\Value_kind_number_value) {
      $e->setCustomEncoding($this->kind->number_value);
      return;
    }
    if ($this->kind is \google\protobuf\Value_kind_string_value) {
      $e->setCustomEncoding($this->kind->string_value);
      return;
    }
    if ($this->kind is \google\protobuf\Value_kind_bool_value) {
      $e->setCustomEncoding($this->kind->bool_value);
      return;
    }
    if ($this->kind is \google\protobuf\Value_kind_list_value) {
      $e->setCustomEncoding($e->encodeMessage($this->kind->list_value));
      return;
    }
    if ($this->kind is \google\protobuf\Value_kind_struct_value) {
      $e->setCustomEncoding($e->encodeMessage($this->kind->struct_value));
      return;
    }
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) {
      $this->kind = new \google\protobuf\Value_kind_null_value(\google\protobuf\NullValue::NULL_VALUE);
    } else if ($m is string) {
      $this->kind = new \google\protobuf\Value_kind_string_value($m);
    } else if ($m is bool) {
      $this->kind = new \google\protobuf\Value_kind_bool_value($m);
    } else if (\is_numeric($m)) {
      $this->kind = new \google\protobuf\Value_kind_number_value((float)$m);
    } else if ($m is vec<_>) {
      $lv = new \google\protobuf\ListValue();
      $lv->MergeJsonFrom($m);
      $this->kind = new \google\protobuf\Value_kind_list_value($lv);
    } else if ($m is dict<_,_>) {
      $struct = new \google\protobuf\Struct();
      $struct->MergeJsonFrom($m);
      $this->kind = new \google\protobuf\Value_kind_struct_value($struct);
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Value)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->kind = $o->kind->Copy();
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class ListValue implements \Protobuf\Message {
  public vec<\google\protobuf\Value> $values;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'values' => vec<\google\protobuf\Value>,
  ) $s = shape()) {
    $this->values = $s['values'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.ListValue";
  }

  public static function ParseFrom(string $input): ?ListValue {
    $msg = new ListValue();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $obj = new \google\protobuf\Value();
          $obj->MergeFrom($d->readDecoder());
          $this->values []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    foreach ($this->values as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $vec = vec[];
    foreach ($this->values as $lv) {
      $vec []= $e->encodeMessage($lv);
    }
    $e->setCustomEncoding($vec);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m is vec<_>) {
      foreach ($m as $vv) {
        $val = new \google\protobuf\Value();
        $val->MergeJsonFrom($vv);
        $this->values []= $val;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is ListValue)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    foreach ($o->values as $v) {
      $nv = new \google\protobuf\Value();
      $nv->CopyFrom($v);
      $this->values []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_struct__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/struct.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 1564 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\x74\x92\xc1\x8b\xd3\x40\x14\xc6\x3b\xc9\x36\x98\x17\x59\x97\x11\xb4\xac\xa2\xa1\x7b\x9\x22\x9\xd4\x8b\x58\x2f\x6\xd6\x2d\x18\x4a\x8c\xb6\x82\x97\xd2\xa4\x69\x8\x9d\xce\x94\x64\x46\xe9\xc9\x7f\xc3\xb3\x47\x8f\xfe\x75\x1e\x65\x66\x92\x54\x5a\x7a\xcb\x7b\xef\xf7\x7d\x33\xdf\xcb\xc0\xd3\x82\xb1\x82\xe4\xc1\xae\x62\x9c\xa5\x62\x1d\xd4\xbc\x12\x19\xf7\x55\x8d\x1f\xe8\xa9\xdf\x4e\x87\x3f\x11\x58\x9f\x14\x81\xc7\x60\xad\xcb\x9c\xac\xea\x1\x72\x4d\xcf\x19\xdd\xf8\x47\xb0\xaf\x41\xff\xbd\xa2\x6e\x29\xaf\xf6\x49\x23\xb9\xfe\x8\xce\x7f\x6d\x7c\x5\xe6\x26\xdf\xf\x90\x8b\x3c\x3b\x91\x9f\xf8\x25\xf4\xbf\x2d\x89\xc8\x7\x86\x8b\x3c\x67\xf4\xe8\xc4\x7c\x2e\xa7\x89\x86\xde\x18\xaf\xd1\xf0\x8f\x1\x7d\xd5\xc4\x63\x0\x2a\x8\x59\x68\x3\x69\x7a\x39\xba\x3e\x31\x98\xa\x42\x14\x3f\xe9\x25\x36\x6d\xb\x7c\x3\xf7\xa9\xd8\xa6\x79\xb5\x38\x9c\x8f\x26\xbd\xc4\xd1\xdd\xe\xaa\x79\x55\xd2\xa2\x81\x4c\x79\x71\x9\xe9\xae\x86\x9e\x3\xa4\x8c\xb5\xd7\xb8\x70\x91\x77\x4f\x1e\x25\x7b\x1a\x78\xab\x5c\x44\xc6\x1b\xa4\xaf\xa2\x3e\x3e\xb3\xc7\xc6\x5e\x64\xbc\x4b\x49\xca\xba\xd5\x5a\x4a\x7b\x9a\x32\x2a\x6b\xde\xa5\x24\x6d\x11\x5a\x70\xb1\x29\xe9\x6a\x38\x6\xbb\x23\xb0\xf\x96\x32\x6b\xff\xe8\xb9\xa5\x37\xd4\x8b\x27\x60\x77\x4b\xc4\x97\x0\xd3\x59\x14\x2d\xe6\xef\xa2\xd9\xed\x55\x2f\xfc\x1\xf\x33\xb6\x3d\x76\x8\x1d\x1d\x26\x96\x75\x8c\xbe\x6\xcd\xbc\x60\x64\x49\xb\x9f\x55\xc5\xe1\x25\xf2\xfd\x2e\xaf\x83\xd\x65\xdf\x69\xf3\x2a\x77\xe9\x5f\x84\x7e\x19\xe6\x5d\x1c\xfe\x36\x9e\xdd\x69\x69\xdc\x5e\xee\x4b\x4e\xc8\x7\x49\x7f\x96\xc2\xd4\x52\x46\xaf\xfe\x5\x0\x0\xff\xff\xc7\xb4\xec\xb8");
  }
}
