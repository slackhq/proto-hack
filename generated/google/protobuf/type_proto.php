<?hh // strict
namespace google\protobuf;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/type.proto

newtype Syntax_enum_t as int = int;
abstract class Syntax {
  const Syntax_enum_t SYNTAX_PROTO2 = 0;
  const Syntax_enum_t SYNTAX_PROTO3 = 1;
  const Syntax_enum_t SYNTAX_EDITIONS = 2;
  private static dict<int, string> $itos = dict[
    0 => 'SYNTAX_PROTO2',
    1 => 'SYNTAX_PROTO3',
    2 => 'SYNTAX_EDITIONS',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'SYNTAX_PROTO2' => 0,
    'SYNTAX_PROTO3' => 1,
    'SYNTAX_EDITIONS' => 2,
  ];
  public static function FromMixed(mixed $m): Syntax_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): Syntax_enum_t {
    return $i;
  }
}

class Type implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\Field> $fields;
  public vec<string> $oneofs;
  public vec<\google\protobuf\Option> $options;
  public ?\google\protobuf\SourceContext $source_context;
  public \google\protobuf\Syntax_enum_t $syntax;
  public string $edition;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'fields' => vec<\google\protobuf\Field>,
    ?'oneofs' => vec<string>,
    ?'options' => vec<\google\protobuf\Option>,
    ?'source_context' => ?\google\protobuf\SourceContext,
    ?'syntax' => \google\protobuf\Syntax_enum_t,
    ?'edition' => string,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->fields = $s['fields'] ?? vec[];
    $this->oneofs = $s['oneofs'] ?? vec[];
    $this->options = $s['options'] ?? vec[];
    $this->source_context = $s['source_context'] ?? null;
    $this->syntax = $s['syntax'] ?? \google\protobuf\Syntax::FromInt(0);
    $this->edition = $s['edition'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Type";
  }

  public static function ParseFrom(string $input): ?Type {
    $msg = new Type();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\Field();
          $obj->MergeFrom($d->readDecoder());
          $this->fields []= $obj;
          break;
        case 3:
          $this->oneofs []= $d->readString();
          break;
        case 4:
          $obj = new \google\protobuf\Option();
          $obj->MergeFrom($d->readDecoder());
          $this->options []= $obj;
          break;
        case 5:
          if ($this->source_context is null) {
            $this->source_context = new \google\protobuf\SourceContext();
          }
          $this->source_context->MergeFrom($d->readDecoder());
          break;
        case 6:
          $this->syntax = \google\protobuf\Syntax::FromInt($d->readVarint());
          break;
        case 7:
          $this->edition = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->fields as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    foreach ($this->oneofs as $elem) {
      $e->writeTag(3, 2);
      $e->writeString($elem);
    }
    foreach ($this->options as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    $msg = $this->source_context;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    if ($this->syntax !== \google\protobuf\Syntax::FromInt(0)) {
      $e->writeTag(6, 0);
      $e->writeVarint($this->syntax);
    }
    if ($this->edition !== '') {
      $e->writeTag(7, 2);
      $e->writeString($this->edition);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('fields', 'fields', $this->fields);
    $e->writePrimitiveList('oneofs', 'oneofs', $this->oneofs);
    $e->writeMessageList('options', 'options', $this->options);
    $e->writeMessage('source_context', 'sourceContext', $this->source_context, false);
    $e->writeEnum('syntax', 'syntax', \google\protobuf\Syntax::ToStringDict(), $this->syntax, false);
    $e->writeString('edition', 'edition', $this->edition, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'fields':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Field();
            $obj->MergeJsonFrom($vv);
            $this->fields []= $obj;
          }
          break;
        case 'oneofs':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $this->oneofs []= \Protobuf\Internal\JsonDecoder::readString($vv);
          }
          break;
        case 'options':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Option();
            $obj->MergeJsonFrom($vv);
            $this->options []= $obj;
          }
          break;
        case 'source_context': case 'sourceContext':
          if ($v is null) break;
          if ($this->source_context is null) {
            $this->source_context = new \google\protobuf\SourceContext();
          }
          $this->source_context->MergeJsonFrom($v);
          break;
        case 'syntax':
          $this->syntax = \google\protobuf\Syntax::FromMixed($v);
          break;
        case 'edition':
          $this->edition = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Type)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    foreach ($o->fields as $v) {
      $nv = new \google\protobuf\Field();
      $nv->CopyFrom($v);
      $this->fields []= $nv;
    }
    $this->oneofs = $o->oneofs;
    foreach ($o->options as $v) {
      $nv = new \google\protobuf\Option();
      $nv->CopyFrom($v);
      $this->options []= $nv;
    }
    $tmp = $o->source_context;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\SourceContext();
      $nv->CopyFrom($tmp);
      $this->source_context = $nv;
    }
    $this->syntax = $o->syntax;
    $this->edition = $o->edition;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

newtype Field_Kind_enum_t as int = int;
abstract class Field_Kind {
  const Field_Kind_enum_t TYPE_UNKNOWN = 0;
  const Field_Kind_enum_t TYPE_DOUBLE = 1;
  const Field_Kind_enum_t TYPE_FLOAT = 2;
  const Field_Kind_enum_t TYPE_INT64 = 3;
  const Field_Kind_enum_t TYPE_UINT64 = 4;
  const Field_Kind_enum_t TYPE_INT32 = 5;
  const Field_Kind_enum_t TYPE_FIXED64 = 6;
  const Field_Kind_enum_t TYPE_FIXED32 = 7;
  const Field_Kind_enum_t TYPE_BOOL = 8;
  const Field_Kind_enum_t TYPE_STRING = 9;
  const Field_Kind_enum_t TYPE_GROUP = 10;
  const Field_Kind_enum_t TYPE_MESSAGE = 11;
  const Field_Kind_enum_t TYPE_BYTES = 12;
  const Field_Kind_enum_t TYPE_UINT32 = 13;
  const Field_Kind_enum_t TYPE_ENUM = 14;
  const Field_Kind_enum_t TYPE_SFIXED32 = 15;
  const Field_Kind_enum_t TYPE_SFIXED64 = 16;
  const Field_Kind_enum_t TYPE_SINT32 = 17;
  const Field_Kind_enum_t TYPE_SINT64 = 18;
  private static dict<int, string> $itos = dict[
    0 => 'TYPE_UNKNOWN',
    1 => 'TYPE_DOUBLE',
    2 => 'TYPE_FLOAT',
    3 => 'TYPE_INT64',
    4 => 'TYPE_UINT64',
    5 => 'TYPE_INT32',
    6 => 'TYPE_FIXED64',
    7 => 'TYPE_FIXED32',
    8 => 'TYPE_BOOL',
    9 => 'TYPE_STRING',
    10 => 'TYPE_GROUP',
    11 => 'TYPE_MESSAGE',
    12 => 'TYPE_BYTES',
    13 => 'TYPE_UINT32',
    14 => 'TYPE_ENUM',
    15 => 'TYPE_SFIXED32',
    16 => 'TYPE_SFIXED64',
    17 => 'TYPE_SINT32',
    18 => 'TYPE_SINT64',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'TYPE_UNKNOWN' => 0,
    'TYPE_DOUBLE' => 1,
    'TYPE_FLOAT' => 2,
    'TYPE_INT64' => 3,
    'TYPE_UINT64' => 4,
    'TYPE_INT32' => 5,
    'TYPE_FIXED64' => 6,
    'TYPE_FIXED32' => 7,
    'TYPE_BOOL' => 8,
    'TYPE_STRING' => 9,
    'TYPE_GROUP' => 10,
    'TYPE_MESSAGE' => 11,
    'TYPE_BYTES' => 12,
    'TYPE_UINT32' => 13,
    'TYPE_ENUM' => 14,
    'TYPE_SFIXED32' => 15,
    'TYPE_SFIXED64' => 16,
    'TYPE_SINT32' => 17,
    'TYPE_SINT64' => 18,
  ];
  public static function FromMixed(mixed $m): Field_Kind_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): Field_Kind_enum_t {
    return $i;
  }
}

newtype Field_Cardinality_enum_t as int = int;
abstract class Field_Cardinality {
  const Field_Cardinality_enum_t CARDINALITY_UNKNOWN = 0;
  const Field_Cardinality_enum_t CARDINALITY_OPTIONAL = 1;
  const Field_Cardinality_enum_t CARDINALITY_REQUIRED = 2;
  const Field_Cardinality_enum_t CARDINALITY_REPEATED = 3;
  private static dict<int, string> $itos = dict[
    0 => 'CARDINALITY_UNKNOWN',
    1 => 'CARDINALITY_OPTIONAL',
    2 => 'CARDINALITY_REQUIRED',
    3 => 'CARDINALITY_REPEATED',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'CARDINALITY_UNKNOWN' => 0,
    'CARDINALITY_OPTIONAL' => 1,
    'CARDINALITY_REQUIRED' => 2,
    'CARDINALITY_REPEATED' => 3,
  ];
  public static function FromMixed(mixed $m): Field_Cardinality_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): Field_Cardinality_enum_t {
    return $i;
  }
}

class Field implements \Protobuf\Message {
  public \google\protobuf\Field_Kind_enum_t $kind;
  public \google\protobuf\Field_Cardinality_enum_t $cardinality;
  public int $number;
  public string $name;
  public string $type_url;
  public int $oneof_index;
  public bool $packed;
  public vec<\google\protobuf\Option> $options;
  public string $json_name;
  public string $default_value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'kind' => \google\protobuf\Field_Kind_enum_t,
    ?'cardinality' => \google\protobuf\Field_Cardinality_enum_t,
    ?'number' => int,
    ?'name' => string,
    ?'type_url' => string,
    ?'oneof_index' => int,
    ?'packed' => bool,
    ?'options' => vec<\google\protobuf\Option>,
    ?'json_name' => string,
    ?'default_value' => string,
  ) $s = shape()) {
    $this->kind = $s['kind'] ?? \google\protobuf\Field_Kind::FromInt(0);
    $this->cardinality = $s['cardinality'] ?? \google\protobuf\Field_Cardinality::FromInt(0);
    $this->number = $s['number'] ?? 0;
    $this->name = $s['name'] ?? '';
    $this->type_url = $s['type_url'] ?? '';
    $this->oneof_index = $s['oneof_index'] ?? 0;
    $this->packed = $s['packed'] ?? false;
    $this->options = $s['options'] ?? vec[];
    $this->json_name = $s['json_name'] ?? '';
    $this->default_value = $s['default_value'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Field";
  }

  public static function ParseFrom(string $input): ?Field {
    $msg = new Field();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->kind = \google\protobuf\Field_Kind::FromInt($d->readVarint());
          break;
        case 2:
          $this->cardinality = \google\protobuf\Field_Cardinality::FromInt($d->readVarint());
          break;
        case 3:
          $this->number = $d->readVarint32Signed();
          break;
        case 4:
          $this->name = $d->readString();
          break;
        case 6:
          $this->type_url = $d->readString();
          break;
        case 7:
          $this->oneof_index = $d->readVarint32Signed();
          break;
        case 8:
          $this->packed = $d->readBool();
          break;
        case 9:
          $obj = new \google\protobuf\Option();
          $obj->MergeFrom($d->readDecoder());
          $this->options []= $obj;
          break;
        case 10:
          $this->json_name = $d->readString();
          break;
        case 11:
          $this->default_value = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->kind !== \google\protobuf\Field_Kind::FromInt(0)) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->kind);
    }
    if ($this->cardinality !== \google\protobuf\Field_Cardinality::FromInt(0)) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->cardinality);
    }
    if ($this->number !== 0) {
      $e->writeTag(3, 0);
      $e->writeVarint($this->number);
    }
    if ($this->name !== '') {
      $e->writeTag(4, 2);
      $e->writeString($this->name);
    }
    if ($this->type_url !== '') {
      $e->writeTag(6, 2);
      $e->writeString($this->type_url);
    }
    if ($this->oneof_index !== 0) {
      $e->writeTag(7, 0);
      $e->writeVarint($this->oneof_index);
    }
    if ($this->packed !== false) {
      $e->writeTag(8, 0);
      $e->writeBool($this->packed);
    }
    foreach ($this->options as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 9);
    }
    if ($this->json_name !== '') {
      $e->writeTag(10, 2);
      $e->writeString($this->json_name);
    }
    if ($this->default_value !== '') {
      $e->writeTag(11, 2);
      $e->writeString($this->default_value);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeEnum('kind', 'kind', \google\protobuf\Field_Kind::ToStringDict(), $this->kind, false);
    $e->writeEnum('cardinality', 'cardinality', \google\protobuf\Field_Cardinality::ToStringDict(), $this->cardinality, false);
    $e->writeInt32('number', 'number', $this->number, false);
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('type_url', 'typeUrl', $this->type_url, false);
    $e->writeInt32('oneof_index', 'oneofIndex', $this->oneof_index, false);
    $e->writeBool('packed', 'packed', $this->packed, false);
    $e->writeMessageList('options', 'options', $this->options);
    $e->writeString('json_name', 'jsonName', $this->json_name, false);
    $e->writeString('default_value', 'defaultValue', $this->default_value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'kind':
          $this->kind = \google\protobuf\Field_Kind::FromMixed($v);
          break;
        case 'cardinality':
          $this->cardinality = \google\protobuf\Field_Cardinality::FromMixed($v);
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'type_url': case 'typeUrl':
          $this->type_url = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'oneof_index': case 'oneofIndex':
          $this->oneof_index = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'packed':
          $this->packed = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'options':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Option();
            $obj->MergeJsonFrom($vv);
            $this->options []= $obj;
          }
          break;
        case 'json_name': case 'jsonName':
          $this->json_name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'default_value': case 'defaultValue':
          $this->default_value = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Field)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->kind = $o->kind;
    $this->cardinality = $o->cardinality;
    $this->number = $o->number;
    $this->name = $o->name;
    $this->type_url = $o->type_url;
    $this->oneof_index = $o->oneof_index;
    $this->packed = $o->packed;
    foreach ($o->options as $v) {
      $nv = new \google\protobuf\Option();
      $nv->CopyFrom($v);
      $this->options []= $nv;
    }
    $this->json_name = $o->json_name;
    $this->default_value = $o->default_value;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class pb_Enum implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\EnumValue> $enumvalue;
  public vec<\google\protobuf\Option> $options;
  public ?\google\protobuf\SourceContext $source_context;
  public \google\protobuf\Syntax_enum_t $syntax;
  public string $edition;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'enumvalue' => vec<\google\protobuf\EnumValue>,
    ?'options' => vec<\google\protobuf\Option>,
    ?'source_context' => ?\google\protobuf\SourceContext,
    ?'syntax' => \google\protobuf\Syntax_enum_t,
    ?'edition' => string,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->enumvalue = $s['enumvalue'] ?? vec[];
    $this->options = $s['options'] ?? vec[];
    $this->source_context = $s['source_context'] ?? null;
    $this->syntax = $s['syntax'] ?? \google\protobuf\Syntax::FromInt(0);
    $this->edition = $s['edition'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Enum";
  }

  public static function ParseFrom(string $input): ?pb_Enum {
    $msg = new pb_Enum();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\EnumValue();
          $obj->MergeFrom($d->readDecoder());
          $this->enumvalue []= $obj;
          break;
        case 3:
          $obj = new \google\protobuf\Option();
          $obj->MergeFrom($d->readDecoder());
          $this->options []= $obj;
          break;
        case 4:
          if ($this->source_context is null) {
            $this->source_context = new \google\protobuf\SourceContext();
          }
          $this->source_context->MergeFrom($d->readDecoder());
          break;
        case 5:
          $this->syntax = \google\protobuf\Syntax::FromInt($d->readVarint());
          break;
        case 6:
          $this->edition = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->enumvalue as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    foreach ($this->options as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    $msg = $this->source_context;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 4);
    }
    if ($this->syntax !== \google\protobuf\Syntax::FromInt(0)) {
      $e->writeTag(5, 0);
      $e->writeVarint($this->syntax);
    }
    if ($this->edition !== '') {
      $e->writeTag(6, 2);
      $e->writeString($this->edition);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('enumvalue', 'enumvalue', $this->enumvalue);
    $e->writeMessageList('options', 'options', $this->options);
    $e->writeMessage('source_context', 'sourceContext', $this->source_context, false);
    $e->writeEnum('syntax', 'syntax', \google\protobuf\Syntax::ToStringDict(), $this->syntax, false);
    $e->writeString('edition', 'edition', $this->edition, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'enumvalue':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\EnumValue();
            $obj->MergeJsonFrom($vv);
            $this->enumvalue []= $obj;
          }
          break;
        case 'options':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Option();
            $obj->MergeJsonFrom($vv);
            $this->options []= $obj;
          }
          break;
        case 'source_context': case 'sourceContext':
          if ($v is null) break;
          if ($this->source_context is null) {
            $this->source_context = new \google\protobuf\SourceContext();
          }
          $this->source_context->MergeJsonFrom($v);
          break;
        case 'syntax':
          $this->syntax = \google\protobuf\Syntax::FromMixed($v);
          break;
        case 'edition':
          $this->edition = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is pb_Enum)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    foreach ($o->enumvalue as $v) {
      $nv = new \google\protobuf\EnumValue();
      $nv->CopyFrom($v);
      $this->enumvalue []= $nv;
    }
    foreach ($o->options as $v) {
      $nv = new \google\protobuf\Option();
      $nv->CopyFrom($v);
      $this->options []= $nv;
    }
    $tmp = $o->source_context;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\SourceContext();
      $nv->CopyFrom($tmp);
      $this->source_context = $nv;
    }
    $this->syntax = $o->syntax;
    $this->edition = $o->edition;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class EnumValue implements \Protobuf\Message {
  public string $name;
  public int $number;
  public vec<\google\protobuf\Option> $options;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'number' => int,
    ?'options' => vec<\google\protobuf\Option>,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->number = $s['number'] ?? 0;
    $this->options = $s['options'] ?? vec[];
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.EnumValue";
  }

  public static function ParseFrom(string $input): ?EnumValue {
    $msg = new EnumValue();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->number = $d->readVarint32Signed();
          break;
        case 3:
          $obj = new \google\protobuf\Option();
          $obj->MergeFrom($d->readDecoder());
          $this->options []= $obj;
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->number !== 0) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->number);
    }
    foreach ($this->options as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeInt32('number', 'number', $this->number, false);
    $e->writeMessageList('options', 'options', $this->options);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'number':
          $this->number = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        case 'options':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Option();
            $obj->MergeJsonFrom($vv);
            $this->options []= $obj;
          }
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is EnumValue)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $this->number = $o->number;
    foreach ($o->options as $v) {
      $nv = new \google\protobuf\Option();
      $nv->CopyFrom($v);
      $this->options []= $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class Option implements \Protobuf\Message {
  public string $name;
  public ?\google\protobuf\Any $value;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'value' => ?\google\protobuf\Any,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->value = $s['value'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Option";
  }

  public static function ParseFrom(string $input): ?Option {
    $msg = new Option();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          if ($this->value is null) {
            $this->value = new \google\protobuf\Any();
          }
          $this->value->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    $msg = $this->value;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessage('value', 'value', $this->value, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'value':
          if ($v is null) break;
          if ($this->value is null) {
            $this->value = new \google\protobuf\Any();
          }
          $this->value->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Option)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $tmp = $o->value;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\Any();
      $nv->CopyFrom($tmp);
      $this->value = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_type__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/type.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 3234 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\xa4\x55\x4f\x6f\xe2\x46\x14\x5f\x1b\x63\xf0\x23\x90\xd9\xc9\x6a\xd7\x9b\x95\xb6\x88\xf6\x80\x56\x2a\xa8\x10\x45\xbd\x42\x70\xa8\x15\xd6\x76\x7\xd3\xdd\xf4\x82\x1c\x98\x20\x36\x66\x8c\xb0\x69\x83\xfa\x49\x7a\xed\xa5\x52\xcf\xfd\x10\xfd\x48\x3d\x56\x33\x6\x63\xfe\x54\x6a\xba\x37\xbf\xdf\xfb\xbd\xff\xcf\x6f\xe0\x7c\x12\x4\x13\x9f\xd6\xe7\x8b\x20\xa\xee\x96\xf7\xf5\x68\x35\xa7\x35\x21\xe1\xd3\x58\x57\xdb\xe8\xce\x5f\xef\x93\x3d\xb6\x8a\xb5\xe7\x5f\xed\xab\xc2\x60\xb9\x18\xd1\xe1\x28\x60\x11\x7d\x8c\x62\x56\xe5\x77\x19\x14\x77\x35\xa7\x18\x83\xc2\xbc\x19\xd5\xa5\xb2\x54\xd5\x88\xf8\xc6\x35\x50\xef\xa7\xd4\x1f\x87\xba\x5c\xce\x54\xb\x8d\x97\xb5\xbd\xf8\xb5\x6b\xae\x26\x6b\x16\x7e\x9\x6a\xc0\x68\x70\x1f\xea\x99\x72\xa6\xaa\x91\xb5\x84\xbf\x81\x5c\x30\x8f\xa6\x1\xb\x75\x45\x38\x7a\x75\xe0\xc8\x16\x7a\xb2\xe1\x61\x3\x4a\xbb\xf9\xea\xd9\xb2\x54\x2d\x34\xde\x1e\x58\xf6\x5\xed\x2a\x66\x91\x62\x98\x16\x71\x1d\xd4\x70\xc5\x22\xef\x51\x57\xcb\x52\xb5\x74\x24\x70\x5f\xa8\xc9\x9a\x86\x75\xc8\xd1\xf1\x94\xe7\xa0\xe7\x44\x27\x36\x62\xe5\x4f\x15\xb2\xa2\x5c\x5c\x7\xe5\x61\xca\xc6\xa2\x55\xa5\xc6\x9b\xe3\x4d\xa9\xdd\x4c\xd9\x98\x8\x22\xee\x40\x61\xe4\x2d\xc6\x53\xe6\xf9\xd3\x68\xa5\xcb\xc2\xae\xf2\x2f\x76\x57\x5b\x26\x49\x9b\xf1\xee\xb2\xe5\xec\x8e\x2e\xf4\x4c\x59\xaa\x66\xc9\x5a\x4a\x26\xa7\xa4\x26\xf7\x1a\xf2\x7c\x6d\x86\xcb\x85\x2f\x2a\xd7\x48\x8e\xcb\x83\x85\x8f\xbf\x80\x82\x18\xcb\x70\xca\xc6\xf4\x51\x54\x99\x25\x20\x20\x93\x23\x3c\xce\xdc\x1b\x3d\xd0\xb1\x9e\x2f\x4b\xd5\x3c\x59\x4b\xe9\x29\x6a\xff\x71\x8a\x6f\x40\xfb\x14\x6\x6c\x28\xf2\x3\x91\x47\x9e\x3\x16\xcf\xf1\x4b\x28\x8e\xe9\xbd\xb7\xf4\xa3\xe1\x4f\x9e\xbf\xa4\x7a\x41\x10\x4e\xd6\xe0\xf\x1c\xab\xfc\x25\x83\xc2\x3b\x89\x11\x9c\xb8\xb7\x8e\x31\x1c\x58\x37\x96\xfd\xc1\x42\xcf\xf0\x29\x14\x4\xd2\xb1\x7\xed\x9e\x81\x24\x5c\x2\x10\xc0\x75\xcf\x6e\xb9\x48\x4e\x64\xd3\x72\x2f\x2f\x50\x26\x31\x18\xc4\x80\x92\x26\x34\x1b\x28\x9b\xc4\xb8\x36\x3f\x1a\x9d\xcb\xb\xa4\xee\x22\xcd\x6\xca\xe1\x22\x68\x2\x69\xdb\x76\xf\xe5\x13\x9f\x7d\x97\x98\x56\x17\x69\x89\xcf\x2e\xb1\x7\xe\x82\xc4\xc3\x7b\xa3\xdf\x6f\x75\xd\x54\x48\x18\xed\x5b\xd7\xe8\xa3\x93\x9d\xb4\x9a\xd\x54\x4c\x42\x18\xd6\xe0\x3d\x2a\xe1\xe7\x50\x8c\x43\x6c\x92\x38\xdd\x83\x2e\x2f\x10\xda\x26\x12\x7b\x79\xbe\x3\x5c\x5e\x20\x5c\x89\xa0\x90\xda\x2d\xfc\xa\xce\xae\x5a\xa4\x63\x5a\xad\x9e\xe9\xde\xa6\xfa\xaa\xc3\x8b\xb4\xc2\x76\x5c\xd3\xb6\x5a\x3d\x24\xed\x6b\x88\xf1\xfd\xc0\x24\x46\x7\xc9\x87\x1a\xc7\x68\xb9\x46\x7\x65\x2a\xbf\xca\xa0\x18\x6c\x39\x3b\x7a\x60\xbe\x5\x8d\xb2\xe5\x2c\x1e\x7f\x7c\x63\xce\xf\x96\x8a\x5b\x8b\x65\x20\x5b\x72\x7a\x19\x33\xff\xfb\xa4\x28\x9f\x77\x52\xb2\x4f\x3e\x29\xea\xee\x49\xf9\x4\x5a\x52\xdc\xd1\xfe\x6c\x7f\x79\x79\xe7\x97\x7f\x7a\xf5\x95\xef\x40\x8d\xa1\xa3\x81\xde\x41\x76\x33\x4\xde\x92\x17\x7\xee\x5a\x6c\x45\x62\xca\xbb\x2b\x50\xe3\xa\xf9\x1a\xf6\x6f\x2d\xb7\xf5\x71\xe8\x10\xdb\xb5\x1b\xe8\xd9\x3e\xd4\x44\x12\x3e\x83\xd3\x35\x64\x74\x4c\xbe\x4b\x7d\x24\xb7\x7f\x81\xb3\x51\x30\xdb\xf\xd3\xd6\xf8\x5b\xe4\x70\xc9\x91\x7e\xfc\x7a\xad\x9d\x4\xbe\xc7\x26\xb5\x60\x31\xd9\x7d\x14\xc3\xfa\x3\xb\x7e\x66\xe2\x7b\x7e\xf7\xb7\x24\xfd\x26\x67\xba\x4e\xfb\xf\xf9\x6d\x37\x36\x74\x36\xd9\x7f\xa0\xbe\x7f\xc3\xb9\xdc\x7d\x78\xa7\xa\x37\xcd\x7f\x2\x0\x0\xff\xff\x5d\xf4\x26\xf5");
  }
}
