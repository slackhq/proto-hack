<?hh // strict
namespace google\protobuf;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: google/protobuf/api.proto

class Api implements \Protobuf\Message {
  public string $name;
  public vec<\google\protobuf\Method> $methods;
  public vec<\google\protobuf\Option> $options;
  public string $version;
  public ?\google\protobuf\SourceContext $source_context;
  public vec<\google\protobuf\Mixin> $mixins;
  public \google\protobuf\Syntax_enum_t $syntax;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'methods' => vec<\google\protobuf\Method>,
    ?'options' => vec<\google\protobuf\Option>,
    ?'version' => string,
    ?'source_context' => ?\google\protobuf\SourceContext,
    ?'mixins' => vec<\google\protobuf\Mixin>,
    ?'syntax' => \google\protobuf\Syntax_enum_t,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->methods = $s['methods'] ?? vec[];
    $this->options = $s['options'] ?? vec[];
    $this->version = $s['version'] ?? '';
    $this->source_context = $s['source_context'] ?? null;
    $this->mixins = $s['mixins'] ?? vec[];
    $this->syntax = $s['syntax'] ?? \google\protobuf\Syntax::FromInt(0);
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Api";
  }

  public static function ParseFrom(string $input): ?Api {
    $msg = new Api();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $obj = new \google\protobuf\Method();
          $obj->MergeFrom($d->readDecoder());
          $this->methods []= $obj;
          break;
        case 3:
          $obj = new \google\protobuf\Option();
          $obj->MergeFrom($d->readDecoder());
          $this->options []= $obj;
          break;
        case 4:
          $this->version = $d->readString();
          break;
        case 5:
          if ($this->source_context is null) {
            $this->source_context = new \google\protobuf\SourceContext();
          }
          $this->source_context->MergeFrom($d->readDecoder());
          break;
        case 6:
          $obj = new \google\protobuf\Mixin();
          $obj->MergeFrom($d->readDecoder());
          $this->mixins []= $obj;
          break;
        case 7:
          $this->syntax = \google\protobuf\Syntax::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    foreach ($this->methods as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    foreach ($this->options as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 3);
    }
    if ($this->version !== '') {
      $e->writeTag(4, 2);
      $e->writeString($this->version);
    }
    $msg = $this->source_context;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 5);
    }
    foreach ($this->mixins as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    if ($this->syntax !== \google\protobuf\Syntax::FromInt(0)) {
      $e->writeTag(7, 0);
      $e->writeVarint($this->syntax);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeMessageList('methods', 'methods', $this->methods);
    $e->writeMessageList('options', 'options', $this->options);
    $e->writeString('version', 'version', $this->version, false);
    $e->writeMessage('source_context', 'sourceContext', $this->source_context, false);
    $e->writeMessageList('mixins', 'mixins', $this->mixins);
    $e->writeEnum('syntax', 'syntax', \google\protobuf\Syntax::ToStringDict(), $this->syntax, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'methods':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Method();
            $obj->MergeJsonFrom($vv);
            $this->methods []= $obj;
          }
          break;
        case 'options':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Option();
            $obj->MergeJsonFrom($vv);
            $this->options []= $obj;
          }
          break;
        case 'version':
          $this->version = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'source_context': case 'sourceContext':
          if ($v is null) break;
          if ($this->source_context is null) {
            $this->source_context = new \google\protobuf\SourceContext();
          }
          $this->source_context->MergeJsonFrom($v);
          break;
        case 'mixins':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Mixin();
            $obj->MergeJsonFrom($vv);
            $this->mixins []= $obj;
          }
          break;
        case 'syntax':
          $this->syntax = \google\protobuf\Syntax::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Api)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    foreach ($o->methods as $v) {
      $nv = new \google\protobuf\Method();
      $nv->CopyFrom($v);
      $this->methods []= $nv;
    }
    foreach ($o->options as $v) {
      $nv = new \google\protobuf\Option();
      $nv->CopyFrom($v);
      $this->options []= $nv;
    }
    $this->version = $o->version;
    $tmp = $o->source_context;
    if ($tmp is nonnull) {
      $nv = new \google\protobuf\SourceContext();
      $nv->CopyFrom($tmp);
      $this->source_context = $nv;
    }
    foreach ($o->mixins as $v) {
      $nv = new \google\protobuf\Mixin();
      $nv->CopyFrom($v);
      $this->mixins []= $nv;
    }
    $this->syntax = $o->syntax;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class Method implements \Protobuf\Message {
  public string $name;
  public string $request_type_url;
  public bool $request_streaming;
  public string $response_type_url;
  public bool $response_streaming;
  public vec<\google\protobuf\Option> $options;
  public \google\protobuf\Syntax_enum_t $syntax;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'request_type_url' => string,
    ?'request_streaming' => bool,
    ?'response_type_url' => string,
    ?'response_streaming' => bool,
    ?'options' => vec<\google\protobuf\Option>,
    ?'syntax' => \google\protobuf\Syntax_enum_t,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->request_type_url = $s['request_type_url'] ?? '';
    $this->request_streaming = $s['request_streaming'] ?? false;
    $this->response_type_url = $s['response_type_url'] ?? '';
    $this->response_streaming = $s['response_streaming'] ?? false;
    $this->options = $s['options'] ?? vec[];
    $this->syntax = $s['syntax'] ?? \google\protobuf\Syntax::FromInt(0);
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Method";
  }

  public static function ParseFrom(string $input): ?Method {
    $msg = new Method();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->request_type_url = $d->readString();
          break;
        case 3:
          $this->request_streaming = $d->readBool();
          break;
        case 4:
          $this->response_type_url = $d->readString();
          break;
        case 5:
          $this->response_streaming = $d->readBool();
          break;
        case 6:
          $obj = new \google\protobuf\Option();
          $obj->MergeFrom($d->readDecoder());
          $this->options []= $obj;
          break;
        case 7:
          $this->syntax = \google\protobuf\Syntax::FromInt($d->readVarint());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->request_type_url !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->request_type_url);
    }
    if ($this->request_streaming !== false) {
      $e->writeTag(3, 0);
      $e->writeBool($this->request_streaming);
    }
    if ($this->response_type_url !== '') {
      $e->writeTag(4, 2);
      $e->writeString($this->response_type_url);
    }
    if ($this->response_streaming !== false) {
      $e->writeTag(5, 0);
      $e->writeBool($this->response_streaming);
    }
    foreach ($this->options as $msg) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 6);
    }
    if ($this->syntax !== \google\protobuf\Syntax::FromInt(0)) {
      $e->writeTag(7, 0);
      $e->writeVarint($this->syntax);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('request_type_url', 'requestTypeUrl', $this->request_type_url, false);
    $e->writeBool('request_streaming', 'requestStreaming', $this->request_streaming, false);
    $e->writeString('response_type_url', 'responseTypeUrl', $this->response_type_url, false);
    $e->writeBool('response_streaming', 'responseStreaming', $this->response_streaming, false);
    $e->writeMessageList('options', 'options', $this->options);
    $e->writeEnum('syntax', 'syntax', \google\protobuf\Syntax::ToStringDict(), $this->syntax, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'request_type_url': case 'requestTypeUrl':
          $this->request_type_url = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'request_streaming': case 'requestStreaming':
          $this->request_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'response_type_url': case 'responseTypeUrl':
          $this->response_type_url = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'response_streaming': case 'responseStreaming':
          $this->response_streaming = \Protobuf\Internal\JsonDecoder::readBool($v);
          break;
        case 'options':
          foreach(\Protobuf\Internal\JsonDecoder::readList($v) as $vv) {
            $obj = new \google\protobuf\Option();
            $obj->MergeJsonFrom($vv);
            $this->options []= $obj;
          }
          break;
        case 'syntax':
          $this->syntax = \google\protobuf\Syntax::FromMixed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Method)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $this->request_type_url = $o->request_type_url;
    $this->request_streaming = $o->request_streaming;
    $this->response_type_url = $o->response_type_url;
    $this->response_streaming = $o->response_streaming;
    foreach ($o->options as $v) {
      $nv = new \google\protobuf\Option();
      $nv->CopyFrom($v);
      $this->options []= $nv;
    }
    $this->syntax = $o->syntax;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class Mixin implements \Protobuf\Message {
  public string $name;
  public string $root;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
    ?'root' => string,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->root = $s['root'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "google.protobuf.Mixin";
  }

  public static function ParseFrom(string $input): ?Mixin {
    $msg = new Mixin();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        case 2:
          $this->root = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    if ($this->root !== '') {
      $e->writeTag(2, 2);
      $e->writeString($this->root);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
    $e->writeString('root', 'root', $this->root, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        case 'root':
          $this->root = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Mixin)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $this->root = $o->root;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_google_protobuf_api__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'google/protobuf/api.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 1665 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\x94\x93\xcd\x8e\xd3\x30\x14\x85\x95\xa4\x4d\x7\x8f\xe8\x80\x91\xc0\x74\x31\x8a\x46\x2c\x22\x7e\x12\x31\x3c\xc1\x14\xa1\x59\x20\x44\x94\x82\x90\xd8\x54\x69\x31\xc1\x22\xf1\x35\xb6\x33\xb4\xaf\xc3\x92\x25\x6f\xc0\x9b\x21\x3b\x71\x7f\xd2\x22\xc1\xce\xd7\xe7\xbb\xa7\xf7\x1e\x37\xe8\x61\x9\x50\x56\x34\x15\x12\x34\x2c\x9a\xcf\x69\x21\x58\x62\xb\x7c\xd6\x4a\x89\x93\x26\x8f\xfa\xac\x82\x46\x2e\xe9\x7c\x9\x5c\xd3\x95\x6e\xc1\xc9\xa4\x4f\xe9\xb5\xe8\x4c\x2e\x7e\xfb\x28\xb8\x12\xc\x63\x34\xe0\x45\x4d\x89\x17\x79\xf1\xad\xdc\x9e\xf1\x73\x34\xaa\xa9\xfe\x2\x9f\x14\xf1\xa3\x20\x3e\xbd\x7c\x90\xf4\x6\x48\xde\x58\x3d\x77\x9c\x69\x1\xa1\x19\x70\x45\x82\xbf\xb4\xbc\xb5\x7a\xee\x38\x4c\xd0\xe8\x86\x4a\xc5\x80\x93\x81\xfd\x71\x57\xe2\x57\x68\xbc\xbf\xf\x19\x46\x5e\x7c\x7a\x79\x7e\xe0\x39\xb3\xd8\xcb\x96\xca\x6f\xab\xdd\x12\x27\x28\xac\xd9\x8a\x71\x45\x42\x3b\xd2\xfd\xc3\x2d\x8c\x9c\x77\x14\x4e\x51\xa8\xd6\x5c\x17\x2b\x32\x8a\xbc\x78\x7c\x64\x85\x99\x95\xf3\xe\xbb\xf8\xe5\xa3\xb0\xd\xe2\x68\x8c\x31\xba\x23\xe9\xb7\x86\x2a\x3d\x37\xc1\xcf\x1b\x59\x11\xdf\xea\xe3\xee\xfe\xdd\x5a\xd0\xf7\xb2\xc2\x4f\xd0\x5d\x47\x2a\x2d\x69\x51\x33\x5e\x92\x20\xf2\xe2\x93\xdc\x59\xcc\xdc\x3d\x7e\x6c\x60\x25\x80\x2b\xba\xf5\x6d\x13\x3c\x73\x82\x33\x7e\x86\xf0\x86\xdd\x3a\xf\xad\xf3\xc6\x65\x6b\xbd\xf3\x8a\xe1\x3f\xbe\xe2\x7f\x87\x96\xa2\xa1\x8d\xfd\x68\x64\x18\xd\x24\x80\xee\x62\xb2\xe7\xe9\xd\xba\xb7\x84\xba\x6f\x3b\x3d\xb9\x12\x2c\x33\x45\xe6\x7d\x7c\xda\x89\x25\x54\x5\x2f\x13\x90\xe5\xfe\x7f\x5e\xa5\x5f\x39\x7c\xe7\xe6\x8b\x12\x8b\x1f\x7e\x70\x9d\x4d\x7f\xfa\xe7\xd7\x6d\x53\xe6\x6\xfd\x40\xab\xea\xb5\xe1\x4c\x7a\x6a\x11\x5a\x8b\x17\x7f\x2\x0\x0\xff\xff\x35\x6b\x2c\x33");
  }
}
