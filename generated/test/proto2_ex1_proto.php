<?hh // strict
namespace bing\bong;

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: test/proto2_ex1.proto

newtype AEnum1_enum_t as int = int;
abstract class AEnum1 {
  const AEnum1_enum_t A = 3;
  const AEnum1_enum_t B = 1;
  const AEnum1_enum_t pb_CLASS = 10;
  private static dict<int, string> $itos = dict[
    3 => 'A',
    1 => 'B',
    10 => 'CLASS',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'A' => 3,
    'B' => 1,
    'CLASS' => 10,
  ];
  public static function FromMixed(mixed $m): AEnum1_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): AEnum1_enum_t {
    return $i;
  }
}

class example1 implements \Protobuf\Message {
  private \bing\bong\AEnum1_enum_t $enum_default;
  private bool $was_enum_default_set;
  private \bing\bong\AEnum1_enum_t $enum_custom;
  private bool $was_enum_custom_set;
  private float $adouble;
  private bool $was_adouble_set;
  private float $afloat;
  private bool $was_afloat_set;
  private bool $abool;
  private bool $was_abool_set;
  private string $astring;
  private bool $was_astring_set;
  private string $abytes;
  private bool $was_abytes_set;
  public string $required_field;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'enum_default' => \bing\bong\AEnum1_enum_t,
    ?'enum_custom' => \bing\bong\AEnum1_enum_t,
    ?'adouble' => float,
    ?'afloat' => float,
    ?'abool' => bool,
    ?'astring' => string,
    ?'abytes' => string,
    ?'required_field' => string,
  ) $s = shape()) {
    if (Shapes::keyExists($s, 'enum_default')) {
      $this->enum_default = $s['enum_default'];
      $this->was_enum_default_set = true;
    } else {
      $this->enum_default = \bing\bong\AEnum1::A;
      $this->was_enum_default_set = false;
    }
    if (Shapes::keyExists($s, 'enum_custom')) {
      $this->enum_custom = $s['enum_custom'];
      $this->was_enum_custom_set = true;
    } else {
      $this->enum_custom = \bing\bong\AEnum1::pb_CLASS;
      $this->was_enum_custom_set = false;
    }
    if (Shapes::keyExists($s, 'adouble')) {
      $this->adouble = $s['adouble'];
      $this->was_adouble_set = true;
    } else {
      $this->adouble = (float)3;
      $this->was_adouble_set = false;
    }
    if (Shapes::keyExists($s, 'afloat')) {
      $this->afloat = $s['afloat'];
      $this->was_afloat_set = true;
    } else {
      $this->afloat = (float)4.5;
      $this->was_afloat_set = false;
    }
    if (Shapes::keyExists($s, 'abool')) {
      $this->abool = $s['abool'];
      $this->was_abool_set = true;
    } else {
      $this->abool = true;
      $this->was_abool_set = false;
    }
    if (Shapes::keyExists($s, 'astring')) {
      $this->astring = $s['astring'];
      $this->was_astring_set = true;
    } else {
      $this->astring = 'custom!';
      $this->was_astring_set = false;
    }
    if (Shapes::keyExists($s, 'abytes')) {
      $this->abytes = $s['abytes'];
      $this->was_abytes_set = true;
    } else {
      $this->abytes = \stripcslashes('foo');
      $this->was_abytes_set = false;
    }
    $this->required_field = $s['required_field'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function getEnumDefault(): \bing\bong\AEnum1_enum_t {
    return $this->enum_default;
  }

  public function setEnumDefault(\bing\bong\AEnum1_enum_t $v): void {
    $this->enum_default = $v;
    $this->was_enum_default_set = true;
  }

  public function hasEnumDefault(): bool {
    return $this->was_enum_default_set;
  }

  public function getEnumCustom(): \bing\bong\AEnum1_enum_t {
    return $this->enum_custom;
  }

  public function setEnumCustom(\bing\bong\AEnum1_enum_t $v): void {
    $this->enum_custom = $v;
    $this->was_enum_custom_set = true;
  }

  public function hasEnumCustom(): bool {
    return $this->was_enum_custom_set;
  }

  public function getAdouble(): float {
    return $this->adouble;
  }

  public function setAdouble(float $v): void {
    $this->adouble = $v;
    $this->was_adouble_set = true;
  }

  public function hasAdouble(): bool {
    return $this->was_adouble_set;
  }

  public function getAfloat(): float {
    return $this->afloat;
  }

  public function setAfloat(float $v): void {
    $this->afloat = $v;
    $this->was_afloat_set = true;
  }

  public function hasAfloat(): bool {
    return $this->was_afloat_set;
  }

  public function getAbool(): bool {
    return $this->abool;
  }

  public function setAbool(bool $v): void {
    $this->abool = $v;
    $this->was_abool_set = true;
  }

  public function hasAbool(): bool {
    return $this->was_abool_set;
  }

  public function getAstring(): string {
    return $this->astring;
  }

  public function setAstring(string $v): void {
    $this->astring = $v;
    $this->was_astring_set = true;
  }

  public function hasAstring(): bool {
    return $this->was_astring_set;
  }

  public function getAbytes(): string {
    return $this->abytes;
  }

  public function setAbytes(string $v): void {
    $this->abytes = $v;
    $this->was_abytes_set = true;
  }

  public function hasAbytes(): bool {
    return $this->was_abytes_set;
  }

  public function MessageName(): string {
    return "bing.bong.example1";
  }

  public static function ParseFrom(string $input): ?example1 {
    $msg = new example1();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->enum_default = \bing\bong\AEnum1::FromInt($d->readVarint());
          $this->was_enum_default_set = true;
          break;
        case 2:
          $this->enum_custom = \bing\bong\AEnum1::FromInt($d->readVarint());
          $this->was_enum_custom_set = true;
          break;
        case 3:
          $this->adouble = $d->readDouble();
          $this->was_adouble_set = true;
          break;
        case 4:
          $this->afloat = $d->readFloat();
          $this->was_afloat_set = true;
          break;
        case 5:
          $this->abool = $d->readBool();
          $this->was_abool_set = true;
          break;
        case 6:
          $this->astring = $d->readString();
          $this->was_astring_set = true;
          break;
        case 7:
          $this->abytes = $d->readString();
          $this->was_abytes_set = true;
          break;
        case 8:
          $this->required_field = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->was_enum_default_set) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->enum_default);
    }
    if ($this->was_enum_custom_set) {
      $e->writeTag(2, 0);
      $e->writeVarint($this->enum_custom);
    }
    if ($this->was_adouble_set) {
      $e->writeTag(3, 1);
      $e->writeDouble($this->adouble);
    }
    if ($this->was_afloat_set) {
      $e->writeTag(4, 5);
      $e->writeFloat($this->afloat);
    }
    if ($this->was_abool_set) {
      $e->writeTag(5, 0);
      $e->writeBool($this->abool);
    }
    if ($this->was_astring_set) {
      $e->writeTag(6, 2);
      $e->writeString($this->astring);
    }
    if ($this->was_abytes_set) {
      $e->writeTag(7, 2);
      $e->writeString($this->abytes);
    }
    if ($this->required_field !== '') {
      $e->writeTag(8, 2);
      $e->writeString($this->required_field);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    if ($this->hasEnumDefault()) {
      $e->writeEnum('enum_default', 'enumDefault', \bing\bong\AEnum1::ToStringDict(), $this->enum_default, false);
    }
    if ($this->hasEnumCustom()) {
      $e->writeEnum('enum_custom', 'enumCustom', \bing\bong\AEnum1::ToStringDict(), $this->enum_custom, false);
    }
    if ($this->hasAdouble()) {
      $e->writeFloat('adouble', 'adouble', $this->adouble, false);
    }
    if ($this->hasAfloat()) {
      $e->writeFloat('afloat', 'afloat', $this->afloat, false);
    }
    if ($this->hasAbool()) {
      $e->writeBool('abool', 'abool', $this->abool, false);
    }
    if ($this->hasAstring()) {
      $e->writeString('astring', 'astring', $this->astring, false);
    }
    if ($this->hasAbytes()) {
      $e->writeBytes('abytes', 'abytes', $this->abytes, false);
    }
    $e->writeString('required_field', 'requiredField', $this->required_field, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'enum_default': case 'enumDefault':
          $this->enum_default = \bing\bong\AEnum1::FromMixed($v);
          $this->was_enum_default_set = true;
          break;
        case 'enum_custom': case 'enumCustom':
          $this->enum_custom = \bing\bong\AEnum1::FromMixed($v);
          $this->was_enum_custom_set = true;
          break;
        case 'adouble':
          $this->adouble = \Protobuf\Internal\JsonDecoder::readFloat($v);
          $this->was_adouble_set = true;
          break;
        case 'afloat':
          $this->afloat = \Protobuf\Internal\JsonDecoder::readFloat($v);
          $this->was_afloat_set = true;
          break;
        case 'abool':
          $this->abool = \Protobuf\Internal\JsonDecoder::readBool($v);
          $this->was_abool_set = true;
          break;
        case 'astring':
          $this->astring = \Protobuf\Internal\JsonDecoder::readString($v);
          $this->was_astring_set = true;
          break;
        case 'abytes':
          $this->abytes = \Protobuf\Internal\JsonDecoder::readBytes($v);
          $this->was_abytes_set = true;
          break;
        case 'required_field': case 'requiredField':
          $this->required_field = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is example1)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    if ($o->hasEnumDefault()) {
      $this->setEnumDefault($o->getEnumDefault());
    }
    if ($o->hasEnumCustom()) {
      $this->setEnumCustom($o->getEnumCustom());
    }
    if ($o->hasAdouble()) {
      $this->setAdouble($o->getAdouble());
    }
    if ($o->hasAfloat()) {
      $this->setAfloat($o->getAfloat());
    }
    if ($o->hasAbool()) {
      $this->setAbool($o->getAbool());
    }
    if ($o->hasAstring()) {
      $this->setAstring($o->getAstring());
    }
    if ($o->hasAbytes()) {
      $this->setAbytes($o->getAbytes());
    }
    $this->required_field = $o->required_field;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_test_proto2_ex1__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'test/proto2_ex1.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 1102 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\x74\x8f\xc1\x4a\xc3\x40\x10\x86\xd9\xa4\x69\x9a\xb1\x96\xba\x20\x2c\xf6\xb2\x15\x84\xc5\x43\xa4\xb5\x1e\xcc\xad\x56\x3d\x79\xda\x3e\x40\xd8\x98\x49\x9\x24\xd9\x9a\xec\x42\x7d\x33\x1f\x4f\x92\x34\xde\x3c\xcd\xcc\xc7\x37\xc3\xfc\x70\x6d\xb0\x31\xf\xc7\x5a\x1b\xbd\x8e\xf1\xb4\xa\xbb\x96\x6\x49\x5e\x1d\xc2\x44\x57\x87\xdb\x1f\x7\x26\x78\x52\xe5\xb1\xc0\x15\xdd\xc0\x14\x2b\x5b\xc6\x29\x66\xca\x16\x86\x11\x4e\xc4\x6c\x7d\x15\xfe\xe9\xe1\xf6\xad\xb2\xe5\x4a\x5e\xb4\xda\x6b\x6f\xd1\x67\xe8\xc6\xf8\xd3\x36\x46\x97\xcc\xf9\x67\x29\xf2\x76\x1f\xdb\xfd\x5e\x42\x2b\xef\x3a\x97\x2e\xc0\x57\xa9\xb6\x49\x81\xcc\xe5\x44\x90\x88\x3c\xca\x81\xd0\x5\x8c\x55\x56\x68\x65\xd8\x88\x13\xe1\x44\xee\x26\x7c\x92\x67\x44\x6f\xc0\x53\x89\xd6\x5\xf3\x38\x11\x93\x68\x64\x6a\x8b\xb2\x47\x74\x9\xbe\x6a\x4c\x9d\x57\x7\x36\xe6\x44\x4\x91\xdf\xbf\xb6\x94\x3\xef\x6e\x27\xdf\x6\x1b\xe6\x73\x22\xa6\x91\x9b\x69\x2d\xcf\x88\xde\xc1\xac\xc6\x2f\x9b\xd7\x98\xc6\x59\x8e\x45\xca\x26\xdc\x11\x81\xbc\x1c\xe8\x7b\xb\xef\x97\x30\xee\x93\x51\xf\xc8\x76\xee\xb6\xe5\x65\x4e\x68\x0\x7d\xd2\x39\xfc\x6\x0\x0\xff\xff\xed\xcc\x6a\x2c");
  }
}
