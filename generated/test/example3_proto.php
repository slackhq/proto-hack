<?hh // strict

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: test/example3.proto

class Donkey implements \Protobuf\Message {
  public string $hi;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'hi' => string,
  ) $s = shape()) {
    $this->hi = $s['hi'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "Donkey";
  }

  public static function ParseFrom(string $input): ?Donkey {
    $msg = new Donkey();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->hi = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->hi !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->hi);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('hi', 'hi', $this->hi, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'hi':
          $this->hi = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Donkey)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->hi = $o->hi;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class Funky_Monkey implements \Protobuf\Message {
  public string $hi;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'hi' => string,
  ) $s = shape()) {
    $this->hi = $s['hi'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "Funky.Monkey";
  }

  public static function ParseFrom(string $input): ?Funky_Monkey {
    $msg = new Funky_Monkey();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->hi = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->hi !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->hi);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('hi', 'hi', $this->hi, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'hi':
          $this->hi = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Funky_Monkey)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->hi = $o->hi;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class Funky implements \Protobuf\Message {
  public ?\Funky_Monkey $monkey;
  public ?\Donkey $dokey;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'monkey' => ?\Funky_Monkey,
    ?'dokey' => ?\Donkey,
  ) $s = shape()) {
    $this->monkey = $s['monkey'] ?? null;
    $this->dokey = $s['dokey'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "Funky";
  }

  public static function ParseFrom(string $input): ?Funky {
    $msg = new Funky();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($this->monkey is null) {
            $this->monkey = new \Funky_Monkey();
          }
          $this->monkey->MergeFrom($d->readDecoder());
          break;
        case 2:
          if ($this->dokey is null) {
            $this->dokey = new \Donkey();
          }
          $this->dokey->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $msg = $this->monkey;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $msg = $this->dokey;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 2);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('monkey', 'monkey', $this->monkey, false);
    $e->writeMessage('dokey', 'dokey', $this->dokey, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'monkey':
          if ($v is null) break;
          if ($this->monkey is null) {
            $this->monkey = new \Funky_Monkey();
          }
          $this->monkey->MergeJsonFrom($v);
          break;
        case 'dokey':
          if ($v is null) break;
          if ($this->dokey is null) {
            $this->dokey = new \Donkey();
          }
          $this->dokey->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is Funky)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $tmp = $o->monkey;
    if ($tmp is nonnull) {
      $nv = new \Funky_Monkey();
      $nv->CopyFrom($tmp);
      $this->monkey = $nv;
    }
    $tmp = $o->dokey;
    if ($tmp is nonnull) {
      $nv = new \Donkey();
      $nv->CopyFrom($tmp);
      $this->dokey = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_test_example3__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'test/example3.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 472 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\xe2\x12\x2e\x49\x2d\x2e\xd1\x4f\xad\x48\xcc\x2d\xc8\x49\x35\xd6\x2b\x28\xca\x2f\xc9\x57\x92\xe0\x62\x73\xc9\xcf\xcb\x4e\xad\x14\xe2\xe3\x62\xca\xc8\x94\x60\x54\x60\xd4\xe0\xc\x62\xca\xc8\x54\x4a\xe7\x62\x75\x2b\xcd\xcb\xae\x14\x52\xe5\x62\xcb\x5\x2b\x1\x4b\x72\x1b\xf1\xea\x81\xc5\xf5\x7c\xc1\x82\x41\x50\x49\x21\x59\x2e\xd6\x94\x7c\x90\x2a\x26\xb0\x2a\x76\x3d\x88\xb9\x41\x10\x51\x29\x9\x2e\x36\x5f\xac\x16\x25\xb1\x81\x5d\x62\xc\x8\x0\x0\xff\xff\xb9\xd4\x2a\xde");
  }
}
