<?hh // strict

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: test/example4.proto

class pb_Class implements \Protobuf\Message {
  public string $name;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "Class";
  }

  public static function ParseFrom(string $input): ?pb_Class {
    $msg = new pb_Class();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is pb_Class)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class pb_Interface implements \Protobuf\Message {
  public ?\pb_Class $class;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'class' => ?\pb_Class,
  ) $s = shape()) {
    $this->class = $s['class'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "Interface";
  }

  public static function ParseFrom(string $input): ?pb_Interface {
    $msg = new pb_Interface();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($this->class is null) {
            $this->class = new \pb_Class();
          }
          $this->class->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $msg = $this->class;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('class', 'class', $this->class, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'class':
          if ($v is null) break;
          if ($this->class is null) {
            $this->class = new \pb_Class();
          }
          $this->class->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is pb_Interface)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $tmp = $o->class;
    if ($tmp is nonnull) {
      $nv = new \pb_Class();
      $nv->CopyFrom($tmp);
      $this->class = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class NotClass implements \Protobuf\Message {
  public string $name;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'name' => string,
  ) $s = shape()) {
    $this->name = $s['name'] ?? '';
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "NotClass";
  }

  public static function ParseFrom(string $input): ?NotClass {
    $msg = new NotClass();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->name = $d->readString();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->name !== '') {
      $e->writeTag(1, 2);
      $e->writeString($this->name);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeString('name', 'name', $this->name, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'name':
          $this->name = \Protobuf\Internal\JsonDecoder::readString($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is NotClass)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->name = $o->name;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class AndClient {
  public function __construct(private \Grpc\Invoker $invoker) {
  }

  public async function throw(\Grpc\Context $ctx, \pb_Class $in, \Grpc\CallOption ...$co): Awaitable<\Errors\Result<\google\protobuf\pb_Empty>> {
    $out = new \google\protobuf\pb_Empty();
    $err = await $this->invoker->Invoke($ctx, '/And/throw', $in, $out, ...$co);
    if ($err->Ok()) {
      return \Errors\ResultV($out);
    }
    return \Errors\ResultE($err);
  }
}

interface AndServer {
  public function throw(\Grpc\Context $ctx, \pb_Class $in): Awaitable<\Errors\Result<\google\protobuf\pb_Empty>>;
}

function AndServiceDescriptor(AndServer $service): \Grpc\ServiceDesc {
  $methods = vec[];
  $handler = async (\Grpc\Context $ctx, \Grpc\Unmarshaller $u): Awaitable<\Errors\Result<\Protobuf\Message>> ==> {
    $in = new \pb_Class();
    $err = $u->Unmarshal($in);
    if (!$err->Ok()) {
      return \Errors\ResultE(\Errors\Errorf('proto unmarshal: %s', $err->Error()));
    }
    return (await $service->throw($ctx, $in))->As<\Protobuf\Message>();
  };
  $methods []= new \Grpc\MethodDesc('throw', $handler);
  return new \Grpc\ServiceDesc('And', $methods);
}

function RegisterAndServer(\Grpc\Server $server, AndServer $service): void {
  $server->RegisterService(AndServiceDescriptor($service));
}

class XXX_FileDescriptor_test_example4__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'test/example4.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 626 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\xe2\x12\x2e\x49\x2d\x2e\xd1\x4f\xad\x48\xcc\x2d\xc8\x49\x35\xd1\x2b\x28\xca\x2f\xc9\x97\x92\x4e\xcf\xcf\x4f\xcf\x49\xd5\x7\xf3\x92\x4a\xd3\xf4\x53\x73\xb\x4a\x2a\x21\x92\x4a\xd2\x5c\xac\xce\x39\x89\xc5\xc5\x42\x42\x5c\x2c\x79\x89\xb9\xa9\x12\x8c\xa\x8c\x1a\x9c\x41\x60\xb6\x92\x26\x17\xa7\x67\x5e\x49\x6a\x51\x5a\x62\x72\xaa\x90\xc\x17\x6b\x32\x48\x25\x58\x5\xb7\x11\x9b\x1e\x58\x5f\x10\x44\x50\x49\x8e\x8b\xc3\x2f\xbf\x4\xa7\x51\x46\x6\x5c\xcc\x8e\x79\x29\x42\x9a\x5c\xac\x25\x19\x45\xf9\xe5\x42\x50\xed\x52\x62\x7a\x10\xd7\xe9\xc1\x5c\xa7\xe7\xa\x72\x9d\x12\x43\x12\x1b\x58\xc4\x18\x10\x0\x0\xff\xff\x56\x33\x3e\x22");
  }
}
