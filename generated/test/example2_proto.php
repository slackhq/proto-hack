<?hh // strict
namespace fiz\baz;
// custom namespace is unimplemented: 'fizzy\bazzy'

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source: test/example2.proto

newtype AEnum2_enum_t as int = int;
abstract class AEnum2 {
  const AEnum2_enum_t Z = 0;
  private static dict<int, string> $itos = dict[
    0 => 'Z',
  ];
  public static function ToStringDict(): dict<int, string> {
    return self::$itos;
  }
  private static dict<string, int> $stoi = dict[
    'Z' => 0,
  ];
  public static function FromMixed(mixed $m): AEnum2_enum_t {
    if ($m is string) return idx(self::$stoi, $m, \is_numeric($m) ? ((int) $m) : 0);
    if ($m is int) return $m;
    return 0;
  }
  public static function FromInt(int $i): AEnum2_enum_t {
    return $i;
  }
}

class example2 implements \Protobuf\Message {
  public int $zomg;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'zomg' => int,
  ) $s = shape()) {
    $this->zomg = $s['zomg'] ?? 0;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "fiz.baz.example2";
  }

  public static function ParseFrom(string $input): ?example2 {
    $msg = new example2();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          $this->zomg = $d->readVarint32Signed();
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    if ($this->zomg !== 0) {
      $e->writeTag(1, 0);
      $e->writeVarint($this->zomg);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeInt32('zomg', 'zomg', $this->zomg, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'zomg':
          $this->zomg = \Protobuf\Internal\JsonDecoder::readInt32Signed($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is example2)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $this->zomg = $o->zomg;
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}

class refexample3 implements \Protobuf\Message {
  public ?\Funky $funky;
  private string $XXX_unrecognized;

  public function __construct(shape(
    ?'funky' => ?\Funky,
  ) $s = shape()) {
    $this->funky = $s['funky'] ?? null;
    $this->XXX_unrecognized = '';
  }

  public function MessageName(): string {
    return "fiz.baz.refexample3";
  }

  public static function ParseFrom(string $input): ?refexample3 {
    $msg = new refexample3();
    $e = \Protobuf\Unmarshal($input, $msg);
    if (!$e->Ok()) {
      return null;
    }
    return $msg;
  }

  public function MergeFrom(\Protobuf\Internal\Decoder $d): void {
    while (!$d->isEOF()){
      list($fn, $wt) = $d->readTag();
      switch ($fn) {
        case 1:
          if ($this->funky is null) {
            $this->funky = new \Funky();
          }
          $this->funky->MergeFrom($d->readDecoder());
          break;
        default:
          $d->skip($fn, $wt);
      }
    }
    $this->XXX_unrecognized = $d->skippedRaw();
  }

  public function WriteTo(\Protobuf\Internal\Encoder $e): void {
    $msg = $this->funky;
    if ($msg != null) {
      $nested = new \Protobuf\Internal\Encoder();
      $msg->WriteTo($nested);
      $e->writeEncoder($nested, 1);
    }
    $e->writeRaw($this->XXX_unrecognized);
  }

  public function WriteJsonTo(\Protobuf\Internal\JsonEncoder $e): void {
    $e->writeMessage('funky', 'funky', $this->funky, false);
  }

  public function MergeJsonFrom(mixed $m): void {
    if ($m === null) return;
    $d = \Protobuf\Internal\JsonDecoder::readObject($m);
    foreach ($d as $k => $v) {
      switch ($k) {
        case 'funky':
          if ($v is null) break;
          if ($this->funky is null) {
            $this->funky = new \Funky();
          }
          $this->funky->MergeJsonFrom($v);
          break;
        default:
        break;
      }
    }
  }

  public function CopyFrom(\Protobuf\Message $o): \Errors\Error {
    if (!($o is refexample3)) {
      return \Errors\Errorf('CopyFrom failed: incorrect type received: %s', $o->MessageName());
    }
    $tmp = $o->funky;
    if ($tmp is nonnull) {
      $nv = new \Funky();
      $nv->CopyFrom($tmp);
      $this->funky = $nv;
    }
    $this->XXX_unrecognized = $o->XXX_unrecognized;
    return \Errors\Ok();
  }
}


class XXX_FileDescriptor_test_example2__proto implements \Protobuf\Internal\FileDescriptor {
  const string NAME = 'test/example2.proto';
  public function Name(): string {
    return self::NAME;
  }

  public function FileDescriptorProtoBytes(): string {
    // 652 bytes of gzipped FileDescriptorProto as a string
    return (string)\gzuncompress("\x78\xda\xe2\x12\x2e\x49\x2d\x2e\xd1\x4f\xad\x48\xcc\x2d\xc8\x49\x35\xd2\x2b\x28\xca\x2f\xc9\x17\x62\x4f\xcb\xac\xd2\x4b\x4a\xac\x92\x42\x91\x35\x86\xc8\x4a\xc9\xe4\x17\x94\xe8\x83\x99\xf1\x19\x89\xc9\xd9\xf1\xf9\x5\x25\x99\xf9\x79\xc5\x10\x59\x25\x39\x2e\xe\x98\x69\x42\x42\x5c\x2c\x55\xf9\xb9\xe9\x12\x8c\xa\x8c\x1a\xac\x41\x60\xb6\x92\x36\x17\x77\x51\x6a\x1a\xcc\x48\x21\x19\x2e\xd6\xb4\xd2\xbc\xec\x4a\xb0\x1a\x6e\x23\x36\x3d\x37\x10\x2f\x8\x22\xa8\xc5\xcf\xc5\xe6\xe8\x9a\x57\x9a\x6b\x24\xc4\xca\xc5\x18\x25\xc0\xe0\x24\x78\xea\xdd\x8e\x66\x76\xee\xb4\xcc\xaa\xaa\xca\x98\xa4\xc4\xaa\xaa\xca\x24\x36\xb0\xbd\xc6\x80\x0\x0\x0\xff\xff\xc\xde\x3f\xd7");
  }
}
